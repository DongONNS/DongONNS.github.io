{"meta":{"title":"Dongonns","subtitle":"To change the fate of the first to change their own.","description":"Master record","author":"Dongcheng","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于","date":"2020-11-05T11:13:57.000Z","updated":"2020-11-05T11:19:25.539Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-10-20T06:46:36.000Z","updated":"2020-11-05T11:18:04.500Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-11-05T11:13:45.000Z","updated":"2020-11-05T11:18:42.649Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"favorite","date":"2020-11-05T04:44:52.000Z","updated":"2020-11-05T04:45:25.406Z","comments":true,"path":"favorite/index.html","permalink":"http://yoursite.com/favorite/index.html","excerpt":"","text":""},{"title":"资源","date":"2020-11-05T11:14:34.000Z","updated":"2020-11-05T11:20:00.428Z","comments":false,"path":"resources/index.html","permalink":"http://yoursite.com/resources/index.html","excerpt":"","text":""}],"posts":[{"title":"Springboot学习","slug":"Springboot学习","date":"2019-11-16T14:17:43.000Z","updated":"2020-11-05T12:19:52.814Z","comments":true,"path":"2019/11/16/Springboot学习/","link":"","permalink":"http://yoursite.com/2019/11/16/Springboot%E5%AD%A6%E4%B9%A0/","excerpt":"@PoatConstruct有什么作用PostConstruct注释用于在完成依赖项注入以执行任何初始化之后需要执行的方法。必须在类投入使用之前调用此方法。","text":"@PoatConstruct有什么作用PostConstruct注释用于在完成依赖项注入以执行任何初始化之后需要执行的方法。必须在类投入使用之前调用此方法。 所有支持依赖注入的类都必须支持此注释。即使类没有请求注入任何资源，也必须调用使用PostConstruct注释的方法。 只有一个方法可以使用此批注进行批注。 应用PostConstruct注释的方法必须满足以下所有条件：除了拦截器之外，方法绝不能有任何参数，在这种情况下它采用Interceptor规范定义的InvocationContext对象。 在拦截器类上定义的方法必须具有以下签名之一： void （InvocationContext）Object （InvocationContext）抛出异常注意：PostConstruct拦截器方法不能抛出应用程序异常，但可以声明它抛出检查异常，包括java.lang.Exception， 如果相同的拦截器方法除了生命周期事件之外插入业务或超时方法。 如果PostConstruct拦截器方法返回一个值，容器将忽略它。 在非拦截器类上定义的方法必须具有以下签名：void （）应用PostConstruct的方法可以是public，protected，package private或private。 除应用程序客户端外，该方法绝不能是静态的。 该方法可能是最终的。如果该方法抛出一个未经检查的异常，那么该类绝不能投入使用，除非EJB可以处理异常甚至从它们恢复的EJB。 构造方法 &gt; @Autowired &gt; @PostConstruct1、从Java EE5规范开始，Servlet中增加了两个影响Servlet生命周期的注解，@PostConstruct和@PreDestroy，这两个注解被用来修饰一个非静态的void（）方法。写法有如下两种方式： @PostConstruct public void someMethod(){} 或者 public @PostConstruct void someMethod(){} 被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器执行一次。PostConstruct在构造函数之后执行，init（）方法之前执行。PreDestroy（）方法在destroy（）方法知性之后执行 执行顺序 另外，spring中Constructor、@Autowired、@PostConstruct的顺序其实从依赖注入的字面意思就可以知道，要将对象p注入到对象a，那么首先就必须得生成对象a和对象p，才能执行注入。所以，如果一个类A中有个成员变量p被@Autowried注解，那么@Autowired注入是发生在A的构造方法执行完之后的。如果想在生成对象时完成某些初始化操作，而偏偏这些初始化操作又依赖于依赖注入，那么久无法在构造函数中实现。为此，可以使用@PostConstruct注解一个方法来完成初始化，@PostConstruct注解的方法将会在依赖注入完成后被自动调用。Constructor &gt;&gt; @Autowired &gt;&gt; @PostConstruct @Aspect的作用是什么？AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术.AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 在spring AOP中业务逻辑仅仅只关注业务本身，将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改变这些行为的时候不影响业务逻辑的代码。 @Aspect:作用是把当前类标识为一个切面供容器读取 @Pointcut：Pointcut是植入Advice的触发条件。每个Pointcut的定义包括2部分，一是表达式，二是方法签名。方法签名必须是 public及void型。可以将Pointcut中的方法看作是一个被Advice引用的助记符，因为表达式不直观，因此我们可以通过方法签名的方式为 此表达式命名。因此Pointcut中的方法只需要方法签名，而不需要在方法体内编写实际代码。 @Around：环绕增强，相当于MethodInterceptor @AfterReturning：后置增强，相当于AfterReturningAdvice，方法正常退出时执行 @Before：标识一个前置增强方法，相当于BeforeAdvice的功能，相似功能的还有 @AfterThrowing：异常抛出增强，相当于ThrowsAdvice @After: final增强，不管是抛出异常或者正常退出都会执行Spring AOP面向切面编程，可以用来配置事务、做日志、权限验证、在用户请求时做一些处理等等。用@Aspect做一个切面，就可以直接实现。 1.首先定义一个切面类，加上@Component @Aspect这两个注解 @Component @Aspect public class LogAspect &#123; private static final Logger logger = LoggerFactory.getLogger(LogAspect.class); private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper(); &#125;2.定义切点 private final String POINT_CUT = &quot;execution(public * com.xhx.springboot.controller.*.*(..))&quot;; @Pointcut(POINT_CUT) public void pointCut()&#123;&#125;切点表达式中，..两个点表明多个，代表一个， 上面表达式代表切入com.xhx.springboot.controller包下的所有类的所有方法，方法参数不限，返回类型不限。 其中访问修饰符可以不写，不能用，，第一个代表返回类型不限，第二个表示所有类，第三个*表示所有方法，..两个点表示方法里的参数不限。 然后用@Pointcut切点注解，想在一个空方法上面，一会儿在Advice通知中，直接调用这个空方法就行了，也可以把切点表达式卸载Advice通知中的，单独定义出来主要是为了好管理。 3.Advice，通知增强，主要包括五个注解Before,After,AfterReturning,AfterThrowing,Around，下面代码中关键地方都有注释，我都列出来了。 @Before 在切点方法之前执行 @After 在切点方法之后执行 @AfterReturning 切点方法返回后执行 @AfterThrowing 切点方法抛异常执行 @Around 属于环绕增强，能控制切点执行前，执行后，，用这个注解后，程序抛异常，会影响@AfterThrowing这个注解","categories":[{"name":"springboot","slug":"springboot","permalink":"http://yoursite.com/categories/springboot/"}],"tags":[]},{"title":"正则表达式","slug":"正则表达式","date":"2019-11-15T12:01:15.000Z","updated":"2019-11-15T15:17:59.602Z","comments":true,"path":"2019/11/15/正则表达式/","link":"","permalink":"http://yoursite.com/2019/11/15/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"&emsp;正则是一个非常重要的知识点，我在数据库、前端设计、爬虫等中都看到过很多，但是自己没有去刻意学习，每次都是自己去网上搜，今天就建立自己的正则库，方便自己以后翻阅，同时也用于把自己平时见到的一些巧妙的正则表达式往里面塞一塞。 一、什么是正则表达式？&emsp;&emsp;正则表达式，又称规则表达式，通常被用来检索、替换那些符合某个模式(规则)的文本。正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。 二、正则能干嘛？ 一是给定的字符串是否符合正则表达式的过滤逻辑（这个过程可称为“匹配”）； 二是通过正则表达式，从文本字符串中获取我们想要的特定部分（这个过程可称为“过滤”）。 三正表达式的语法^ 表示匹配字符串的开始位置 (例外 用在中括号中[ ] 时,可以理解为取反,表示不匹配括号中字符串) $ 表示匹配字符串的结束位置 * 表示匹配 零次到多次 + 表示匹配 一次到多次 (至少有一次) ? 表示匹配零次或一次 . 表示匹配单个字符 | 表示为或者,两项中取一项 ( ) 小括号表示匹配括号中全部字符 [ ] 中括号表示匹配括号中一个字符 范围描述 如[0-9 a-z A-Z] &#123; &#125; 大括号用于限定匹配次数 如 &#123;n&#125;表示匹配n个字符 &#123;n,&#125;表示至少匹配n个字符 &#123;n,m&#125;表示至少n,最多m \\ 转义字符 如上基本符号匹配都需要转义字符 如 \\* 表示匹配*号 \\w 表示英文字母和数字 \\W 非字母和数字 \\d 表示数字 \\D 非数字四、常用的正则表达式常用的正则表达式(转)匹配中文字符的正则表达式： [\\u4e00-\\u9fa5] 匹配双字节字符(包括汉字在内)：[^\\x00-\\xff] 匹配空行的正则表达式：\\n[\\s| ]*\\r 匹配HTML标记的正则表达式：/&lt;(.*)&gt;.*&lt;\\/\\1&gt;|&lt;(.*) \\/&gt;/ 匹配首尾空格的正则表达式：(^\\s*)|(\\s*$) 匹配IP地址的正则表达式：/(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)/g // 匹配Email地址的正则表达式：\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)* 匹配网址URL的正则表达式：http://(/[\\w-]+\\.)+[\\w-]+(/[\\w- ./?%&amp;=]*)? sql语句：^(select|drop|delete|create|update|insert).*$ 1、非负整数：^\\d+$ 2、正整数：^[0-9]*[1-9][0-9]*$ 3、非正整数：^((-\\d+)|(0+))$ 4、负整数：^-[0-9]*[1-9][0-9]*$ 5、整数：^-?\\d+$ 6、非负浮点数：^\\d+(\\.\\d+)?$ 7、正浮点数：^((0-9)+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$ 8、非正浮点数：^((-\\d+\\.\\d+)?)|(0+(\\.0+)?))$ 9、负浮点数：^(-((正浮点数正则式)))$ 10、英文字符串：^[A-Za-z]+$ 11、英文大写串：^[A-Z]+$ 12、英文小写串：^[a-z]+$ 13、英文字符数字串：^[A-Za-z0-9]+$ 14、英数字加下划线串：^\\w+$ 15、E-mail地址：^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$ 16、URL：^[a-zA-Z]+://(\\w+(-\\w+)*)(\\.(\\w+(-\\w+)*))*(\\?\\s*)?$或：^http:\\/\\/[A-Za-z0-9]+\\.[A-Za-z0-9]+[\\/=\\?%\\-&amp;_~@[]&#39;:+!]([^&lt;&gt;&quot;&quot;])$` 17、邮政编码：^[1-9]\\d&#123;5&#125;$ 18、中文：^[\\u0391-\\uFFE5]+$ 19、电话号码：^((\\d2,3)|(\\d&#123;3&#125;\\-))?(0\\d2,3|0\\d&#123;2,3&#125;-)?[1-9]\\d&#123;6,7&#125;(\\-\\d&#123;1,4&#125;)?$ 20、手机号码：^((\\d2,3)|(\\d&#123;3&#125;\\-))?13\\d&#123;9&#125;$ 21、双字节字符(包括汉字在内)：^\\x00-\\xff 22、匹配首尾空格：(^\\s*)|(\\s*$)（像vbscript那样的trim函数） 23、匹配HTML标记：&lt;(.*)&gt;.*&lt;\\/\\1&gt;|&lt;(.*) \\/&gt; 24、匹配空行：\\n[\\s| ]*\\r 25、提取信息中的网络链接：(h|H)(r|R)(e|E)(f|F) *= *(&#39;|&quot;)?(\\w|\\\\|\\/|\\.)+(&#39;|&quot;| *|&gt;)? 26、提取信息中的邮件地址：\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)* 27、提取信息中的图片链接：(s|S)(r|R)(c|C) *= *(&#39;|&quot;)?(\\w|\\\\|\\/|\\.)+(&#39;|&quot;| *|&gt;)? 28、提取信息中的IP地址：(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+) 29、提取信息中的中国手机号码：(86)*0*13\\d&#123;9&#125; 30、提取信息中的中国固定电话号码：(\\d3,4|\\d&#123;3,4&#125;-|\\s)?\\d&#123;8&#125; 31、提取信息中的中国电话号码（包括移动和固定电话）：(\\d3,4|\\d&#123;3,4&#125;-|\\s)?\\d&#123;7,14&#125; 32、提取信息中的中国邮政编码：[1-9]&#123;1&#125;(\\d+)&#123;5&#125; 33、提取信息中的浮点数（即小数）：(-?\\d*)\\.?\\d+ 34、提取信息中的任何数字 ：(-?\\d*)(\\.\\d+)? 35、IP：(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+) 36、电话区号：/^0\\d&#123;2,3&#125;$/ 37、腾讯QQ号：^[1-9]*[1-9][0-9]*$ 38、帐号(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$ 39、中文、英文、数字及下划线：^[\\u4e00-\\u9fa5_a-zA-Z0-9]+$","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/categories/%E7%88%AC%E8%99%AB/"}],"tags":[]},{"title":"springboot2——Metrics","slug":"springboot2——Metrics","date":"2019-11-13T12:49:11.000Z","updated":"2019-11-13T12:58:57.430Z","comments":true,"path":"2019/11/13/springboot2——Metrics/","link":"","permalink":"http://yoursite.com/2019/11/13/springboot2%E2%80%94%E2%80%94Metrics/","excerpt":"","text":"Metrics&emsp;&emsp;Spring Boot Actuator为Micrometer提供了依赖项管理和自动配置，Micrometer是一种支持大量监视系统的应用程序指标展示，包括：AppOptics、Atlas、Datadog、Dynatrace、Elastic、Ganglia、Graphite、Humio、Influx、JMX、KairosDB、New Relic、Prometheus、SignalFx、Simple (in-memory)、StatsD、Wavefront。 &emsp;&emsp;要了解有关Micrometer功能的更多信息，请参阅其参考文档，特别是概念部分。 1 入门&emsp;&emsp;Spring Boot自动配置组合MeterRegistry，并为其在类路径上找到的每个支持的实现向组合添加注册表。在micrometer-registry-{system}运行时类路径中具有依赖项足以让Spring Boot配置注册表。 &emsp;&emsp;大多数注册表具有共同的特征。例如，即使Micrometer注册表实现位于类路径中，您也可以禁用特定的注册表。例如，禁用Datadog： management.metrics.export.datadog.enabled=false&emsp;&emsp;Spring Boot还会将任何自动配置的注册表添加到Metrics该类的全局静态复合注册表中，除非您明确告诉它不要： management.metrics.use-global-registry=false&emsp;&emsp;您可以注册任意数量的MeterRegistryCustomizerbean来进一步配置注册表，例如在向注册表注册任何计量器(meter)之前应用通用标签： @Bean MeterRegistryCustomizer&lt;MeterRegistry&gt; metricsCommonTags() &#123; return registry -&gt; registry.config().commonTags(&quot;region&quot;, &quot;us-east-1&quot;); &#125;&emsp;&emsp;您可以通过更具体地了解通用类型，将自定义项应用于特定的注册表实现： @Bean MeterRegistryCustomizer&lt;GraphiteMeterRegistry&gt; graphiteMetricsNamingConvention() &#123; return registry -&gt; registry.config().namingConvention(MY_CUSTOM_CONVENTION); &#125;&emsp;&emsp;完成该设置后，您可以注入MeterRegistry组件并注册指标： @Component public class SampleBean &#123; private final Counter counter; public SampleBean(MeterRegistry registry) &#123; this.counter = registry.counter(&quot;received.messages&quot;); &#125; public void handleMessage(String message) &#123; this.counter.increment(); // handle message implementation &#125; &#125;&emsp;&emsp;Spring Boot还配置了内置工具（即MeterBinder实现），您可以通过配置或专用注释标记来控制它们。 2 支持的监控系统–Prometheus&emsp;&emsp;Prometheus希望抓取或轮询单个应用程序实例以获取指标。Spring Boot提供了一个可用的执行器端点/actuator/prometheus以适当的格式显示Prometheus抓取。 &emsp;&emsp;端点默认情况下不可用，必须公开，有关更多详细信息，请参见暴露端点。 &emsp;&emsp;这是scrape_config要添加到的示例prometheus.yml： scrape_configs: - job_name: &apos;spring&apos; metrics_path: &apos;/actuator/prometheus&apos; static_configs: - targets: [&apos;HOST:PORT&apos;]&emsp;&emsp;对于短暂的或批处理的工作，其时间可能不够长，无法被抓取，可以使用Prometheus Pushgateway支持将其指标暴露给Prometheus。要启用Prometheus Pushgateway支持，请在项目中添加以下依赖项： &lt;dependency&gt; &lt;groupId&gt;io.prometheus&lt;/groupId&gt; &lt;artifactId&gt;simpleclient_pushgateway&lt;/artifactId&gt; &lt;/dependency&gt;&emsp;&emsp;当在类路径中存在Prometheus Pushgateway依赖项时，Spring Boot会自动配置PrometheusPushGatewayManager组件。这可以管理将指标推送到Prometheus Pushgateway。PrometheusPushGatewayManager可以在使用属性management.metrics.export.prometheus.pushgateway配置。对于高级配置，您还可以提供自己的PrometheusPushGatewayManager组件。 3 支持的指标&emsp;&emsp;如果适用，Spring Boot将注册以下核心指标： JVM指标，报告以下各项的利用率： &emsp;&emsp;&emsp;&emsp;各种内存和缓冲池 &emsp;&emsp;&emsp;&emsp;与垃圾收集有关的统计数据 &emsp;&emsp;&emsp;&emsp;线程利用率 &emsp;&emsp;&emsp;&emsp;加载/卸载的类数 CPU指标 文件描述符指标 卡夫卡消耗指标 Log4j2指标：记录每个级别记录到Log4j2的事件数 Logback指标：记录每个级别记录到Logback的事件数 正常运行时间指标：报告正常运行时间的量度和代表应用程序绝对启动时间的固定量度 Tomcat指标（server.tomcat.mbeanregistry.enabled必须设置true为才能注册所有Tomcat指标） Spring集成指标 Spring MVC指标&emsp;&emsp;通过自动配置，可以检测由Spring MVC处理的请求。当management.metrics.web.server.request.autotime.enabled为true时，将对所有请求进行这种检测。或者，当设置为false时，可以通过添加@Timed到请求处理方法来启用检测： @RestController @Timed public class MyController &#123; @GetMapping(&quot;/api/people&quot;) @Timed(extraTags = &#123; &quot;region&quot;, &quot;us-east-1&quot; &#125;) @Timed(value = &quot;all.people&quot;, longTask = true) public List&lt;Person&gt; listPeople() &#123; ... &#125; &#125;&emsp;&emsp;1.控制器类，用于对控制器中的每个请求处理程序启用计时。 &emsp;&emsp;2.一种启用单个端点的方法。如果您将它放在类中，则不必这样做，但是可以用于进一步为此特定端点自定义timer计时器。 &emsp;&emsp;3.一种longTask = true用于为该方法启用长任务计时器的方法。长任务计时器需要一个单独的度量metric名称，并且可以与短任务计时器堆叠在一起。 &emsp;&emsp;默认情况下，指标名称为http.server.requests。可以通过设置management.metrics.web.server.request.metric-name属性来自定义名称。 &emsp;&emsp;默认情况下，与Spring MVC相关的指标带有以下信息标记： 标签 描述 exception 处理请求时引发的任何异常的简单类名。 method 请求的方法（例如GET或POST） outcome 基于响应状态码的请求结果。1xx是INFORMATIONAL，2xx是SUCCESS，3xx是REDIRECTION，4xx CLIENT_ERROR和5xx是SERVER_ERROR status 响应的HTTP状态代码（例如200或500） uri 变量替换之前的请求URI模板（如果可能）（例如，/api/person/{id}） &emsp;&emsp;要自定义标签，请提供@Bean实现的WebMvcTagsProvider。 HTTP客户端指标&emsp;&emsp;启动器同时管理仪表RestTemplate和WebClient。为此，您必须注入自动配置的构建器并使用它来创建实例： RestTemplateBuilder 对于 RestTemplate WebClient.Builder 对于 WebClient &emsp;&emsp;也可以手动应用负责此工具的定制程序，即MetricsRestTemplateCustomizer和MetricsWebClientCustomizer。 &emsp;&emsp;默认情况下，指标名称为http.client.requests。可以通过设置management.metrics.web.client.request.metric-name属性来自定义名称。 &emsp;&emsp;默认情况下，通过检测的客户端生成的指标会标记以下信息： 标签 描述 clientName URI的主机部分 method 请求的方法（例如GET或POST） outcome 基于响应状态码的请求结果。1xx是INFORMATIONAL，2xx是SUCCESS，3xx是REDIRECTION，4xx CLIENT_ERROR和5xx是SERVER_ERROR，否则UNKNOWN status 响应的HTTP状态代码（例如200或500）（IO_ERROR如果存在I / O问题），否则CLIENT_ERROR uri 变量替换之前的请求URI模板（如果可能）（例如，/api/person/{id}） &emsp;&emsp;要自定义标签，并根据您选择的客户端，可以提供@Bean实现RestTemplateExchangeTagsProvider或WebClientExchangeTagsProvider。RestTemplateExchangeTags和WebClientExchangeTags中有方便的静态函数。 缓存指标&emsp;&emsp;通过自动配置可以在启动时使用前缀为Cache的指标来检测所有可用的cache。对于解百纳的cache信息是进行了标准化设置的。此外定制的cache指标也是可用的。 &emsp;&emsp;支持以下缓存库： Caffeine EhCache 2 Hazelcast Any compliant JCache (JSR-107) 的实现 &emsp;&emsp;指标由cache的名称以及CacheManager从Bean名称派生的的名称标记(添加tag)。 &emsp;&emsp;只有启动时可用的缓存才绑定到注册表。对于在启动阶段后即时或以编程方式创建的缓存，需要显式注册。可以使用CacheMetricsRegistrarBean来简化该过程。 数据源指标&emsp;&emsp;自动配置可使前缀为jdbc.connections的metric指标的所有DataSource对象可视化。数据源检测产生的gauge表示池中当前活动，空闲，最大允许和最小允许的连接。 &emsp;&emsp;metrics还通过DataSource基于bean名称的计算名称来标记（添加tag）。 &emsp;&emsp;默认情况下，Spring Boot为所有支持的数据源提供元数据。如果您喜欢的数据源不支持开箱即用，则可以添加其他DataSourcePoolMetadataProvider组件。请参阅DataSourcePoolMetadataProvidersConfiguration示例。 &emsp;&emsp;此外，Hikari特定指标带有hikaricp前缀。每个度量标准都以“池”的名称标记（可以通过来控制spring.datasource.name）。 4 注册自定义指标&emsp;&emsp;要注册自定义指标，请插入MeterRegistry到您的组件中，如以下示例所示： class Dictionary &#123; private final List&lt;String&gt; words = new CopyOnWriteArrayList&lt;&gt;(); Dictionary(MeterRegistry registry) &#123; registry.gaugeCollectionSize(&quot;dictionary.size&quot;, Tags.empty(), this.words); &#125; // … &#125;&emsp;&emsp;如果发现您反复在组件或应用程序中检测一组metrics，则可以将此组metrics封装在MeterBinder实现中。默认情况下，所有MeterBinderbean的metrics都将自动绑定到Spring-managed MeterRegistry。 5 自定义单个指标&emsp;&emsp;如果需要将自定义应用于特定Meter实例，则可以使用该io.micrometer.core.instrument.config.MeterFilter接口。默认情况下，所有MeterFilter组件都会自动应用于MicroMeter的MeterRegistry.Config。 &emsp;&emsp;例如，如果要将所有仪表ID中以com.example开头的mytag.region标签重命名为mytag.area，则可以执行以下操作： @Bean public MeterFilter renameRegionTagMeterFilter() &#123; return MeterFilter.renameTag(&quot;com.example&quot;, &quot;mytag.region&quot;, &quot;mytag.area&quot;); &#125;通用标签&emsp;&emsp;通用标签通常用于在操作环境，如主机，实例，区域，堆栈等，进行维度深入分析。通用标签适用于所有仪表，并可以按以下示例所示进行配置： management.metrics.tags.region=us-east-1 management.metrics.tags.stack=prod&emsp;&emsp;上面的示例将us-east-1和prod分别添加到region和stack到所有仪表。 如果使用Graphite，则常用标签的顺序很重要。由于使用这种方法不能保证通用标签的顺序，因此建议Graphite用户定义一个自定义MeterFilter。 Per-meter属性Per-meter适用于以给定名称开头的所有meter ID。例如，以下将禁用所有ID以example.remote开头的meter。 management.metrics.enable.example.remote=false&emsp;&emsp;以下属性允许per-meter自定义： 表8.per-meter自定义 属性 描述 management.metrics.enable 是否拒绝仪表发出任何指标 management.metrics.distribution.percentiles-histogram 是否发布适合于计算可凝集（跨维度）百分位数逼近的直方图 management.metrics.distribution.minimum-expected-value，management.metrics.distribution.maximum-expected-value 通过限制期望值的范围来发布较少的直方图bucket management.metrics.distribution.percentiles 发布在应用程序中计算的百分位值 management.metrics.distribution.sla 发布包含您的SLA定义的存储桶的累积直方图 &emsp;&emsp;有关percentiles-histogram，percentiles并sla概念更多的细节，请参阅“Histogram and percentiles”部分文档。 6 指标端点&emsp;&emsp;Spring Boot提供了一个metrics端点，可用于诊断检查应用程序收集的指标。端点默认情况下不可用，必须公开，有关更多详细信息，请参见暴露端点。 &emsp;&emsp;路径 /actuator/metrics 展示可用meter名称的列表。您可以通过提供特定的meter名称作为选择器来向下浏览以查看有关该仪表的信息,例如:/actuator/metrics/jvm.memory.max。 &emsp;&emsp;您在此处使用的名称应与代码中使用的名称相匹配，而不是已经针对监视系统进行了命名约定标准化后的名称。 &emsp;&emsp;您还可以tag=KEY:VALUE在URL的末尾添加任意数量的查询参数，以在维度上进一步细分meter，例如/actuator/metrics/jvm.memory.max?tag=area:nonheap。 &emsp;&emsp;报告的测量值是与仪表名称和已应用的任何标签相匹配的所有仪表的统计信息的总和。因此，在上面的示例中，返回的“值”统计量是堆的“代码缓存”，“压缩类空间”和“元空间”区域的最大内存占用量的总和。如果您只想查看“ Metaspace”的最大大小，则可以添加一个额外的tag=id:Metaspace，即/actuator/metrics/jvm.memory.max?tag=area:nonheap&amp;tag=id:Metaspace。","categories":[{"name":"Monitor System","slug":"Monitor-System","permalink":"http://yoursite.com/categories/Monitor-System/"}],"tags":[]},{"title":"java基础--基本数据类型","slug":"java基础-基本数据类型","date":"2019-11-12T14:54:49.000Z","updated":"2019-11-12T16:13:47.193Z","comments":true,"path":"2019/11/12/java基础-基本数据类型/","link":"","permalink":"http://yoursite.com/2019/11/12/java%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"一、注释的写法1.1 单行注释 //这是单行注释 1.2 多行注释 /*这是 多行注释*/1.3 文档注释 /** * * */","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[]},{"title":"MicroMeter基础概念","slug":"MicroMeter基础概念","date":"2019-11-12T14:41:32.000Z","updated":"2019-11-12T14:47:46.300Z","comments":true,"path":"2019/11/12/MicroMeter基础概念/","link":"","permalink":"http://yoursite.com/2019/11/12/MicroMeter%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/","excerpt":"","text":"一、目的&emsp;&emsp;MicroMeter是针对基于JVM的应用程序的Metrics标准检测库。它为最流行的监视系统提供了一个基于可视化客户端的简单外观，使我们无需供应商锁定即可对基于JVM的应用程序代码进行可视化。它旨在在最大限度地提高指标工作可移植性的同时，几乎不增加指标收集活动的开销。 二、支持的监控系统&emsp;&emsp;MicroMeter不是分布式跟踪系统或事件日志记录器。阿德里安·科尔（Adrian Cole）关于“ 可观测性3种方式”的演讲在强调这些不同类型的系统之间的差异方面做得很好。 &emsp;&emsp;MicroMeter包含一个带有可视化一起SPI的核心模块，一组包含各种监视系统的实现（每个系统称为注册表）的模块，以及一个测试套件。学习监视系统理解下面三个重要特征： 2.1 维度&emsp;&emsp;系统是否支持通过标记键/值对丰富metrics名称（tags）。如果系统不是为维度性的，则它是分层的，这意味着它仅支持平面度量标准名称。将metrics指标发布到分层系统时，Micrometer会展平标签键/值对的集合并将其添加到名称中。 2.2 速率聚合（Rate aggregation）&emsp;&emsp;在本文中，我们指的是在规定的时间间隔内集合一组样本。一些监视系统希望某些类型的离散样本（例如计数）在发布之前由应用程序转换为比率。有些人希望总是发送累积值。还有其他人对此没有意见。 2.3 发布&emsp;&emsp;一些系统希望在闲暇时轮询应用程序以获取指标，而另一些系统则希望按固定间隔将指标推送给他们。 三、注册表（Registry）&emsp;&emsp;Meter是用于收集有关应用程序的一组度量（我们分别称为metrics指标）的接口。MicroMeter里面的Meters是从MeterRegistry中创建并保存在其中的。每个支持的监视系统都有一个的实现的MeterRegistry。注册表的创建方式因每个监控系统的实现方式而不同。 &emsp;&emsp;MicroMeter包装带有SimpleMeterRegistry，可在内存中保存每个meter的最新值，并且不会将数据导出到任何地方。如果您还没有首选的监视系统，则可以使用简单的注册表开始使用指标： MeterRegistry registry = new SimpleMeterRegistry();注：一个SimpleMeterRegistry是基于Spring的应用程序自动注入的。 3.1 复合注册表&emsp;&emsp;MicroMeter提供了一个CompositeMeterRegistry可以添加多个注册表的功能，使我们可以同时将Metrics指标发布到多个监视系统。 CompositeMeterRegistry composite = new CompositeMeterRegistry(); Counter compositeCounter = composite.counter(&quot;counter&quot;); compositeCounter.increment(); (1) SimpleMeterRegistry simple = new SimpleMeterRegistry(); composite.add(simple); (2) compositeCounter.increment(); (3)1.组合中没有注册表之前，增量为NOOPd。此时计数器的计数仍将为0。 2.一个名为“ counter”的计数器被注册到简单注册表中。 3.简单注册表计数器以及组合中任何其他注册表的计数器都会增加。 3.2 全局注册表&emsp;&emsp;MicroMeter提供了一个静态全局注册表Metrics.globalRegistry和一组静态生成器，用于基于此注册表生成meters。globalRegistry是一个复合注册表。(我是不是可以理解成Metrics就是默认完成了那个Metrics.globalRegistry，然后我们就可以肆无忌惮的使用Mtrics.xxx了) class MyComponent &#123; Counter featureCounter = Metrics.counter(&quot;feature&quot;, &quot;region&quot;, &quot;test&quot;); (1) void feature() &#123; featureCounter.increment(); &#125; void feature2(String type) &#123; Metrics.counter(&quot;feature.2&quot;, &quot;type&quot;, type).increment(); (2) &#125; &#125; class MyApplication &#123; void start() &#123; // wire your monitoring system to global static state Metrics.addRegistry(new SimpleMeterRegistry()); (3) &#125; &#125;&emsp;&emsp;1.只要能够实现（尤其是在可视化性能至关重要的地方），请将Meter实例存储在字段中，以避免在每次使用时查找其名称/标签。 &emsp;&emsp;2.当需要根据本地上下文确定标记时，您别无选择，只能在方法体内构造/查找Meter。查找成本只是单个哈希查找，因此对于大多数用途而言，这是可以接受的。 &emsp;&emsp;3.创建meters后添加注册表也是可以的，例如Metrics.counter(…​)。这些meters将被添加到每个注册表，因为它已绑定到全局组合。 3.4 Meters&emsp;&emsp;MicroMeter包含的它支持Meter原语集包括：Timer，Counter，Gauge，DistributionSummary，LongTaskTimer，FunctionCounter，FunctionTimer，和TimeGauge。不同的meter类型得出不同数量的时间序列指标metrics。例如，虽然有一个单独的表示Gauge类型的指标，但是Timer类型的指标既得出时间事件的计数，也含有时间事件总的计数。 &emsp;&emsp;meter是通过其名称和维度进行唯一标识的。我们可以“维度”和“标签”是一个意思，而“MicroMeter”层面Tag仅仅是因为它更短。作为一般规则，应该可以使用该名称作为枢轴。维度允许时间切面以特定的命名指标进行深入分析并推断数据。这意味着，如果仅选择名称，则用户可以使用其他维度和显示值的原因进行追溯。 五 命名meters&emsp;&emsp;MicroMeter采用命名约定，用“.”（点）字符分隔小写单词。不同的监视系统对命名约定有不同的建议，并且某些命名约定可能与一个系统兼容，而与另一个系统不兼容。监视系统的每个Micrometer实施都附带一个命名约定，该约定将小写点标记法名称转换为监视系统推荐的命名约定。此外，此命名约定实现还清除了监视系统不允许的Metrics标准名称和特殊字符标签。您可以使用以下方法在注册表中实现NamingConvention并设置注册表，从而覆盖注册表的默认命名约定： registry.config().namingConvention(myCustomNamingConvention);&emsp;&emsp;有了适当的命名约定，在Micrometer中注册的以下timer计时器在各种监视系统中就可以很好的使用了： registry.timer(&quot;http.server.requests&quot;);&emsp;&emsp;Prometheus- http_server_requests_duration_seconds &emsp;&emsp;Atlas- httpServerRequests &emsp;&emsp;Graphite- http.server.requests &emsp;&emsp;InfluxDB- http_server_requests &emsp;&emsp;通过遵守Micrometer的小写点标记约定，我们就可以确保跨监视系统的metrics名称具有最大的可移植性。 5.1 标签命名 tip 命名标签时，建议使用与metrics名称相同的小写点标记。利用标签的这种一致的命名约定，可以更好地转换为相应监视系统的惯用命名方案。 假设我们正在尝试测量http请求的数量和数据库调用的数量。 推荐方法： registry.counter(&quot;database.calls&quot;, &quot;db&quot;, &quot;users&quot;) registry.counter(&quot;http.requests&quot;, &quot;uri&quot;, &quot;/api/users&quot;)&emsp;&emsp;这个变量提供了足够的文本信息，因此，如果仅选择名称，则可以推断出该值，并且至少具有潜在的意义。例如，如果我们选择“database.calls”则可以看到所有数据库的调用总数。然后，我们可以分组或选择“db”以进一步细分或对呼叫对每个数据库的贡献进行比较分析。 不合适的方法 registry.counter(&quot;calls&quot;, &quot;class&quot;, &quot;database&quot;, &quot;db&quot;, &quot;users&quot;); registry.counter(&quot;calls&quot;, &quot;class&quot;, &quot;http&quot;, &quot;uri&quot;, &quot;/api/users&quot;);&emsp;&emsp;在这种方法中，如果选择，calls我们将获得一个值，该值是对数据库和API端点的调用次数的总和。如果没有进一步的维度向下钻取，该时间序列将无用。 5.2 通用标签&emsp;&emsp;可以在注册表级别定义公用标签，并将其添加到报告给监视系统的每个度量标准中。通常用于在操作环境（例如主机，实例，区域，堆栈等）上进行维度深入分析。 registry.config().commonTags(&quot;stack&quot;, &quot;prod&quot;, &quot;region&quot;, &quot;us-east-1&quot;); registry.config().commonTags(Arrays.asList(Tag.of(&quot;stack&quot;, &quot;prod&quot;), Tag.of(&quot;region&quot;, &quot;us-east-1&quot;))); // equivalently&emsp;&emsp;调用commonTags追加其他通用标签。 重要 如果我们在Spring环境中，需要通过添加MeterRegistryCustomizerBean来添加通用标签，以确保在自动配置meter绑定程序之前应用了通用标签。 5.3 标签值&emsp;&emsp;标签值必须非空 警告 注意来自用户提供的来源的标记值可能会破坏指标的基数。我们应该始终保持规范并绑定用户提供的输入。有时原因是非常细微的。考虑用于记录服务端点上的HTTP请求的URI标记。如果我们不将404约束为NOT_FOUND之类的值，则metrics的维度将随着找不到的每个资源而增长。 6.Meter过滤器&emsp;&emsp;每个注册表都可以配置meter过滤器，使我们可以更好地控制如何注册仪表，何时注册仪表以及发出何种统计信息。Meter过滤器具有三个基本功能： &emsp;&emsp;1.拒绝（或接受）meter被注册。 &emsp;&emsp;2.转换Meter的ID（例如，更改名称，添加或删除标签，更改描述或基本单位）。 &emsp;&emsp;3.配置某些meter类型的分布统计信息。 &emsp;&emsp;MeterFilter的实现以编程方式添加到注册表中： registry.config() .meterFilter(MeterFilter.ignoreTags(&quot;too.much.information&quot;)) .meterFilter(MeterFilter.denyNameStartsWith(&quot;jvm&quot;));&emsp;&emsp;按顺序应用Meter过滤器，并将变换或配置meter的结果链接在一起。 6.1 拒绝/接受meters&emsp;&emsp;接受/拒绝过滤器的详细形式为： new MeterFilter() &#123; @Override public MeterFilterReply accept(Meter.Id id) &#123; if(id.getName().contains(&quot;test&quot;)) &#123; return MeterFilterReply.DENY; &#125; return MeterFilterReply.NEUTRAL; &#125; &#125;&emsp;&emsp;MeterFilterReply具有三种可能的状态： DENY-请勿注册该仪表。当我们尝试注册一个与另一个注册表冲突的meter,过滤器返回DENY注册表将返回meter的NOOP版本（例如NoopCounter，NoopTimer）。我们的代码可以继续与NOOP计量器进行交互，但是记录在其中的任何内容都将以最小的开销立即被丢弃。 NEUTRAL-如果没有其他meter过滤器返回DENY，则meter的注册将照常进行。 ACCEPT-如果过滤器返回ACCEPT，meter将立即注册，而不会询问任何其他过滤器的接受方法。 6.1.1 便利的方法6.1.2 链接 拒绝/接受meters6.2 转换metrics&emsp;&emsp;转换过滤器如下所示： new MeterFilter() &#123; @Override public Meter.Id map(Meter.Id id) &#123; if(id.getName().startsWith(&quot;test&quot;)) &#123; return id.withName(&quot;extra.&quot; + id.getName()).withTag(&quot;extra.tag&quot;, &quot;value&quot;); &#125; return id; &#125; &#125;&emsp;&emsp;该过滤器有条件地向meters添加以名称“ test”开头的名称前缀和附加标签。 &emsp;&emsp;MeterFilter 为许多常见的转换案例提供了便利构建器： &emsp;&emsp;commonTags(Iterable)-向所有指标添加一组标签。强烈建议为应用名称，主机，区域等添加通用标签。 &emsp;&emsp;ignoreTags(String…​)-从每个仪表上舍弃匹配的标签键。当标签可证明变得过高的基数并开始给监视系统施加压力或开销增大，使得我们不能快速更改所有检测点时，此功能特别有用。 &emsp;&emsp;replaceTagValues(String tagKey, Function&lt;String, String&gt; replacement, String…​ exceptions)-根据为所有匹配的标记键提供的映射替换标记值。通过将标签值的某些部分映射到其他内容，可以用来减少标签的总基数。 &emsp;&emsp;renameTag(String meterNamePrefix, String fromTagKey, String toTagKey) -重命名以给定前缀开头的每个指标的标签键。 6.3 配置分布统计&emsp;&emsp;Timer和DistributionSummary除了可以通过过滤器配置的计数、总数和最大值的基本信息外，还包含一组可选的分布统计信息。这些分布统计信息包括预先计算的百分位数，SLA和直方图。 new MeterFilter() &#123; @Override public DistributionStatisticConfig configure(Meter.Id id, DistributionStatisticConfig config) &#123; if (id.getName().startsWith(prefix)) &#123; return DistributionStatisticConfig.builder() .publishPercentiles(0.9, 0.95) .build() .merge(config); &#125; return config; &#125; &#125;;&emsp;&emsp;通常，我们应该仅对我们希望配置的切片创建一个新的DistributionStatisticConfig并且将它与输入的配置合并。这样，我们就可以下拉注册表提供的分发统计信息的默认值，并将多个过滤器链接在一起，每个过滤器都可以配置分发统计信息的一部分（例如，我们可能希望所有http请求都具有100ms的SLA，但在一些关键请求上只需要百分位端点）。 &emsp;&emsp;MeterFilter 为以下人员提供便利构建器： &emsp;&emsp;maxExpected(Duration/long) -控制从timer或summary中得到的百分比直方图桶的上限。 &emsp;&emsp;minExpected(Duration/long) -控制从timer或summary中得到的百分比直方图桶的下限。 &emsp;&emsp;Spring Boot提供了基于属性的过滤器，用于通过名称前缀配置SLA，百分比和百分比直方图。 7.速率聚合&emsp;&emsp;Micrometer知道特定的监视系统希望在metrics发布之前还是在服务器端作为查询的一部分临时在客户端进行速率聚合。它根据监视系统期望的样式累积metrics。 &emsp;&emsp;并非所有测量指标都进行速率聚合进行报告或展示。例如，gauge和long task timer的任务就不是速率聚合。 &emsp;&emsp;执行服务器端速率聚合的监视系统希望在每个发布间隔报告绝对值。例如，自从应用程序的开始运行，在每个发布间隔所有counter增量的绝对值都会发布。 &emsp;&emsp;假设我们有一个略微偏向的随机游走，它选择每10ms增加一次counter计数器。如果我们在监控系统，比如Prometheus这样的系统中查看原始计数器值，则会看到逐步单调递增的函数（步长是Prometheus轮询或抓取数据的间隔）。 &emsp;&emsp;在某个时间窗口内没有速率聚合的counter很少是有用的，因为表示的是计数器递增的速度和服务寿命的函数。在上面的示例中，服务重新启动时，counter降回零。新实例（例如在生产部署中）投入使用后，速率聚合图像将返回到约55的值。 &emsp;&emsp;如果我们已实现零停机时间部署（例如通过红黑部署），则应该能够在速率汇总图上轻松设置最低警报阈值，而无需重新启动服务导致计数器值下降。 重要 对于大多数生产目的，无论是警报，自动数据分析等，都是基于速率汇总数据进行自动化的。 7.2 客户端另一类监视系统： &emsp;&emsp;1.期望速率汇总数据。考虑到对于大多数生产目的的关键需求指标，我们应该基于速率而不是绝对值来做出决策，这样的系统将得益于无需进行太多数学运算即可满足查询的需求。 &emsp;&emsp;2.几乎没有数学运算或没有数学运算，即可使我们可以通过查询对数据进行速率聚合。对于这些系统，发布预先聚合的数据是构建有意义的表示的唯一方法。 &emsp;&emsp;MicroMeter通过累积当前发布间隔数据的步长值来有效维护速率数据。当对步长值进行轮询时（例如，在发布时），如果步长值检测到当前间隔已过去，则它将当前数据移至“先前”状态。该先前状态是报告的，直到下次当前数据覆盖它为止。以下是当前和先前状态以及轮询之间相互作用的说明： &emsp;&emsp;poll函数返回的值始终是每秒的速率*间隔。如果上面说明的步长值表示counter的值，则可以说计数器在第一个间隔中看到了“每秒0.3增量”，这可以在第二个间隔中的任何时间报告给后端。 &emsp;&emsp;MicroMeterde的timer至少跟踪一个计数和总时间，作为单独的测量。假设我们以10秒的间隔配置发布，并且看到20个请求，每个请求花费100毫秒。然后在第一个间隔中： 1.count = 10秒*（20个请求/ 10秒）= 20个请求 2.totalTime = 10秒*（20 * 100毫秒/ 10秒）= 2秒&emsp;&emsp;该count统计信息很有意义，可以单独使用–它是吞吐量的度量。totalTime表示间隔中所有请求的总延迟。另外： totalTime / count = 2秒/ 20个请求= 0.1秒/请求= 100 ms /请求&emsp;&emsp;这是平均延迟的有用度量。当将相同的思想应用于分布汇总totalAmount并count从中得出时，该度量称为分布平均值。平均延迟只是按时间（timer）度量的分发summary的分发平均值。犹如Atlas一些监测系统计算从这些统计分布平均提供设施和MicroMeter将发布totalTime和count作为单独统计。其他如Datadog则没有内置此类操作，Micrometer将计算客户端的平均分配并将其发送出去。&emsp;&emsp;发布时间间隔的速率足以推断出在任何时间窗口内大于或等于发布时间间隔的速率。在我们的示例中，如果服务在给定的分钟内继续接收20个请求，在每10秒间每个请花费100ms，那么我们可以说： &emsp;&emsp;1.MicroMeter每10秒报告一次total–“ 20个请求” 。监视系统简单地将这六个10秒的间隔相加即可得出每分钟120个请求的结论。请注意，是进行进行求和操作的是监视系统，而不是MicroMeter。 &emsp;&emsp;2.MicroMeter每隔10 秒报告一次totalTime–“ 2秒” 。监视系统可以对一分钟内的所有总时间统计信息求和，以在分钟间隔内产生总时间的“ 12秒”。然后，平均延迟就如我们期望的那样：12秒/ 120个请求= 100 ms /请求。 8.CountersCouners报告一个指标，计数。该Counter接口允许我们以固定数量递增，该数量必须为正。 tip 永远不要记数一些我们可以使用Timer或用DistributionSummary记录的东西！Timer和DistributionSummary会发布除了其他的测量事件之外，还有事件的计数。 &emsp;&emsp;建立图表并根据Counter发出警报时，通常我们应该最感兴趣的是测量在给定时间间隔内某些事件的速率。考虑一个简单的队列，Counter可用于衡量事物的插入和移除速度。 &emsp;&emsp;人们首先想到的是可视化绝对数值，而不是速率，但绝对数量通常是既是一些事务的使用速率的函数也是可视化条件下应用程序实例的使用寿命。在某些时间间隔内构建仪表板和Counter速率警报会忽略应用程序的寿命，让我们在应用程序启动后很长时间才看到异常行为。 注意 在进入使用计数器之前，请务必通读Timer部分，因为Timer会记录计时事件的计数，因为Counter记录了时间事件的计数作为度量的一部分。对于我们打算计时的那些代码，我们无需单独添加计数器。 &emsp;&emsp;以下代码模拟了一个真实的Counter，该Counter的rate在较短的时间范围内显示出一些扰动。 Normal rand = ...; // a random generator MeterRegistry registry = ... Counter counter = registry.counter(&quot;counter&quot;); (1) Flux.interval(Duration.ofMillis(10)) .doOnEach(d -&gt; &#123; if (rand.nextDouble() + 0.1 &gt; 0) &#123; (2) counter.increment(); (3) &#125; &#125;) .blockLast();&emsp;&emsp;1.可以使用名称和（可选）一组标签从注册表本身创建大多数Counter。 &emsp;&emsp;2.略微偏向的随机游走。 &emsp;&emsp;3.这就是我们与Conuter交互的方式。我们也可以用counter.increment(n)在单个操作中调用增加1以上的值。 &emsp;&emsp;Counter接口本身还有一个流利的计数器构建器，可以访问不太常用的选项，例如基本单位和说明。我们可以通过调用将计数器注册为构造计数器的最后一步register。 Counter counter = Counter .builder(&quot;counter&quot;) .baseUnit(&quot;beans&quot;) // optional .description(&quot;a description of what this counter does&quot;) // optional .tags(&quot;region&quot;, &quot;test&quot;) // optional .register(registry);8.1 功能–追踪Counter&emsp;&emsp;MicroMeter还提供了一种更不常用的计数器模式，该模式跟踪单调递增的函数（函数保持不变或随时间增加，但从不减少）。一些监视系统（例如Prometheus）将Counter的累积值推送到后端，但是其他系统则发布Counter在推送间隔内递增的速率。通过采用这种模式，我们可以让监控系统的Micrometer实施选择是否对Counter进行归一化评估，并且计数器可以在不同类型的监控系统之间保持可移植性。 Cache cache = ...; // suppose we have a Guava cache with stats recording on registry.more().counter(&quot;evictions&quot;, tags, cache, c -&gt; c.stats().evictionCount()); (1)&emsp;&emsp;1.evictionCount() 是一个单调递增的函数，从生命周期的开始就随着每次缓存逐出而递增。 &emsp;&emsp;功能–跟踪Counter,与监视系统的速率归一化功能（无论是查询语言的人工产物还是数据被推送到系统的方式）配合使用，在功能的累积值之上增加了一层丰富性。可以推断值增加的速率，这样的速率是否在一个可接受的范围，随着时间的推移是在增加或降低。 警告 MicroMeter不能为您保证函数的单调性。通过使用此签名，我们可以根据对定义的了解来断言其单调性。 &emsp;&emsp;FunctionCounter接口本身也具有用于功能计数器的流利的构建器，可以访问不太常用的选项，例如基本单元和描述。我们可以通过调用将计数器注册为构造计数器的最后一步register(MeterRegistry)。 MyCounterState state = ...; FunctionCounter counter = FunctionCounter .builder(&quot;counter&quot;, state, state -&gt; state.count()) .baseUnit(&quot;beans&quot;) // optional .description(&quot;a description of what this counter does&quot;) // optional .tags(&quot;region&quot;, &quot;test&quot;) // optional .register(registry);9.Gauge&emsp;&emsp;Gauge是获取当前值的处理器。Gauge的典型示例是运行状态下的集合或映射的大小或线程数。 tip Gauge对于监视具有自然上限的事物很有用。不建议使用Gauge来监视诸如请求计数之类的事情，因为它们会在应用程序实例生命周期内不受限制地增长。 tip 能用Counter计量的东西千万不要用Gauge！ &emsp;&emsp;MicroMeter的立场是应该对Gauge进行采样而不进行设置，因此没有关于样品之间可能发生的情况的信息。毕竟，在将Gauge值报告给Metrics后端后，Gauge上设置的任何中间值都会丢失，因此首先设置这些中间值似乎没有什么价值。 &emsp;&emsp;如果有帮助，可以将其Gauge视为“heisen-gauge”-仅在观察到时才会改变的仪表。开箱即用提供的所有其他Meter类型都会在向数据后端发送数据时累积中间计数。 &emsp;&emsp;该MeterRegistry接口包含用于构建Gauge以观察数值、方法、、集合和映射的方法。 List&lt;String&gt; list = registry.gauge(&quot;listGauge&quot;, Collections.emptyList(), new ArrayList&lt;&gt;(), List::size); (1) List&lt;String&gt; list2 = registry.gaugeCollectionSize(&quot;listSize2&quot;, Tags.empty(), new ArrayList&lt;&gt;()); (2) Map&lt;String, Integer&gt; map = registry.gaugeMapSize(&quot;mapGauge&quot;, Tags.empty(), new HashMap&lt;&gt;());&emsp;&emsp;1.gauge的一种较常见的形式是监视某些非数字对象。最后一个参数建立了一个函数，该函数用于在观察gauge时确定gauge的值。 &emsp;&emsp;2.对于(1)的一种更方便的形式，用于您只想监视集合大小的情况。 &emsp;&emsp;创建gauge的所有不同形式都仅保持对要观察的对象的弱引用，以免阻止对象的垃圾收集。 9.1 手动增减仪表&emsp;&emsp;gauge可制成可以跟踪任何java.lang.Number亚型，如java.util.concurrent.atomic中发现的AtomicInteger和AtomicLong，和Guava的AtomicDouble类似的类型。 AtomicInteger n = registry.gauge(&quot;numberGauge&quot;, new AtomicInteger(0)); n.set(1); n.set(2);&emsp;&emsp;请注意，这种形式与其他meter类型不同，Gauge在创建一个meter时，我们不会得到引用，而是要观察到的东西。这是因为存在”heisen-gauge”原理，gauge一经创建便是自给自足的，因此我们无需与之交互。这使MicroMeter可以只向我们退还已检测的对象，从而可以快速创建一个可观察对象并围绕该对象设置metrics指标。 &emsp;&emsp;此模式应比DoubleFunction表格少见。请记住，频繁设置观察值会Number导致许多中间值无法发布。仅在发布时将gauge的瞬时值发送到监视系统。 警告 尝试使用原始数字或其java.lang对象形式之一构造gauge总是不正确的。这些数字是不可变的，因此gauge无法更改。尝试用不同的编号“重新注册”量规是行不通的，因为注册表仅对名称和标签组成的唯一组合维护一个仪表。 9.2 Gauge的构建器&emsp;&emsp;该接口包含一个流利的gauge构建器： Gauge gauge = Gauge .builder(&quot;gauge&quot;, myObj, myObj::gaugeValue) .description(&quot;a description of what this gauge does&quot;) // optional .tags(&quot;region&quot;, &quot;test&quot;) // optional .register(registry);&emsp;&emsp;通常，返回的Gauge实例仅在测试中有用，因为gauge已设置为在注册后自动跟踪数值。 9.3 我的Gauge为什么报告NaN或消失？&emsp;&emsp;MicroMeter对于创建强引用对象非常谨慎，避免那些对象无法进行垃圾收集，一旦被测量的对象被取消引用并被垃圾回收，Micrometer将开始报告测量值的NaN或不报告，具体取决于注册表的实现方式。 &emsp;&emsp;如果看到gauge报告了几分钟，然后消失或报告了NaN，则几乎可以肯定地表明被测量的基础对象已被垃圾回收。 10 Timer&emsp;&emsp;计时器用于测量短时延以及此类事件的频率。所有实现的Timer将按照时间序列报告至少总时间和事件计数。尽管可以将Timers用于其他用例，但请注意不支持负值，并且记录更长的持续时间可能会导致总时间溢出（以Long.MAX_VALUE纳秒计）（292.3年）。 &emsp;&emsp;例如，考虑一个图表，它显示了对典型Web服务器的请求延迟。可以期望服务器快速响应许多请求，因此计时器将每秒更新多次。 &emsp;&emsp;Counter的适当基本单位因指标后端的不同而有所不同。MicroMeter对此毫无疑问，但是由于存在混淆的可能性，与Timers 相互作用时需要TimeUnit。Micrometer知道每种实现的首选项，并根据实现在适当的基本单元中发布我们的时间安排。 public interface Timer extends Meter &#123; ... void record(long amount, TimeUnit unit); void record(Duration duration); double totalTime(TimeUnit unit); &#125;&emsp;&emsp;该接口包含一个流畅的Timer构建器： Timer timer = Timer .builder(&quot;my.timer&quot;) .description(&quot;a description of what this timer does&quot;) // optional .tags(&quot;region&quot;, &quot;test&quot;) // optional .register(registry);10.1 记录代码块&emsp;&emsp;该Timer接口公开了一些方便的重载，用于内联时间记录，例如： timer.record(() -&gt; dontCareAboutReturnValue()); timer.recordCallable(() -&gt; returnValue()); Runnable r = timer.wrap(() -&gt; dontCareAboutReturnValue()); (1) Callable c = timer.wrap(() -&gt; returnValue());1.包装Runnable或Callable返回其可视化版本以供以后使用。 注意 Timer实际上只是一个专门的分布式summary，它知道如何将持续时间缩放到每个监视系统的基本时间单位，并且具有自动确定的基本单位。在每种情况下，如果要测量时间，都应使用Timer而不是DistributionSummary。 10.2 将开始状态存储在Timer.Sample&emsp;&emsp;您也可以将启动状态存储在示例实例中，以后可以将其停止。该示例记录基于注册表时钟的开始时间。开始采样后，执行要计时的代码，并通过调用stop(Timer)采样完成操作。 Timer.Sample sample = Timer.start(registry); // do stuff Response response = ... sample.stop(registry.timer(&quot;my.timer&quot;, &quot;response&quot;, response.status()));&emsp;&emsp;请注意，在停止采样之前，如何确定采样所用的计时器。这使我们能够根据我们正在计时的操作的结束状态动态地确定某些标签。 10.3 @Timed注解&emsp;&emsp;micrometer-core模块包含一个@Timed注释，框架可以使用该注释向特定类型的方法（例如为Web请求端点提供服务的方法）或通常为所有方法添加计时支持。 警告 Micrometer的Spring Boot配置无法@Timed在任意方法上识别。 &emsp;&emsp;还包含一个可孵化的AspectJ方面micrometer-core，在应用程序中，我们可以通过编译/加载AspectJ编织，或通过框架工具比如Spring Aop等其他方式解释AspectJ切面和代理目标方法。如下是一个示例Spring AOP配置： @Configuration public class TimedConfiguration &#123; @Bean public TimedAspect timedAspect(MeterRegistry registry) &#123; return new TimedAspect(registry); &#125; &#125;&emsp;&emsp;在AspectJ代理实例中，应用程序TimedAspect的@Timed用于任何任意方法。 10.4 功能–跟踪timers&emsp;&emsp;MicroMeter还提供了一种不常用的计时器模式，该模式可跟踪两个单调递增的函数（一个函数随时间保持不变或增加，但从不减小）：计数函数和总时间函数。某些监视系统（例如Prometheus）将计数器的累积值（在这种情况下适用于计数和总时间函数）推送到后端，但其他系统则发布计数器在推送间隔内递增的速率。通过采用这种模式，我们可以让监控系统的Micrometer实现选择是否对timer进行速率聚合，并且计时器可以在不同类型的监控系统之间保持可移植性。 IMap&lt;?, ?&gt; cache = ...; // suppose we have a Hazelcast cache registry.more().timer(&quot;cache.gets.latency&quot;, Tags.of(&quot;name&quot;, cache.getName()), cache, c -&gt; c.getLocalMapStats().getGetOperationCount(), (1) c -&gt; c.getLocalMapStats().getTotalGetLatency(), TimeUnit.NANOSECONDS (2) );&emsp;&emsp;1.getGetOperationCount() 是一个单调递增的函数，它从生命周期的开始就随着每个缓存的获取而递增。 &emsp;&emsp;2.这表示由getTotalGetLatency()表示的时间单位。每个注册表实现均指定其预期的基本时间单位是什么，并且报告的总时间将缩放为该值。 &emsp;&emsp;功能–跟踪timer与监视系统的速率归一功能（无论是查询语言的人工产物还是数据被推送到系统的方式）配合使用，在功能的累积值之上增加了一层丰富性，我们可以推断吞吐量和延迟的速率，该速率是否在可接受的范围内，随时间增加还是减少等。 警告 MicroMeter不能为我们保证count和total time功能的单调性。通过使用此签名，您可以根据对定义的了解来断言它们的单调性。 &emsp;&emsp;FunctionTimer接口本身还有一个流利的FunctionTimer构建器，可用于访问不常用的选项，例如基本单元和描述。您可以通过调用register(MeterRegistry)为构造计时器的最后一步)。 IMap&lt;?, ?&gt; cache = ... FunctionTimer.builder(&quot;cache.gets.latency&quot;, cache, c -&gt; c.getLocalMapStats().getGetOperationCount(), c -&gt; c.getLocalMapStats().getTotalGetLatency(), TimeUnit.NANOSECONDS) .tags(&quot;name&quot;, cache.getName()) .description(&quot;Cache gets&quot;) .register(registry);10.5 暂停检测&emsp;&emsp;MicroMeter使用LatencyUtils包来补偿协同遗漏—系统和VM暂停导致的额外延迟会延迟您的延迟统计信息。百分位数和SLA计数之类的分布统计信息受暂停检测器实现的影响，该实现会在此处和此处添加额外的延迟以补偿暂停。 &emsp;&emsp;MicroMeter支持两种暂停检测器实施方式：基于时钟漂移的检测器和无操作检测器。在MicroMeter的1.0.10/1.1.4/1.2.0版本之前，默认情况下配置了时钟漂移检测器以报告尽可能准确的度量标准，而无需进行进一步配置。从1.0.10/1.1.4/1.2.0版本开始，默认情况下配置无操作检测器，但可以如下配置时钟漂移检测器。 &emsp;&emsp;基于时钟漂移的检测器具有可配置的睡眠间隔和暂停阈值。CPU消耗与sleepInterval、暂停检测精度成反比。这两个值的100ms是合理的默认值，以提供对长时间停顿事件的适当检测，同时消耗可忽略的CPU时间。 &emsp;&emsp;我们可以使用以下方法自定义暂停检测器： registry.config().pauseDetector(new ClockDriftPauseDetector(sleepInterval, pauseThreshold)); registry.config().pauseDetector(new NoPauseDetector());&emsp;&emsp;将来，我们可能会提供进一步的检测器实现。例如，在某些情况下，可以从GC日志中推断出一些暂停，而不需要恒定的CPU负载，尽管负载很小。将来的JDK也可能会提供对暂停事件的直接访问。 10.6 内存占用估算&emsp;&emsp;Timer是最消耗内存的meter，其总占用空间可能会因我们选择的选项而有很大差异。下表是基于各种功能使用情况的内存消耗表。这些数字假定没有标签，并且环形缓冲区的长度为3。添加标签当然会增加总数，增加缓冲区的长度也会有所增加。总存储量也可能会有所不同，具体取决于注册表的实现。 R =环形缓冲区的长度。在所有示例中，我们假定默认值为3。R用设置Timer.Builder#distributionStatisticBufferLength。 B =总直方图桶。可以是SLA边界或百分比直方图桶。默认情况下，计时器被限制为最小期望值1ms和最大期望值30秒，如果适用，则为百分比直方图产生66个桶。 I =暂停补偿的间隔估算器。1.7 kb M =最大衰减时间。104字节 Fb =固定边界直方图。30b * B * R Pp =百分位数精度。默认情况下为1。通常在[0，3]范围内。Pp用设置Timer.Builder#percentilePrecision。 Hdr（Pp）=高动态范围直方图。 若 Pp = 0：1.9kb * R + 0.8kb 若 Pp = 1：3.8kb * R + 1.1kb 若 Pp = 2：18.2kb * R + 4.7kb 若 Pp = 3：66kb * R + 33kb 暂停检测 客户端百分位数 Cool 直方图和/或SLA 示例 YES NO NO I+M ~1.8kb YES NO YES I+M+Fb 对于默认的百分比直方图，〜7.7kb YES YES YES I+M+Hdr(Pp) 要添加默认值的0.95％，否则为〜14.3kb NO NO NO M 〜0.1kb NO NO YES M+Fb 对于默认的百分比直方图，〜6kb NO YES YES M+Hdr(Pp) 要添加默认值的0.95％，否则为〜12.6kb 注意 这些估计是基于Micrometer 1.0.3中所做的改进，并且假定至少使用该版本。 注意 特别是对于Prometheus ，无论您如何尝试通过进行配置Timer.Builder，R 始终等于1 。这对于 &emsp;&emsp;Prometheus来说是特殊情况，因为它期望永不翻转的累积直方图数据。 11 分布式 summaries&emsp;&emsp;分布式summaries用于跟踪事件的分布。它在结构上类似于计时器，但记录的值不代表时间单位。例如，分布式summary可用于衡量命中服务器的请求的有效负载大小。 &emsp;&emsp;要创建一个分布式summary： DistributionSummary summary = registry.summary(&quot;response.size&quot;);&emsp;&emsp;该接口包含一个流利的分布式summary构建器： DistributionSummary summary = DistributionSummary .builder(&quot;response.size&quot;) .description(&quot;a description of what this summary does&quot;) // optional .baseUnit(&quot;bytes&quot;) // optional (1) .tags(&quot;region&quot;, &quot;test&quot;) // optional .scale(100) // optional (2) .register(registry);&emsp;&emsp;1.添加基本​​单元以获得最大的可移植性-基本单元是某些监视系统的命名约定的一部分。如果忘记的话，将其保留下来并违反命名约定不会有任何不利影响。 &emsp;&emsp;2.可选的，我们可以提供一个比例因子，每个记录的样本在记录时将乘以该比例。 11.1 标度和直方图&emsp;&emsp;MicroMeter的预选百分比直方图桶都是从1到最大long的整数。目前minimumExpectedValue和maximumExpectedValue用来控制桶的基数。如果我们尝试检测到您的最小/最大值产生较小的范围并将预选的存储桶域缩放到summary的范围，则我们没有其他方法可以控制桶的基数。 &emsp;&emsp;相反，如果summary的域受到更多限制，则按固定因子缩放摘要的范围。到目前为止，我们所听到的用例是域为[0,1]的比率的汇总。然后： DistributionSummary.builder(&quot;my.ratio&quot;).scale(100).register(registry)&emsp;&emsp;这样，比率最终会在[0,100]的范围内，我们可以将其设置maximumExpectedValue为100。如果您关心特定的比率，则将其与自定义SLA边界配对： DistributionSummary.builder(&quot;my.ratio&quot;) .scale(100) .sla(70, 80, 90) .register(registry)11.2 内存占用估算&emsp;&emsp;分布式summary的总内存占用量可能会变化很大，具体取决于我们选择的选项。下表是基于各种功能使用情况的内存消耗表。这些数字假定没有标签，并且环形缓冲区的长度为3。添加标签当然会增加总数，增加缓冲区的长度也会有所增加。总存储量也可能会有所不同，具体取决于注册表的实现。 R =环形缓冲区的长度。在所有示例中，我们假定默认值为3。R用设置DistributionSummary.Builder#distributionStatisticBufferLength。 B =总直方图桶。可以是SLA边界或百分比直方图桶。默认情况下，摘要没有最小和最大期望值，因此请装运所有276个预定的直方图桶。当您打算运送百分位直方图时，应始终使用minimumExpectedValue和来固定分布摘要maximumExpectedValue。 M =最大衰减时间。104字节 Fb =固定边界直方图。30b * B * R Pp =百分位数精度。默认情况下为1。通常在[0，3]范围内。Pp用设置DistributionSummary.Builder#percentilePrecision。 Hdr（Pp）=高动态范围直方图。 当Pp = 0时：1.9kb * R + 0.8kb 当Pp = 1时：3.8kb * R + 1.1kb 当Pp = 2时：18.2kb * R + 4.7kb 当Pp = 3时：66kb * R + 33kb 客户端 百分位数直方图和/或SLA 公式 示例 NO NO M 〜0.1kb NO YES M+Fb 对于固定在66个桶中的百分位直方图，〜6kb YES YES M+Hdr(Pp) 要添加默认值的0.95％，否则为〜12.6kb 注意 这些估计是基于Micrometer1.0.3中所做的改进，并且假定至少使用该版本。 注意 特别是对于Prometheus ，无论您如何尝试通过DistributionSummary.Builder进行配置，R 始终等于1。这对于Prometheus来说是特殊情况，因为它期望的是永不翻转的累积直方图数据。 12.长任务timers&emsp;&emsp;长任务timers是一种特殊的timer，可让我们在正在测量的事件仍在运行时测量时间。在任务完成之前，计时器不会持续记录时间。 &emsp;&emsp;现在考虑一个后台过程来刷新数据存储中的元数据。例如，Edda缓存AWS资源，例如实例、卷、自动扩展组等。通常，所有数据都可以在几分钟内刷新。如果AWS服务出现问题，则可能需要更长的时间。长任务timer可用于跟踪刷新元数据的总时间。 &emsp;&emsp;例如，在Spring应用程序中，通常使用来实现如此长时间运行的进程@Scheduled。MicroMeter提供了特殊的@Timed注释，用于使用长任务timer来可视化这些过程。 @Timed(value = &quot;aws.scrape&quot;, longTask = true) @Scheduled(fixedDelay = 360000) void scrapeResources() &#123; // find instances, volumes, auto-scaling groups, etc... &#125;&emsp;&emsp;@Timed是否生效取决于应用程序框架。如果所选择的框架不支持它，我们仍然可以使用长任务计时器： LongTaskTimer scrapeTimer = registry.more().longTaskTimer(&quot;scrape&quot;); void scrapeResources() &#123; scrapeTimer.record(() =&gt; &#123; // find instances, volumes, auto-scaling groups, etc... &#125;); &#125;&emsp;&emsp;如果我们想在此过程超过阈值时发出警报，则需要longtasktimer，超过阈值后，我们将在第一个报告间隔收到该警报。如果使用常规timer，则直到该过程完成后的第一个报告间隔（超过一个小时），我们才会收到警报！ &emsp;&emsp;该接口包含用于Longtasktimer的流利的构建器： LongTaskTimer longTaskTimer = LongTaskTimer .builder(&quot;long.task.timer&quot;) .description(&quot;a description of what this timer does&quot;) // optional .tags(&quot;region&quot;, &quot;test&quot;) // optional .register(registry); 13 直方图和百分位数&emsp;&emsp;Timer和分布式summary支持收集数据以观察其百分比分布。查看百分位数的主要方法有两种： &emsp;&emsp;1.百分比直方图 -MicroMeter将值累加为基础直方图，并将预定的一组buckets集合发送给监视系统。监视系统的查询语言负责计算此直方图的百分位数。目前，只有Prometheus，Atlas，和Wavefront支持直方图基于百分比近似，通过histogram_quantile，:percentile和hs()分别。如果定位到Prometheus，Atlas或Wavefront，则最好使用此方法，因为我们可以汇总各个维度上的直方图（通过简单地将一组维度中各个值的值相加）并从该直方图中得出可凝集的百分位数。 &emsp;&emsp;2.客户端百分位数 -MicroMeter为每个仪表ID（名称和标签集）计算百分位数近似值，并将百分位数值发送到监视系统。这不能像百分位数直方图那样灵活，因为不可能汇总标签之间的百分位数近似值。但是，它为不支持基于直方图的服务器端百分比计算的监视系统提供了一定百分比的洞察力。 &emsp;&emsp;这是一个使用直方图构建计时器的示例： Timer.builder(&quot;my.timer&quot;) .publishPercentiles(0.5, 0.95) // median and 95th percentile .publishPercentileHistogram() .sla(Duration.ofMillis(100)) .minimumExpectedValue(Duration.ofMillis(1)) .maximumExpectedValue(Duration.ofSeconds(10))&emsp;&emsp;1.publishPercentiles-用于发布在我们的应用中计算出的百分位值。这些值在各个维度上都是不可凝聚的。 &emsp;&emsp;2.publishPercentileHistogram-用于发布直方图，该直方图适用于在Prometheus使用histogram_quantile，Atlas使用:percentile和Wavefront使用中计算可聚集的（跨维度）百分位近似hs()。对于Prometheus和Atlas，结果的直方图中的buckets值由MicroMeter根据由Netflix凭经验确定的生成器进行预设，以在大多数现实世界timer和分布式summary上产生合理的误差。默认情况下，生成器会产生276个存储桶，但Micrometer仅发送那些在设置范围内（包括minimumExpectedValue和maximumExpectedValue）的buckets值。MicroMeter默认将timer限制在1毫秒到1分钟的范围内，每个timer产生73个直方图桶。publishPercentileHistogram 对不支持可凝集百分位数逼近的系统没有影响-这些系统未提供直方图。 &emsp;&emsp;3.sla-发布包含我们SLA定义的buckets的累积直方图。与publishPercentileHistogram支持可聚集百分位数的监视系统配合使用，此设置将其他buckets添加到已发布的直方图中。在不支持可聚集百分位数的系统上使用时，此设置将导致仅使用这些存储桶发布直方图。 &emsp;&emsp;4.minimumExpectedValue/ maximumExpectedValue-控制publishPercentileHistogram发送的存储桶的数量，以及控制基础HdrHistogram结构的准确性和内存占用量。 &emsp;&emsp;由于将百分位数发送到监视系统会生成其他时间序列，因此通常最好不要在作为依赖项包含在应用程序中的核心库中对其进行配置。取而代之的是，应用程序可以通过meter过滤器为某些计时器/分配摘要集启用此行为。 &emsp;&emsp;例如，假设我们在一个公共库中有几个计时器。我们为这些计时器名称添加了前缀myservice： registry.timer(&quot;myservice.http.requests&quot;).record(..); registry.timer(&quot;myservice.db.requests&quot;).record(..);&emsp;&emsp;我们可以通过仪表过滤器为两个timer打开客户端百分位数： registry.config().meterFilter( new MeterFilter() &#123; @Override public DistributionStatisticConfig configure(Meter.Id id, DistributionStatisticConfig config) &#123; if(id.getName().startsWith(&quot;myservice&quot;)) &#123; return DistributionStatisticConfig.builder() .percentiles(0.95) .build() .merge(config); &#125; return config; &#125; &#125;);","categories":[{"name":"Monitor System","slug":"Monitor-System","permalink":"http://yoursite.com/categories/Monitor-System/"}],"tags":[]},{"title":"小技巧","slug":"小技巧","date":"2019-11-11T11:24:12.000Z","updated":"2019-11-11T13:43:38.880Z","comments":true,"path":"2019/11/11/小技巧/","link":"","permalink":"http://yoursite.com/2019/11/11/%E5%B0%8F%E6%8A%80%E5%B7%A7/","excerpt":"","text":"for(i=0;i&lt;n;i++){} for(i=n;i;i–){}下面这一项是boolean比较，编译速度要快上一倍； 不用申请额外空间完成数值交换a = a^bb = a^ba = a^b BitMask将帅问题 python代码实现一遍然后再写一个文档说明。 模考必考的大体类型KNN算法和聚类算法 信息熵的概念信息熵的算法解决过拟合问题–剪枝，避免决策树太深 AI一、资源管理工具1.1 Kubernate1.2 Docker1.3 OpenStack 二、硬件加速2.1 InfiniBand2.2 NVMESSD2.3 GPU2.4 FPGA2.5 ASIC cpu为什么会发热？计算机发生了信息丢失时就会发热，","categories":[],"tags":[]},{"title":"posts","slug":"posts","date":"2019-11-11T11:23:48.000Z","updated":"2019-11-11T11:23:49.001Z","comments":true,"path":"2019/11/11/posts/","link":"","permalink":"http://yoursite.com/2019/11/11/posts/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"SpringBoot-日志","slug":"SpringBoot-日志","date":"2019-11-10T02:06:55.000Z","updated":"2019-11-10T05:24:23.340Z","comments":true,"path":"2019/11/10/SpringBoot-日志/","link":"","permalink":"http://yoursite.com/2019/11/10/SpringBoot-%E6%97%A5%E5%BF%97/","excerpt":"","text":"在我们的日常开发中，通常需要查看日志来帮我们解决程序运行中的一些错误问题及对程序运行过程的监控，这篇文章主要是讲解在SpringBoot中日志的工作原理、日志实现类的选择、日志的展示及存储方式等内容。 一、常用的日志框架JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j…. 其中属于日志门面（日志的抽象层）的是：JCL（Jakarta Commons Logging） SLF4j（Simple Logging Facade for Java）、jboss-logging 属于日志的实现类的是：Log4j2 Logback、Log4j JUL（java.util.logging） 我们一般是选择SLF4j作为抽象层，Logback作为实现类 springboot也是选用的SLF4j和Logback 二、如何在系统中使用SLF4j开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法；给系统里面导入slf4j的jar和 logback的实现jar 具体的实现代码如下： import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info(&quot;Hello World&quot;); &#125; &#125; 抽象类与实现类之间的关系如下所示,每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件。 三、遗留问题在springboot中我们含有很多的框架，如Spring、Hebernate、MyBatis等，这些不同的日志框架使用的日志实现类是不相同的，那么我们如何实现不同的日志实现类之间的协调统一呢？ 如：a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx 统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？ 如何让系统中所有的日志都统一到slf4j： 1、将系统中其他日志框架先排除出去； 2、用中间包来替换原有的日志框架； 3、我们导入slf4j其他的实现； 四、SpringBoot的日志依赖关系： 总结： 1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录 2）、SpringBoot也把其他的日志都替换成了slf4j； 3）、中间替换包？ 4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？Spring框架用的是commons-logging；如下为在SpringBoot中引入依赖后的转换jar包 SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要 把这个框架依赖的日志框架排除掉即可； &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring‐core&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons‐logging&lt;/groupId&gt; &lt;artifactId&gt;commons‐logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency 五 日志的使用SpringBoot默认帮我们配置好了日志； 默认配置import org.junit.jupiter.api.Test; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.boot.test.context.SpringBootTest; @SpringBootTest class DemoApplicationTests &#123; //日志记录器 Logger logger = LoggerFactory.getLogger(getClass()); @Test void contextLoads() &#123; //日志的级别由低到高 trace&lt;debug&lt;info&lt;warn&lt;error //可以调整输出的日志级别，日志就只会在这个级别以后的级别中生效 logger.trace(&quot;这是trace()日志&quot;); logger.debug(&quot;这是debug日志&quot;); //springboot默认提供的是info级别 logger.info(&quot;这是info日志&quot;); logger.warn(&quot;这是warn日志&quot;); logger.error(&quot;这是error日志&quot;); &#125; &#125;当然我们可以对日志的输出格式、输出位置、默认级别等等做相应的调整 #指定日志的输出级别，默认条件为info级别的。 logging.level.csu = trace #在当前目录下生成springboot.log日志 #不指定目录则在当前目录下生成springboot.log日志 #logging.file = springboot.log #也可以指定springboot.log的生成路径 logging.file= F:/springboot.log #指定控制台输出的文件格式 logging.pattern.console==%d&#123;yyyy‐MM‐dd&#125; [%thread] %‐5level %logger&#123;50&#125; ‐ %msg%n #指定文件中日志的输出格式 logging.pattern.file=%d&#123;yyyy‐MM‐dd&#125; === [%thread] === %‐5level === %logger&#123;50&#125; ==== %msg%n关于日志的输出格式简介： 日志输出格式： %d表示日期时间 %thread表示线程名 %‐5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符指定配置给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了 logback.xml：直接就被日志框架识别了； logback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot 的高级Proﬁle功能 所以我们一般使用加上了“-spring”后缀的命名格式，如下所示在开发过程中就可以指定在开发环境和非开发环境使用的日志格式了。 &lt;springProfile name=&quot;dev&quot;&gt; &lt;pattern&gt;%d&#123;yyyy‐MM‐dd HH:mm:ss.SSS&#125; ‐‐‐‐&gt; [%thread] ‐‐‐&gt; %‐5level %logger&#123;50&#125; ‐ %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;springProfile name=&quot;!dev&quot;&gt; &lt;pattern&gt;%d&#123;yyyy‐MM‐dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %‐5level %logger&#123;50&#125; ‐ %msg%n&lt;/pattern&gt; &lt;/springProfile&gt;如果直接使用没有“-spring”后缀的格式设置开发环境和非开发环境的日志格式会发生错误； 当然我们也可以使用在配置中设置环境变量来进行开发环境选择：spring.profiles.active=dev 六 切换日志框架SpringBoot的默认方式为SLF4j+Logback形式的，现在我们将其切换成SLF4j+log4j的形式，具体操作如下：","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[]},{"title":"Hadoop学习笔记","slug":"Hadoop学习笔记","date":"2019-10-27T07:04:26.000Z","updated":"2019-11-10T05:24:08.546Z","comments":true,"path":"2019/10/27/Hadoop学习笔记/","link":"","permalink":"http://yoursite.com/2019/10/27/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"HDFS概述NameNode(nn):存储文件的元数据，如文件名、文件目录结构、文件属性（生成时间、副本数、文件权限），以及每个文件的块列表和和块所在的DataNode等。 DataNode(dn):在本地文件系统存储文件数据块以及数据块的校验和。 Secondary NameNode(2nn):用来监控HDFS的辅助后台程序，每隔一段时间获取HDFS元数据的快照。 yarn架构图 常见的正则表达式 为什么不能一直格式化NameNode,格式化NameNode需要注意什么？集群在工作的时候他的datanode的集群id和namenode的集群id是一样的，这样才能保证集群的正常工作，如果你格式化了namenode的集群id这个时候你的datanode的集群id是没有改变的，他们两个不一致的话集群无法正常工作。 如果需要格式化NameNode的信息，那就需要datanode中的关于集群id的信息删除； 关于YARN ResourceManager:集群资源的总管NodeManager:单个节点资源的总管 HDFS的优缺点 优点 1.高容错性 2.适合处理大数据 3.可构建在廉价机器上 缺点 1.不适合低延时数据访问 2.无法高效的对大量小文件进行存储 1.存储大量小文件的话，会占用NameNode的大量内存来存储文件目录和块信息，但NameNode的内存总是有限的 2.小文件的存储时间会超过读取时间，违反了DFSDE的设计目标 3.不支持并发写入，文件的随机修改 一个文件只能有一个写，不允许多个线程同时写 仅支持数据的追加，不支持数据的随机修改","categories":[{"name":"hadoop","slug":"hadoop","permalink":"http://yoursite.com/categories/hadoop/"}],"tags":[]},{"title":"Linux笔记","slug":"Linux笔记","date":"2019-10-20T04:34:24.000Z","updated":"2019-11-04T07:27:26.014Z","comments":true,"path":"2019/10/20/Linux笔记/","link":"","permalink":"http://yoursite.com/2019/10/20/Linux%E7%AC%94%E8%AE%B0/","excerpt":"","text":"linux是在日常开发中常用的一个操作系统，但是linux中的指令实在太多了，这篇博客主要是记录平时常用的一些指令进行汇总。 如何进行secureCRT连接的不同界面之间的切换——Alt+”Num”如图所示为4个不同的连接的页面，我们在进行切换时直接按住 Alt+”连接界面所处的位置” 如何在linux中关掉一些进程scp 文件安全拷贝命令（ secure copy）scp -r 本地文件地址 username@ip:目的账户的保存地址（如果是文件的话就不需要加上 -r 了） xsync集群分发脚本在进行集群配置的时候可能会需要在master上进行了配置，然后有需要将配置好的文件逐个传输到其他的文件夹下面，这样是非常的耗费精力的，为了实现快速的进行向各个节点的文件传输，我们这里采取配置xsync集群分发脚本。 集群时间的同步操作","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[]},{"title":"牛顿迭达法","slug":"牛顿迭达法","date":"2019-10-20T01:28:44.000Z","updated":"2019-10-20T11:23:04.375Z","comments":true,"path":"2019/10/20/牛顿迭达法/","link":"","permalink":"http://yoursite.com/2019/10/20/%E7%89%9B%E9%A1%BF%E8%BF%AD%E8%BE%BE%E6%B3%95/","excerpt":"","text":"多数方程不存在求根公式，因此求精确根非常困难，甚至不可能，从而寻找方程的近似根就显得特别重要，牛顿迭达法就是一种有效的求近似根的方法。 一、问题引入 ##实现 int sqrt(int x) 函数。 &emsp;&emsp;计算并返回 x 的平方根，其中 x 是非负整数。 &emsp;&emsp;由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例 1: 输入: 4 输出: 2 示例 2: 输入: 8 输出: 2 &emsp;&emsp;说明: 8 的平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去 ###此处要求算的是一个数的平方根，所以我们可以很合理的考虑使用牛顿迭达法（也称牛顿法或牛顿-拉夫森法） ###一、牛顿法的基本思想： &emsp;&emsp;通过迭代来实现，每次运算都让结果比之前好一点。 &emsp;&emsp;哪怕只好一点点，在很多次迭代之后也可以得到一个很好的结果甚至最优或期望的结果。 ###二、牛顿法的目的： &emsp;&emsp;牛顿法就是通过使原方程泰勒展开的一阶近似等于零不断获得更好的结果的求解方程零点的方法。 ###三、牛顿迭达法的详解 牛顿法是求解方程零点的方法 牛顿法利用泰勒展开的一阶近似的零点获得更接近真实零点的点 牛顿法通过迭代的方法不断的获得更好的解来求得最好的解 ![函数的泰勒展开](https://wx1.sinaimg.cn/mw690/007857NYly1g84fnxcv24j30yp0himya.jpg) ####具体的图像如下所示： ![二次函数迭达求零点](https://wx2.sinaimg.cn/mw690/007857NYly1g84fo1jounj30sc0lygmc.jpg) &emsp;&emsp;图中最右边点为原来猜想的点，然后经过迭达后得到左边的橙色点，这样子逐步逼近到零点。 ####&emsp;&emsp;当然对于这个公式还有个问题，为什么是一阶导而不是二阶导或者三阶导呢？ 第一是一阶导已经能够满足我们的需求了； 第二就是二阶导三阶导不一定存在，而且就算存在计算也会比较麻烦。 ###&emsp;&emsp;好了，现在我们已经熟悉牛顿迭达法的原理了，那么解决上述问题就是轻而易举地事情，具体的代码如下： class Solution &#123; int s; public int mySqrt(int x) &#123; s=x; if(x==0) return 0; return ((int)(sqrts(x))); &#125; public double sqrts(double x)&#123; double res = (x + s / x) / 2; if (res == x) &#123; return x; &#125; else &#123; return sqrts(res); &#125; &#125; &#125;&emsp;&emsp;根据牛顿迭达法我们知道 x−f(x)/(2x)就是一个比x更准确的的近似值，此处将 f(x)=x^2-a 代入到上述的公式中就得到x−(x^2−a)/(2x)，也就是(x+a/x)/2,(上述的a就是我们要求平方根的2)，循环的结束条件就是我们通过牛顿迭达法得到的值res已经达到稳定了（或者说不再发生变化了）。 参考博客：牛顿法及牛顿法求解优化问题","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"Daily Plan","slug":"Daily-Plan","date":"2019-10-20T01:07:33.000Z","updated":"2019-11-01T15:30:01.194Z","comments":true,"path":"2019/10/20/Daily-Plan/","link":"","permalink":"http://yoursite.com/2019/10/20/Daily-Plan/","excerpt":"","text":"每天给自己定一个计划，持续努力，遇见不一样的自己！ 2019年10月20日1.写一篇关于牛顿迭达法求最优解的博客（上午） 2.学习python两小时--笔记总结（上午） 3.好好改善自己的博客页面--中午 4.总结多线程中的生产者-消费者模式--还有队列安全实现（下午） 5.稍微看一下实习任务作内容（下午） 6.总结一下http的连接方式，get和post的区别 --- 2019年10月21日1.总结一下Object对象的那些内置方法； 2.学习Linux完成75-80集，好好回顾昨天的内容； 3.一定要写出来prometheus系统对于java客户端的监控来； 4.总结昨天做的合并两个有序数组的内容； 5.学习5集左右springboot的内容； --- 2019年10月22日昨天的任务当然是没有完成的，今天的要求降低。 1.整理好prometheus的相关内容（上班时间，能够讲明白，能够实现，80%） 2.看10集linux的内容（晚上，已完成） 3.整理好自己前几天刷的题（晚上，完成50%） 4.多线程的基础内容回顾（晚上，未完成）2019年10月23日1.今天成功实现了prometheus每秒请求数量和请求响应时间的监察； 2.在地铁上学习了关于多线程中的避免死锁的三种方法：顺序加锁、设置等待时间、忘了还有一个是什么了； 3.还学了一个新的东西Atomic,cas原理和ABA问题； 4.Linux学了十集，下载软件 文件的压缩解压缩 硬链接软连接 大概这些印象深一些；2019年10月23日1.实习上完成了一些简单的查询功能； 2.做了一道leetcode上的中档题，感觉自己思路比较渣，大佬思路太棒了； 3.学习了多线程的线程池相关知识，但不是很深入，明天还得继续线程池； 4.学习了python的一些基础语法，但感觉学的东西很简单，我学java时候也接触过了； 5.明天得装好python3然后安装号pycharm 2019年10月26日漏了好几天的总结回顾了，昨天还忘记刷leetcode了…… 1.看完了集合元素里面的list集合，对于具体的东西可以尝试博客记录一下。2.然后也看完了Linux的基础操作，准备每天再看一下别人总结的博客内容，copy整理一下；3.三天刷了两道leetcode，主要是关于二叉树的内容，得好好总结一下了，不能老是忘记；4.自动化数据分析学习了一下决策树算法的概述5.大数据平台核心技术学习了hadoop集群的部署，以及在hadoop集群中数据是如何进行传输保存的； 2019年10月31日今天成功的将qps和latency指标写进了系统里面 2019年11月1日今天开始了阿波罗配置系统的学习","categories":[{"name":"每日计划","slug":"每日计划","permalink":"http://yoursite.com/categories/%E6%AF%8F%E6%97%A5%E8%AE%A1%E5%88%92/"}],"tags":[]},{"title":"易忘的一些琐碎操作","slug":"易忘的一些琐碎操作","date":"2019-10-19T14:30:46.000Z","updated":"2019-10-20T11:23:15.107Z","comments":true,"path":"2019/10/19/易忘的一些琐碎操作/","link":"","permalink":"http://yoursite.com/2019/10/19/%E6%98%93%E5%BF%98%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%90%E7%A2%8E%E6%93%8D%E4%BD%9C/","excerpt":"","text":"这篇博客记录的是一些琐碎但重要的内容 一、如何写一篇博客并部署到github上？ 第1步：首先在博客所在的文件目录下打开git客户端，新建一个markdown文件 hexo new post &quot;article title&quot; 第2步：书写博客，具体的markdown的语法格式参考如下： markdown语法 第3步：清除本地缓存 hexo clean 第4步：进行渲染 hexo generate 简写作 hexo g 第5步：部署到本地 hexo server 简写作 hexo s此时会弹出本地链接地址进行浏览 第6步：部署到git服务器 hexo deploy 简写作 hexo d --- #二、运行web项目时发生了端口已占用如何解决？ 第一步：打开命令窗口查看对应端口号的进程及其PID Windows+R——打开命令窗口 netstat -ano——查看具体进程的pid 第2步：打开任务管理器，在“详细”处根据pid找到进程然后强制关闭","categories":[{"name":"实用操作","slug":"实用操作","permalink":"http://yoursite.com/categories/%E5%AE%9E%E7%94%A8%E6%93%8D%E4%BD%9C/"}],"tags":[]},{"title":"markdown常用语法","slug":"markdown-note","date":"2019-10-15T13:51:46.000Z","updated":"2019-11-15T14:23:09.339Z","comments":true,"path":"2019/10/15/markdown-note/","link":"","permalink":"http://yoursite.com/2019/10/15/markdown-note/","excerpt":"","text":"如何用markdown写博客？需要的语法都在这里 标题 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 一级标题二级标题三级标题四级标题五级标题 引用 &gt;一级引用 &gt; &gt;&gt;二级引用 &gt; &gt;一级引用 一级引用 二级引用 一级引用 行开头加“点” * red * green * blue red green blue 加上序号 1.red 2.green 3.red1.red 2.green 3.red 代码块区域：直接点上面的code“&lt;&gt;”就可以了； public class Hello&#123; public static void main(String[] args)&#123; System.out.println(&quot;Hello MarkDown); &#125; &#125; 斜体 *这是斜体的方式* _这是斜体的方_这是斜体的方式 这是斜体的方 粗体 **这是粗体** __这是粗体__这是粗体 这是粗体 ># **标记行内小段代码** >加上 ‘’ 即可 use the `printf()` function.use the printf() function. 自动连接 语法格式：加上左右尖括号 &lt;http://example.com/&gt;示例：字节跳动招聘官网 https://job.bytedance.com/intern 行内链接 语法格式 这是 [字节跳动](https://job.bytedance.com/intern/ &quot;title&quot;) 的连接.这是字节跳动的连接 图片 语法格式： [图片alt](图片地址 &apos;&apos;图片title&apos;&apos;) 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。 图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 ![字节跳动](https://wx1.sinaimg.cn/mw690/007857NYgy1g7z99tuyqbj30hs0hsglq.jpg) 如何实现首行缩进 &amp;ensp;这是半方大的空白 &amp;emsp;这是全方大的空白 &amp;nbsp;这是不断行的空白&ensp;这是半方大的空白 &emsp;这是全方大的空白 &nbsp;这是不断行的空白 --- 如何设置图片居中 在图片标签之前加上&lt;div align=center&gt;标签 &lt;div align=center&gt;![字节跳动](https://wx1.sinaimg.cn/mw690/007857NYgy1g7z99tuyqbj30hs0hsglq.jpg)![字节跳动](https://wx1.sinaimg.cn/mw690/007857NYgy1g7z99tuyqbj30hs0hsglq.jpg) 表格 表头 表头 表头 内容 内容 内容 内容 内容 内容 第二行分割表头和内容。 - 有一个就行，为了对齐，多加了几个 文字默认居左 -两边加：表示文字居中 -右边加：表示文字居右 注：原生的语法两边都要用 | 包起来。 流程图 此处留白先，不会用。 ># **分割线** `---` 转义符号\\ 下面这些符号可以通过转义符号来实现 \\ 反斜线 ` 反引号 * 星号 _ 底线 &#123;&#125; 花括号 [] 方括号 () 括弧 # 井字号 + 加号 - 减号 . 英文句点 ! 惊叹号","categories":[{"name":"实用操作","slug":"实用操作","permalink":"http://yoursite.com/categories/%E5%AE%9E%E7%94%A8%E6%93%8D%E4%BD%9C/"}],"tags":[]},{"title":"二叉树","slug":"二叉树","date":"2019-09-11T14:00:00.000Z","updated":"2019-10-20T11:22:53.434Z","comments":true,"path":"2019/09/11/二叉树/","link":"","permalink":"http://yoursite.com/2019/09/11/%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"关于二叉树的定义以及遍历方式 #二叉树二叉树：任何一个节点的子节点数量不超过2，二叉树的子节点分为左节点和右节点 满二叉树：所有叶子节点都在最后一层，而且节点的总数为Math.pow(2,n)个，其中n是指树的高度 完全二叉树：所有叶子节点都在最后一层或者倒数第二层，且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续完全二叉树是可以从左向右一直数下去的，如果出现了数数过程中的不连续，那么就说明不是一棵完全二叉树（如果图中没有6和7,那么就不是一棵完全二叉） ####树的遍历对于下图的二叉树进行遍历时，其三种遍历顺序结果为 前序遍历：ABCDEFGHK 中序遍历：BDCAEHGKF 后序遍历：DCBHKGFEA 前序遍历： 中左右进行遍历时，先从最中间的根节点开始，然后是左子树，左子树的遍历也是按照先中间，再左边，然后右边的顺序进行的，遍历完左子树，再进行右子树的遍历。先从最中间开始，A，然后再到左子树AB,B没有左节点，故ABC,C结束后再C的先左右节点，ABCD,然后到了A的右子树，查找顺序是一样的，就不再进行赘述了得到ABCDEFGHK 中序遍历： 左中右先从根节点开始，根节点有左节点，所以到了B位置，然后再找B的左节点的，但是为空，所以第一个为B，再到B的右节点C，此时C有左节点，优先左节点D，然后再C，C没有右节点，这个时候左子树就结束了为BDC,然乎是中间的根节点A，为BDCA，再到右子树，右子树的查找顺序是一样的，先找有没有左节点，然后再中间节点，再右节点，最后得到的结果为:BDCAEHGKF后序遍历： 左右中进行遍历时，先从左子树开始，从左子树的左边的叶子节点开始，然后一直到左子树遍历结束，然后右子树，遍历方式是一样的，再是中间的根节点。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]}],"categories":[{"name":"springboot","slug":"springboot","permalink":"http://yoursite.com/categories/springboot/"},{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/categories/%E7%88%AC%E8%99%AB/"},{"name":"Monitor System","slug":"Monitor-System","permalink":"http://yoursite.com/categories/Monitor-System/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"},{"name":"hadoop","slug":"hadoop","permalink":"http://yoursite.com/categories/hadoop/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"每日计划","slug":"每日计划","permalink":"http://yoursite.com/categories/%E6%AF%8F%E6%97%A5%E8%AE%A1%E5%88%92/"},{"name":"实用操作","slug":"实用操作","permalink":"http://yoursite.com/categories/%E5%AE%9E%E7%94%A8%E6%93%8D%E4%BD%9C/"}],"tags":[]}