<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dongonns</title>
  
  <subtitle>To change the fate of the first, to change their own.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-05-04T08:21:22.706Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>dongcheng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>go中rune数据类型</title>
    <link href="http://yoursite.com/2022/05/04/go%E4%B8%ADrune%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2022/05/04/go%E4%B8%ADrune%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2022-05-04T07:35:00.000Z</published>
    <updated>2022-05-04T08:21:22.706Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>什么是rune,看下官方回答</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rune is an alias for int32 and is equivalent to</span></span><br><span class="line"><span class="comment">// int32 in all ways. It is</span></span><br><span class="line"><span class="comment">// used, by convention, to distinguish character</span></span><br><span class="line"><span class="comment">// values from integer values.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int32的别名，几乎在所有方面等同于int32</span></span><br><span class="line"><span class="comment">// 它用来区分字符值和整数值</span></span><br></pre></td></tr></table></figure><p>type rune &#x3D; int32<br><b>划重点：用它来区分字符值和整数值</b></p><p>大家知道计算机在底层处理的都是零和一的数字，那么字符串也不另外。string字符串在转换成byte之后其实都是一个数值，我们知道常规的英文字符是ascii码是通过一个字节( 2^8 其实还有一位是不用的 )来存储，中国文字、日本文字常用文字就有4000+，通过2^8肯定表达不了，所有可以通过unicode来存储，占用2个字节。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;go-algorithm&quot;</span>,<span class="built_in">len</span>(<span class="string">&quot;go-algorithm&quot;</span>))</span><br><span class="line">fmt.Println(<span class="string">&quot;go算法&quot;</span>,<span class="built_in">len</span>(<span class="string">&quot;go算法&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">go</span>-algorithm <span class="number">12</span></span><br><span class="line"><span class="attribute">go</span>算法 <span class="number">8</span></span><br></pre></td></tr></table></figure><p>为什么go算法的长度是8，不应该是6么？<br>这个就要讲到go语言的编码是按照UTF-8编码规则来的。</p><p>UTF-8 顾名思义，是一套以 8 位为一个编码单位的可变长编码。会将一个码位编码为 1 到 4 个字节：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">U</span>+ <span class="number">0000</span> ~ U+  <span class="number">007</span>F: <span class="number">0</span>XXXXXXX</span><br><span class="line"><span class="attribute">U</span>+ <span class="number">0080</span> ~ U+  <span class="number">07</span>FF: <span class="number">110</span>XXXXX <span class="number">10</span>XXXXXX</span><br><span class="line"><span class="attribute">U</span>+ <span class="number">0800</span> ~ U+  FFFF: <span class="number">1110</span>XXXX <span class="number">10</span>XXXXXX <span class="number">10</span>XXXXXX</span><br><span class="line"><span class="attribute">U</span>+<span class="number">10000</span> ~ U+<span class="number">10</span>FFFF: <span class="number">11110</span>XXX <span class="number">10</span>XXXXXX <span class="number">10</span>XXXXXX <span class="number">10</span>XXXXXX</span><br></pre></td></tr></table></figure><p>我们再深究下为什么 “算法” 占用6个字节的长度<br>我们查询到这两个汉字的16进制值得区间在UTF-8的第三区段，那么在go的编码下会占用三个字符。</p><p>由于编码的原因我们如果按照一个个字节的方式去处理字符串会导致处理规则没办知道是按照一个字节处理、两个字节处理或者三个字节处理，处理不对输出的子字符串可能是乱码。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> <span class="built_in">str</span> = <span class="string">&quot;go算法&quot;</span></span><br><span class="line">fmt.Println(<span class="built_in">str</span>[:<span class="number">4</span>])</span><br><span class="line"><span class="comment">// 输出：go�</span></span><br></pre></td></tr></table></figure><p>所以在go语言中引进了rune的概念。在我们对字符串进去处理的时候只需要将字符串通过range去遍历，会按照rune为单位自动去处理，极其便利。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;go算法&quot;</span></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> str &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;v type: %T\n&quot;</span>, v)</span><br><span class="line">fmt.Println(v,k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出如下：</span><br><span class="line">v <span class="keyword">type</span>: <span class="keyword">int32</span></span><br><span class="line"><span class="number">103</span> <span class="number">0</span></span><br><span class="line">v <span class="keyword">type</span>: <span class="keyword">int32</span></span><br><span class="line"><span class="number">111</span> <span class="number">1</span></span><br><span class="line">v <span class="keyword">type</span>: <span class="keyword">int32</span></span><br><span class="line"><span class="number">31639</span> <span class="number">2</span></span><br><span class="line">v <span class="keyword">type</span>: <span class="keyword">int32</span></span><br><span class="line"><span class="number">27861</span> <span class="number">5</span></span><br><span class="line">我们可以通过 <span class="number">31639</span>去查询他代表的汉字就是“算”</span><br></pre></td></tr></table></figure><p>其中返回的v变量类型int32<br>在 Go 1.9 版本中对rune的定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">byte</span> = <span class="keyword">uint8</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">rune</span> = <span class="keyword">int32</span></span><br></pre></td></tr></table></figure><p>通过上面的代码我们已经很清楚的知道rune类型实质其实就是int32，他是go语言内在处理字符串及其便捷的字符单位。它会自动按照字符独立的单位去处理方便我们在遍历过程中按照我们想要的方式去遍历。<br>另外一个使用场景就是：我们在处理字符串的时候可以通过map[rune]int类型方便的判断字符串是否存在，其中 rune表示字符的UTF-8的编码值，int表示字符在字符串中的位置(按照字节的位置)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;什么是rune,看下官方回答&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;spa
      
    
    </summary>
    
    
      <category term="Go" scheme="http://yoursite.com/categories/Go/"/>
    
    
  </entry>
  
  <entry>
    <title>MapReduce论文学习</title>
    <link href="http://yoursite.com/2022/05/02/MapReduce%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2022/05/02/MapReduce%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-05-02T11:44:00.000Z</published>
    <updated>2022-05-04T08:09:58.875Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>&amp;emsp;&amp;emsp;MapReduce是一个编程模型，也是一个处理和生成超大数据集的算法模型的相关实现。用户首先创建一个Map函数处理一个基于key&#x2F;value pair的数据集合，输出中间的基于key&#x2F;value pair的数据集合；然后再创建一个基于Reduce函数用来合并所有的具有相同中间key值的中间value值。<br>&amp;emsp;&amp;emsp;MapReduce架构的程序能够再大量的普通配置的计算机上实现并行处理，这个系统在运行时只关心：如何分割输入数据，在大量计算机组成的集群上的调度，集群中计算机的错误处理，管理集群中计算机之间必要的通信。</p><h2 id="二、编程模型"><a href="#二、编程模型" class="headerlink" title="二、编程模型"></a>二、编程模型</h2><p>&amp;emsp;&amp;emsp;MapReduce 编程模型的原理是：利用一个输入 key&#x2F;value pair 集合来产生一个输出的 key&#x2F;value pair 集合。 MapReduce 库的用户用两个函数表达这个计算：Map 和 Reduce。<br>&amp;emsp;&amp;emsp;用户自定义的 Map 函数接受一个输入的 key&#x2F;value pair 值，然后产生一个中间 key&#x2F;value pair 值的集合。 MapReduce 库把所有具有相同中间 key 值 I 的中间 value 值集合在一起后传递给 reduce 函数。<br> &amp;emsp;&amp;emsp;用户自定义的 Reduce 函数接受一个中间 key 的值 I 和相关的一个 value 值的集合。Reduce 函数合并这些value 值，形成一个较小的 value 值的集合。一般的，每次 Reduce 函数调用只产生 0 或 1 个输出 value 值。通常我们通过一个迭代器把中间 value 值提供给 Reduce 函数，这样我们就可以处理无法全部放入内存中的大量的 value 值的集合。 </p><p>###2.1 词数统计伪码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>(String key, String value):</span><br><span class="line">    <span class="comment">// key: document name</span></span><br><span class="line">    <span class="comment">// value: document contents</span></span><br><span class="line">    <span class="keyword">for</span> each word w in value:</span><br><span class="line">        <span class="built_in">EmitIntermediate</span>(w, <span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="built_in">reduce</span>(String key,Iterator values):</span><br><span class="line">    <span class="comment">// key: a word</span></span><br><span class="line">    <span class="comment">// values:a list of counts</span></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> each v in values:</span><br><span class="line">        result += <span class="built_in">ParseInt</span>(v);</span><br><span class="line">    <span class="built_in">Emit</span>(<span class="built_in">AsString</span>(result))    </span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;Map 函数输出文档中的每个词、以及这个词的出现次数(在这个简单的例子里就是 1)。Reduce 函数把 Map函数产生的每一个特定的词的计数累加起来。 </p><h2 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a>三、实现</h2><p>&amp;emsp;&amp;emsp;MapReduce 模型可以有多种不同的实现方式。如何正确选择取决于具体的环境。例如，一种实现方式适用于小型的共享内存方式的机器，另外一种实现方式则适用于大型 NUMA 架构的多处理器的主机，而有的实现方式更适合大型的网络连接集群。 </p><h3 id="3-1-执行概括"><a href="#3-1-执行概括" class="headerlink" title="3.1 执行概括"></a>3.1 执行概括</h3><p>&amp;emsp;&amp;emsp;通过将 Map 调用的输入数据自动分割为 M 个数据片段的集合，Map 调用被分布到多台机器上执行。输入的数据片段能够在不同的机器上并行处理。使用分区函数将 Map 调用产生的中间 key 值分成 R 个不同分区（例如，hash(key) mod R），Reduce 调用也被分布到多台机器上执行。分区数量（R）和分区函数由用户来指定。<br><img src="https://ladychili.top/CS5052-1-MapReduce/overview.png" alt="MapReduce执行流程"></p><center> <b>图1 MapReduce执行流程 </b></center><p>&amp;emsp;&amp;emsp;图1为MapReduce实现中操作的全部流程，当调用MapReduce时将会发生如下一系列操作：<br>&amp;emsp;&amp;emsp;1.用户程序首先调用的 MapReduce 库将输入文件分成 M 个数据片度，每个数据片段的大小一般从16MB 到 64MB(可以通过可选的参数来控制每个数据片段的大小)。然后用户程序在机群中创建大量的程序副本。<br>&amp;emsp;&amp;emsp;2.这些程序副本中的有一个特殊的程序–master。副本中其它的程序都是 worker 程序，由 master 分配任务。有 M 个 Map 任务和 R 个 Reduce 任务将被分配，master 将一个 Map 任务或 Reduce 任务分配给一个空闲的 worker。<br>&amp;emsp;&amp;emsp;3.被分配了 map 任务的 worker 程序读取相关的输入数据片段，从输入的数据片段中解析出 key&#x2F;value pair，然后把 key&#x2F;value pair 传递给用户自定义的 Map 函数，由 Map 函数生成并输出的中间 key&#x2F;value pair，并缓存在内存中。<br>&amp;emsp;&amp;emsp;4.缓存中的 key&#x2F;value pair 通过分区函数分成 R 个区域，之后周期性的写入到本地磁盘上。缓存的key&#x2F;value pair 在本地磁盘上的存储位置将被回传给 master，由 master 负责把这些存储位置再传送给Reduce worker。<br>&amp;emsp;&amp;emsp;5.当 Reduce worker 程序接收到 master 程序发来的数据存储位置信息后，使用 RPC 从 Map worker 所在主机的磁盘上读取这些缓存数据。当 Reduce worker 读取了所有的中间数据后，通过对 key 进行排序后使得具有相同 key 值的数据聚合在一起。由于许多不同的 key 值会映射到相同的 Reduce 任务上，因此必须进行排序。如果中间数据太大无法在内存中完成排序，那么就要在外部进行排序。<br>&amp;emsp;&amp;emsp;6.Reduce worker 程序遍历排序后的中间数据，对于每一个唯一的中间 key 值，Reduce worker 程序将这个 key 值和它相关的中间 value 值的集合传递给用户自定义的 Reduce 函数。Reduce 函数的输出被追加到所属分区的输出文件。<br>&amp;emsp;&amp;emsp;7.当所有的 Map 和 Reduce 任务都完成之后，master 唤醒用户程序。在这个时候，在用户程序里的对MapReduce 调用才返回。</p><p>&amp;emsp;&amp;emsp;在成功完成任务之后，MapReduce 的输出存放在 R 个输出文件中（对应每个 Reduce 任务产生一个输出文件，文件名由用户指定）。一般情况下，用户不需要将这 R 个输出文件合并成一个文件–他们经常把这些文件作为另外一个 MapReduce 的输入，或者在另外一个可以处理多个分割文件的分布式应用中使用。</p><p>###3.2 Master数据结构<br>&amp;emsp;&amp;emsp;Master 持有一些数据结构，它存储每一个 Map 和 Reduce 任务的状态（空闲、工作中或完成)，以及 Worker机器(非空闲任务的机器)的标识。<br>&amp;emsp;&amp;emsp;Master 就像一个数据管道，中间文件存储区域的位置信息通过这个管道从 Map 传递到 Reduce。因此，对于每个已经完成的 Map 任务，master 存储了 Map 任务产生的 R 个中间文件存储区域的大小和位置。当 Map任务完成时，Master 接收到位置和大小的更新信息，这些信息被逐步递增的推送给那些正在工作的 Reduce 任务。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h2 id=&quot;一、介绍&quot;&gt;&lt;a href=&quot;#一、介绍&quot; class=&quot;headerlink&quot; title=&quot;一、介绍&quot;&gt;&lt;/a&gt;一、介绍&lt;/h2&gt;&lt;p&gt;&amp;amp;emsp;&amp;amp;emsp;MapReduce是一个编程模型，也是一个处理
      
    
    </summary>
    
    
      <category term="MIT 6.824" scheme="http://yoursite.com/categories/MIT-6-824/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2022/04/12/hexo%20d%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E6%8A%A5%E9%94%99/"/>
    <id>http://yoursite.com/2022/04/12/hexo%20d%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E6%8A%A5%E9%94%99/</id>
    <published>2022-04-11T16:41:15.151Z</published>
    <updated>2022-04-11T16:41:15.151Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>SerialVersionUid的作用</title>
    <link href="http://yoursite.com/2021/01/26/SerialVersionUid%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8/"/>
    <id>http://yoursite.com/2021/01/26/SerialVersionUid%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8/</id>
    <published>2021-01-26T14:00:00.000Z</published>
    <updated>2022-04-10T16:35:10.717Z</updated>
    
    <content type="html"><![CDATA[<p>序列化运行时与每个可序列化的类关联一个版本号，称为<code>serialVersionUID</code>，在反序列化期间使用该版本号来验证序列化对象的发送者和接收者是否已加载了该对象的与序列化兼容的类。如果接收者为对象加载的类<code>serialVersionUID</code>与相应的发送者的类不同，则反序列化将导致 <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/InvalidClassException.html"><code>InvalidClassException</code></a>。可序列化的类可以<code>serialVersionUID</code>通过声明一个<code>serialVersionUID</code>必须为static，final和type 的字段来显式声明其自身<code>long</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANY-ACCESS-MODIFIER <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">42L</span>;</span><br></pre></td></tr></table></figure><p>如果可序列化的类未显式声明a <code>serialVersionUID</code>，则序列化运行时将根据<code>serialVersionUID</code>该类的各个方面为该类计算默认值，如Java™对象序列化规范中所述。但是，<em>强烈建议</em>所有可序列化的类显式声明<code>serialVersionUID</code>值，因为默认的情况下<code>serialVersionUID</code>计算对类详细信息高度敏感，而类详细信息可能会根据编译器的实现而有所不同，因此可能导致<code>InvalidClassExceptions</code>反序列化期间发生意外情况。因此，为了保证<code>serialVersionUID</code>不同Java编译器实现之间的值一致，可序列化的类必须声明一个显式<code>serialVersionUID</code>值。还强烈建议明确<code>serialVersionUID</code>声明尽可能使用private修饰符，因为此类声明仅适用于立即声明的类<code>serialVersionUID</code>字段，不能用作继承成员。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;序列化运行时与每个可序列化的类关联一个版本号，称为&lt;code&gt;serialVersionUID&lt;/code&gt;，在反序列化期间使用该版本号来验证序列化对象的发送者和接收者是否已加载了该对象的与序列化兼容的类。如果接收者为对象加载的类&lt;code&gt;serialVersionUID
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL中自增主键的好处</title>
    <link href="http://yoursite.com/2021/01/26/mysql%E4%B8%AD%E4%BD%BF%E7%94%A8uuid%E7%9A%84%E5%A5%BD%E5%A4%84/"/>
    <id>http://yoursite.com/2021/01/26/mysql%E4%B8%AD%E4%BD%BF%E7%94%A8uuid%E7%9A%84%E5%A5%BD%E5%A4%84/</id>
    <published>2021-01-26T14:00:00.000Z</published>
    <updated>2022-04-10T16:34:24.377Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UUID-好处-以及-自增主键-的优缺点"><a href="#UUID-好处-以及-自增主键-的优缺点" class="headerlink" title="UUID 好处 以及 自增主键 的优缺点"></a>UUID 好处 以及 自增主键 的优缺点</h1><p>自增主键<br>自增ID是在设计表时将id字段的值设置为自增的形式，这样当插入一行数据时无需指定id会自动根据前一字段的ID值+1进行填充。在<a href="https://www.yisu.com/mysql/">MySQL</a>数据库中，可通过sql语句AUTO_INCREMENT来对特定的字段启用自增赋值 使用自增ID作为主键，能够保证字段的原子性.</p><p>优点</p><p>数据库自动编号，速度快，而且是增量增长，按顺序存放，对于检索非常有利；<br>数字型，占用空间小，易排序，在程序中传递也方便；<br>如果通过非系统增加记录时，可以不用指定该字段，不用担心主键重复问题。<br>缺点</p><p>因为自动增长，在手动要插入指定ID的记录时会显得麻烦，尤其是当系统与其它系统集成时，需要数据导入时，很难保证原系统的ID不发生主键冲突（前提是老系统也是数字型的）。特别是在新系统上线时，新旧系统并行存在，并且是异库异构的数据库的情况下，需要双向同步时，自增主键将是你的噩梦；<br>在系统集成或割接时，如果新旧系统主键不同是数字型就会导致修改主键数据类型，这也会导致其它有外键关联的表的修改，后果同样很严重；<br>若系统也是数字型的，在导入时，为了区分新老数据，可能想在老数据主键前统一加一个字符标识（例如“o”，old）来表示这是老数据，那么自动增长的数字型又面临一个挑战。<br>UUID<br>UUID含义是通用唯一识别码 (Universally Unique Identifier)uuid 项目应用 <a href="http://www.1b23.com,指在一台机器上生成的数字,它保证对在同一时空中的所有机器都是唯一的.通常平台会提供生成的api.换句话说能够在一定的范围内保证主键id的唯一性./">www.1b23.com，指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。通常平台会提供生成的API。换句话说能够在一定的范围内保证主键id的唯一性。</a></p><p>优点</p><p>出现数据拆分、合并存储的时候，能达到全局的唯一性</p><p>缺点</p><p>影响插入速度， 并且造成硬盘使用率低<br>uuid之间比较大小相对数字慢不少， 影响查询速度。<br>uuid占空间大， 如果你建的索引越多， 影响越严重</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;UUID-好处-以及-自增主键-的优缺点&quot;&gt;&lt;a href=&quot;#UUID-好处-以及-自增主键-的优缺点&quot; class=&quot;headerlink&quot; title=&quot;UUID 好处 以及 自增主键 的优缺点&quot;&gt;&lt;/a&gt;UUID 好处 以及 自增主键 的优缺点&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>使用SuperVisor管理进程</title>
    <link href="http://yoursite.com/2021/01/26/%E4%BD%BF%E7%94%A8supervisorctl%E7%AE%A1%E7%90%86%E8%BF%9B%E7%A8%8B/"/>
    <id>http://yoursite.com/2021/01/26/%E4%BD%BF%E7%94%A8supervisorctl%E7%AE%A1%E7%90%86%E8%BF%9B%E7%A8%8B/</id>
    <published>2021-01-26T14:00:00.000Z</published>
    <updated>2022-05-04T08:00:07.288Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>Supervisor (<a href="http://supervisord.org/">http://supervisord.org</a>) 是一个用 Python 写的进程管理工具，可以很方便的用来启动、重启、关闭进程（不仅仅是 Python 进程）。除了对单个进程的控制，还可以同时启动、关闭多个进程，比如很不幸的服务器出问题导致所有应用程序都被杀死，此时可以用 supervisor 同时启动所有应用程序而不是一个一个地敲命令启动。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Supervisor 可以运行在 Linux、Mac OS X 上。如前所述，supervisor 是 Python 编写的，所以安装起来也很方便，可以直接用 pip :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install supervisor</span><br></pre></td></tr></table></figure><p>如果是 Ubuntu 系统，还可以使用 apt-get 安装。</p><h2 id="supervisord-配置"><a href="#supervisord-配置" class="headerlink" title="supervisord 配置"></a>supervisord 配置</h2><p>Supervisor 相当强大，提供了很丰富的功能，不过我们可能只需要用到其中一小部分。安装完成之后，可以编写配置文件，来满足自己的需求。为了方便，我们把配置分成两部分：supervisord（supervisor 是一个 C&#x2F;S 模型的程序，这是 server 端，对应的有 client 端：supervisorctl）和应用程序（即我们要管理的程序）。</p><p>首先来看 supervisord 的配置文件。安装完 supervisor 之后，可以运行<code>echo_supervisord_conf</code> 命令输出默认的配置项，也可以重定向到一个配置文件里：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo_supervisord_conf &gt; /etc/supervisord.conf</span><br></pre></td></tr></table></figure><p>去除里面大部分注释和“不相关”的部分，我们可以先看这些配置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[unix_http_server]</span></span><br><span class="line"><span class="attr">file</span>=/tmp/supervisor.sock   <span class="comment">; UNIX socket 文件，supervisorctl 会使用</span></span><br><span class="line"><span class="comment">;chmod=0700                 ; socket 文件的 mode，默认是 0700</span></span><br><span class="line"><span class="comment">;chown=nobody:nogroup       ; socket 文件的 owner，格式： uid:gid</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;[inet_http_server]         ; HTTP 服务器，提供 web 管理界面</span></span><br><span class="line"><span class="comment">;port=127.0.0.1:9001        ; Web 管理后台运行的 IP 和端口，如果开放到公网，需要注意安全性</span></span><br><span class="line"><span class="comment">;username=user              ; 登录管理后台的用户名</span></span><br><span class="line"><span class="comment">;password=123               ; 登录管理后台的密码</span></span><br><span class="line"></span><br><span class="line"><span class="section">[supervisord]</span></span><br><span class="line"><span class="attr">logfile</span>=/tmp/supervisord.log <span class="comment">; 日志文件，默认是 $CWD/supervisord.log</span></span><br><span class="line"><span class="attr">logfile_maxbytes</span>=<span class="number">50</span>MB        <span class="comment">; 日志文件大小，超出会 rotate，默认 50MB</span></span><br><span class="line"><span class="attr">logfile_backups</span>=<span class="number">10</span>           <span class="comment">; 日志文件保留备份数量默认 10</span></span><br><span class="line"><span class="attr">loglevel</span>=info                <span class="comment">; 日志级别，默认 info，其它: debug,warn,trace</span></span><br><span class="line"><span class="attr">pidfile</span>=/tmp/supervisord.pid <span class="comment">; pid 文件</span></span><br><span class="line"><span class="attr">nodaemon</span>=<span class="literal">false</span>               <span class="comment">; 是否在前台启动，默认是 false，即以 daemon 的方式启动</span></span><br><span class="line"><span class="attr">minfds</span>=<span class="number">1024</span>                  <span class="comment">; 可以打开的文件描述符的最小值，默认 1024</span></span><br><span class="line"><span class="attr">minprocs</span>=<span class="number">200</span>                 <span class="comment">; 可以打开的进程数的最小值，默认 200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; the below section must remain in the config file for RPC</span></span><br><span class="line"><span class="comment">; (supervisorctl/web interface) to work, additional interfaces may be</span></span><br><span class="line"><span class="comment">; added by defining them in separate rpcinterface: sections</span></span><br><span class="line"><span class="section">[rpcinterface:supervisor]</span></span><br><span class="line"><span class="attr">supervisor.rpcinterface_factory</span> = supervisor.rpcinterface:make_main_rpcinterface</span><br><span class="line"></span><br><span class="line"><span class="section">[supervisorctl]</span></span><br><span class="line"><span class="attr">serverurl</span>=unix:///tmp/supervisor.sock <span class="comment">; 通过 UNIX socket 连接 supervisord，路径与 unix_http_server 部分的 file 一致</span></span><br><span class="line"><span class="comment">;serverurl=http://127.0.0.1:9001 ; 通过 HTTP 的方式连接 supervisord</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 包含其他的配置文件</span></span><br><span class="line"><span class="section">[include]</span></span><br><span class="line"><span class="attr">files</span> = relative/directory/*.ini    <span class="comment">; 可以是 *.conf 或 *.ini</span></span><br></pre></td></tr></table></figure><p>我们把上面这部分配置保存到 &#x2F;etc&#x2F;supervisord.conf（或其他任意有权限访问的文件），然后启动 supervisord（通过 -c 选项指定配置文件路径，如果不指定会按照这个顺序查找配置文件：$CWD&#x2F;supervisord.conf, $CWD&#x2F;etc&#x2F;supervisord.conf, &#x2F;etc&#x2F;supervisord.conf）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisord -c /etc/supervisord.conf</span><br></pre></td></tr></table></figure><p>查看 supervisord 是否在运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep supervisord</span><br></pre></td></tr></table></figure><h2 id="program-配置"><a href="#program-配置" class="headerlink" title="program 配置"></a>program 配置</h2><p>上面我们已经把 supervisrod 运行起来了，现在可以添加我们要管理的进程的配置文件。这些配置可以都写到 supervisord.conf 文件里，如果应用程序很多，最好通过 include 的方式把不同的程序（组）写到不同的配置文件里。</p><p>为了举例，我们新建一个目录 &#x2F;etc&#x2F;supervisor&#x2F; 用于存放这些配置文件，相应的，把 &#x2F;etc&#x2F;supervisord.conf 里 include 部分的的配置修改一下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">include</span>]</span><br><span class="line">files = <span class="regexp">/etc/</span>supervisor<span class="comment">/*.conf</span></span><br></pre></td></tr></table></figure><p>假设有个用 Flask 开发的用户系统 usercenter, 生产环境使用 gunicorn 运行。项目代码位于 <code>/home/leon/projects/usercenter</code>，WSGI 对象位于 wsgi.py。在命令行启动的方式是这样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/leon/projects/usercenter</span><br><span class="line">gunicorn -w 8 -b 0.0.0.0:17510 wsgi:app</span><br></pre></td></tr></table></figure><p>对应的配置文件可能是：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[program:usercenter]</span></span><br><span class="line"><span class="attr">directory</span> = /home/leon/projects/usercenter <span class="comment">; 程序的启动目录</span></span><br><span class="line"><span class="attr">command</span> = gunicorn -w <span class="number">8</span> -b <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">17510</span> wsgi:app  <span class="comment">; 启动命令</span></span><br><span class="line"><span class="attr">autostart</span> = <span class="literal">true</span>     <span class="comment">; 在 supervisord 启动的时候也自动启动</span></span><br><span class="line"><span class="attr">startsecs</span> = <span class="number">5</span>        <span class="comment">; 启动 5 秒后没有异常退出，就当作已经正常启动了</span></span><br><span class="line"><span class="attr">autorestart</span> = <span class="literal">true</span>   <span class="comment">; 程序异常退出后自动重启</span></span><br><span class="line"><span class="attr">startretries</span> = <span class="number">3</span>     <span class="comment">; 启动失败自动重试次数，默认是 3</span></span><br><span class="line"><span class="attr">user</span> = leon          <span class="comment">; 用哪个用户启动</span></span><br><span class="line"><span class="attr">redirect_stderr</span> = <span class="literal">true</span>  <span class="comment">; 把 stderr 重定向到 stdout，默认 false</span></span><br><span class="line"><span class="attr">stdout_logfile_maxbytes</span> = <span class="number">20</span>MB  <span class="comment">; stdout 日志文件大小，默认 50MB</span></span><br><span class="line"><span class="attr">stdout_logfile_backups</span> = <span class="number">20</span>     <span class="comment">; stdout 日志文件备份数</span></span><br><span class="line"><span class="comment">; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）</span></span><br><span class="line"><span class="attr">stdout_logfile</span> = /data/logs/usercenter_stdout.log</span><br></pre></td></tr></table></figure><p>其中 <code>[program:usercenter]</code> 中的 <code>usercenter</code> 是应用程序的唯一标识，不能重复。对该程序的所有操作（start, restart 等）都通过名字来实现。</p><h3 id="Tips-1-Python-环境"><a href="#Tips-1-Python-环境" class="headerlink" title="Tips 1: Python 环境"></a>Tips 1: Python 环境</h3><p>有两种方式指定程序使用的 Python 环境：</p><ol><li><code>command</code> 使用绝对路径。假设使用 pyenv 来管理 Python 环境，上面例子中的 gunicorn 路径可以替换为 <code>/home/leon/.pyenv/versions/usercenter/bin/gunicorn</code>. 这种方式一目了然，推荐。</li><li>通过 <code>environment</code> 配置 <code>PYTHONPATH</code>. <code>environment=PYTHONPATH=$PYTHONPATH:/home/leon/.pyenv/versions/usercenter/bin/</code>. <code>environment</code> 这个配置项非常有用，可以用来给程序传入环境变量。</li></ol><h3 id="Tips-2-后台进程"><a href="#Tips-2-后台进程" class="headerlink" title="Tips 2: 后台进程"></a>Tips 2: 后台进程</h3><p>Supervisor 只能管理在前台运行的程序，所以如果应用程序有后台运行的选项，需要关闭。</p><h3 id="Tips-3-子进程"><a href="#Tips-3-子进程" class="headerlink" title="Tips 3: 子进程"></a>Tips 3: 子进程</h3><p>有时候用 Supervisor 托管的程序还会有子进程（如 Tornado），如果只杀死主进程，子进程就可能变成孤儿进程。通过这两项配置来确保所有子进程都能正确停止：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stopasgroup</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">killasgroup</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="使用-supervisorctl"><a href="#使用-supervisorctl" class="headerlink" title="使用 supervisorctl"></a>使用 supervisorctl</h2><p>Supervisorctl 是 supervisord 的一个命令行客户端工具，启动时需要指定与 supervisord 使用同一份配置文件，否则与 supervisord 一样按照顺序查找配置文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl -c /etc/supervisord.conf</span><br></pre></td></tr></table></figure><p>上面这个命令会进入 supervisorctl 的 shell 界面，然后可以执行不同的命令了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; status    <span class="comment"># 查看程序状态</span></span><br><span class="line">&gt; stop usercenter   <span class="comment"># 关闭 usercenter 程序</span></span><br><span class="line">&gt; start usercenter  <span class="comment"># 启动 usercenter 程序</span></span><br><span class="line">&gt; restart usercenter    <span class="comment"># 重启 usercenter 程序</span></span><br><span class="line">&gt; reread    ＃ 读取有更新（增加）的配置文件，不会启动新添加的程序</span><br><span class="line">&gt; update    ＃ 重启配置文件修改过的程序</span><br></pre></td></tr></table></figure><p>上面这些命令都有相应的输出，除了进入 supervisorctl 的 shell 界面，也可以直接在 bash 终端运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ supervisorctl status</span><br><span class="line">$ supervisorctl stop usercenter</span><br><span class="line">$ supervisorctl start usercenter</span><br><span class="line">$ supervisorctl restart usercenter</span><br><span class="line">$ supervisorctl reread</span><br><span class="line">$ supervisorctl update</span><br></pre></td></tr></table></figure><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>除了 supervisorctl 之外，还可以配置 supervisrod 启动 web 管理界面，这个 web 后台使用 Basic Auth 的方式进行身份认证。</p><p>除了单个进程的控制，还可以配置 group，进行分组管理。</p><p>经常查看日志文件，包括 supervisord 的日志和各个 pragram 的日志文件，程序 crash 或抛出异常的信息一半会输出到 stderr，可以查看相应的日志文件来查找问题。</p><p>Supervisor 有很丰富的功能，还有其他很多项配置，可以在官方文档获取更多信息：<a href="http://supervisord.org/index.html">http://supervisord.org/index.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;Supervisor (&lt;a href=&quot;http://supervisord.org/&quot;&gt;http://supervisord.org&lt;/a&gt;) 是一个用 Python 写的进程管理工具，可以很方便的用来启动、重启、关闭进程（不仅仅是
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>java序列化机制</title>
    <link href="http://yoursite.com/2021/01/26/java%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2021/01/26/java%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6/</id>
    <published>2021-01-26T14:00:00.000Z</published>
    <updated>2022-04-10T16:32:27.737Z</updated>
    
    <content type="html"><![CDATA[<p><a href="#h">一、序列化的含义、意义及使用场景</a><a href="#h-1">二、序列化实现的方式</a><a href="#h1serializable">1、Serializable</a><a href="#h11">1.1 普通序列化</a><a href="#h12">1.2 成员是引用的序列化</a><a href="#h13">1.3 同一对象序列化多次的机制</a><a href="#h14java">1.4 java序列化算法潜在的问题</a><a href="#h15">1.5 可选的自定义序列化</a><a href="#h2externalizable">2、Externalizable：强制自定义序列化</a><a href="#h3">3、两种序列化对比</a><a href="#hserialversionuid">三、序列化版本号serialVersionUID</a><a href="#h-2">四、总结</a></p><h3 id="一、序列化的含义、意义及使用场景"><a href="#一、序列化的含义、意义及使用场景" class="headerlink" title="一、序列化的含义、意义及使用场景"></a>一、序列化的含义、意义及使用场景</h3><ul><li><strong>序列化：将对象写入到IO流中</strong></li><li><strong>反序列化：从IO流中恢复对象</strong></li><li><strong>意义：序列化机制允许将实现序列化的Java对象转换位字节序列，这些字节序列可以保存在磁盘上，或通过网络传输，以达到以后恢复成原来的对象。序列化机制使得对象可以脱离程序的运行而独立存在。</strong></li><li><strong>使用场景：所有可在网络上传输的对象都必须是可序列化的，</strong>比如RMI（remote method invoke,即远程方法调用），传入的参数或返回的对象都是可序列化的，否则会出错；<strong>所有需要保存到磁盘的java对象都必须是可序列化的。通常建议：程序创建的每个JavaBean类都实现Serializeable接口。</strong></li></ul><h3 id="二、序列化实现的方式"><a href="#二、序列化实现的方式" class="headerlink" title="二、序列化实现的方式"></a>二、序列化实现的方式</h3><p>如果需要将某个对象保存到磁盘上或者通过网络传输，那么这个类应该实现<strong>Serializable</strong>接口或者<strong>Externalizable</strong>接口之一。</p><h4 id="1、Serializable"><a href="#1、Serializable" class="headerlink" title="1、Serializable"></a>1、Serializable</h4><h5 id="1-1-普通序列化"><a href="#1-1-普通序列化" class="headerlink" title="1.1 普通序列化"></a>1.1 普通序列化</h5><p>Serializable接口是一个标记接口，不用实现任何方法。一旦实现了此接口，该类的对象就是可序列化的。</p><ol><li><strong>序列化步骤：</strong></li></ol><ul><li><p><strong>步骤一：创建一个ObjectOutputStream输出流；</strong></p></li><li><p><strong>步骤二：调用ObjectOutputStream对象的writeObject输出可序列化对象。</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="title">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">String</span> name;</span><br><span class="line">  <span class="keyword">private</span> int age;</span><br><span class="line">  <span class="comment">//我不提供无参构造器</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">Person</span>(<span class="params"><span class="built_in">String</span> name, int age</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">      <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">String</span> <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">              <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">              <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">              <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteObject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> (<span class="comment">//创建一个ObjectOutputStream输出流</span></span><br><span class="line">           ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;object.txt&quot;</span>))) &#123;</span><br><span class="line">          <span class="comment">//将对象序列化到文件s</span></span><br><span class="line">          Person person = <span class="keyword">new</span> Person(<span class="string">&quot;9龙&quot;</span>, <span class="number">23</span>);</span><br><span class="line">          oos.writeObject(person);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li></ul><ol><li><strong>反序列化步骤：</strong></li></ol><ul><li><p><strong>步骤一：创建一个ObjectInputStream输入流；</strong></p></li><li><p><strong>步骤二：调用ObjectInputStream对象的readObject()得到序列化的对象。</strong></p><p>我们将上面序列化到person.txt的person对象反序列化回来</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="title">implements</span> <span class="title">Serializable</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">String</span> name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  <span class="comment">//我不提供无参构造器</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">String</span> name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">      System.out.<span class="built_in">println</span>(<span class="string">&quot;反序列化，你调用我了吗？&quot;</span>);</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">              <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">              <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">              <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadObject</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">      <span class="built_in"><span class="keyword">try</span></span> (<span class="comment">//创建一个ObjectInputStream输入流</span></span><br><span class="line">           ObjectInputStream ois = <span class="keyword">new</span> <span class="built_in">ObjectInputStream</span>(<span class="keyword">new</span> <span class="built_in">FileInputStream</span>(<span class="string">&quot;person.txt&quot;</span>))) &#123;</span><br><span class="line">          Person brady = (Person) ois.<span class="built_in">readObject</span>();</span><br><span class="line">          System.out.<span class="built_in">println</span>(brady);</span><br><span class="line">      &#125; <span class="built_in"><span class="keyword">catch</span></span> (Exception e) &#123;</span><br><span class="line">          e.<span class="built_in">printStackTrace</span>();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//Person&#123;name=&#x27;9龙&#x27;, age=23&#125;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>waht????    输出告诉我们，反序列化并不会调用构造方法。反序列的对象是由JVM自己生成的对象，不通过构造方法生成。</strong></p></li></ul><h5 id="1-2-成员是引用的序列化"><a href="#1-2-成员是引用的序列化" class="headerlink" title="1.2 成员是引用的序列化"></a>1.2 成员是引用的序列化</h5><p><strong>如果一个可序列化的类的成员不是基本类型，也不是String类型，那这个引用类型也必须是可序列化的；否则，会导致此类不能序列化。</strong></p><p>看例子，我们新增一个Teacher类。将Person去掉实现Serializable接口代码。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//省略相关属性与方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Serializable</span></span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> name;</span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Teacher(<span class="keyword">String</span> name, Person person) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.person = person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) throws Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> <span class="type">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="type">FileOutputStream</span>(<span class="string">&quot;teacher.txt&quot;</span>))) &#123;</span><br><span class="line">            Person person = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">&quot;路飞&quot;</span>, <span class="number">20</span>);</span><br><span class="line">            Teacher teacher = <span class="keyword">new</span> <span class="type">Teacher</span>(<span class="string">&quot;雷利&quot;</span>, person);</span><br><span class="line">            oos.writeObject(teacher);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2019/5/21/16ad9dbc177d9abb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>我们看到程序直接报错，因为Person类的对象是不可序列化的，这导致了Teacher的对象不可序列化</p><h5 id="1-3-同一对象序列化多次的机制"><a href="#1-3-同一对象序列化多次的机制" class="headerlink" title="1.3 同一对象序列化多次的机制"></a>1.3 同一对象序列化多次的机制</h5><p><strong>同一对象序列化多次，会将这个对象序列化多次吗？</strong>答案是<strong>否定</strong>的。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> WriteTeacher &#123;</span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) throws Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> <span class="constructor">ObjectOutputStream(<span class="params">new</span> FileOutputStream(<span class="string">&quot;teacher.txt&quot;</span>)</span>)) &#123;</span><br><span class="line">            Person person = <span class="keyword">new</span> <span class="constructor">Person(<span class="string">&quot;路飞&quot;</span>, 20)</span>;</span><br><span class="line">            Teacher t1 = <span class="keyword">new</span> <span class="constructor">Teacher(<span class="string">&quot;雷利&quot;</span>, <span class="params">person</span>)</span>;</span><br><span class="line">            Teacher t2 = <span class="keyword">new</span> <span class="constructor">Teacher(<span class="string">&quot;红发香克斯&quot;</span>, <span class="params">person</span>)</span>;</span><br><span class="line">            <span class="comment">//依次将4个对象写入输入流</span></span><br><span class="line">            oos.write<span class="constructor">Object(<span class="params">t1</span>)</span>;</span><br><span class="line">            oos.write<span class="constructor">Object(<span class="params">t2</span>)</span>;</span><br><span class="line">            oos.write<span class="constructor">Object(<span class="params">person</span>)</span>;</span><br><span class="line">            oos.write<span class="constructor">Object(<span class="params">t2</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>依次将t1、t2、person、t2对象序列化到文件teacher.txt文件中。</p><p><strong>注意：反序列化的顺序与序列化时的顺序一致</strong>。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> ReadTeacher &#123;</span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">        <span class="keyword">try</span> (ObjectInputStream ois = <span class="keyword">new</span> <span class="constructor">ObjectInputStream(<span class="params">new</span> FileInputStream(<span class="string">&quot;teacher.txt&quot;</span>)</span>)) &#123;</span><br><span class="line">            Teacher t1 = (Teacher) ois.read<span class="constructor">Object()</span>;</span><br><span class="line">            Teacher t2 = (Teacher) ois.read<span class="constructor">Object()</span>;</span><br><span class="line">            Person p = (Person) ois.read<span class="constructor">Object()</span>;</span><br><span class="line">            Teacher t3 = (Teacher) ois.read<span class="constructor">Object()</span>;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(t1<span class="operator"> == </span>t2);</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(t1.get<span class="constructor">Person()</span><span class="operator"> == </span>p);</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(t2.get<span class="constructor">Person()</span><span class="operator"> == </span>p);</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(t2<span class="operator"> == </span>t3);</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(t1.get<span class="constructor">Person()</span><span class="operator"> == </span>t2.get<span class="constructor">Person()</span>);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//false</span></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>从输出结果可以看出，<strong>Java序列化同一对象，并不会将此对象序列化多次得到多个对象。</strong></p><ul><li><strong>Java序列化算法</strong></li></ul><ol><li><p><strong>所有保存到磁盘的对象都有一个序列化编码号</strong></p></li><li><p><strong>当程序试图序列化一个对象时，会先检查此对象是否已经序列化过，只有此对象从未（在此虚拟机）被序列化过，才会将此对象序列化为字节序列输出。</strong></p></li><li><p><strong>如果此对象已经序列化过，则直接输出编号即可。</strong></p><p>图示上述序列化过程。</p></li></ol><p><img src="https://user-gold-cdn.xitu.io/2019/5/21/16ad9dbc1863188b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h5 id="1-4-java序列化算法潜在的问题"><a href="#1-4-java序列化算法潜在的问题" class="headerlink" title="1.4 java序列化算法潜在的问题"></a>1.4 java序列化算法潜在的问题</h5><p>由于java序利化算法不会重复序列化同一个对象，只会记录已序列化对象的编号。<strong>如果序列化一个可变对象（对象内的内容可更改）后，更改了对象内容，再次序列化，并不会再次将此对象转换为字节序列，而只是保存序列化编号。</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> WriteObject &#123;</span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">        <span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> <span class="constructor">ObjectOutputStream(<span class="params">new</span> FileOutputStream(<span class="string">&quot;person.txt&quot;</span>)</span>);</span><br><span class="line">             ObjectInputStream ios = <span class="keyword">new</span> <span class="constructor">ObjectInputStream(<span class="params">new</span> FileInputStream(<span class="string">&quot;person.txt&quot;</span>)</span>)) &#123;</span><br><span class="line">            <span class="comment">//第一次序列化person</span></span><br><span class="line">            Person person = <span class="keyword">new</span> <span class="constructor">Person(<span class="string">&quot;9龙&quot;</span>, 23)</span>;</span><br><span class="line">            oos.write<span class="constructor">Object(<span class="params">person</span>)</span>;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(person);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//修改name</span></span><br><span class="line">            person.set<span class="constructor">Name(<span class="string">&quot;海贼王&quot;</span>)</span>;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(person);</span><br><span class="line">            <span class="comment">//第二次序列化person</span></span><br><span class="line">            oos.write<span class="constructor">Object(<span class="params">person</span>)</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//依次反序列化出p1、p2</span></span><br><span class="line">            Person p1 = (Person) ios.read<span class="constructor">Object()</span>;</span><br><span class="line">            Person p2 = (Person) ios.read<span class="constructor">Object()</span>;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(p1<span class="operator"> == </span>p2);</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(p1.get<span class="constructor">Name()</span>.equals(p2.get<span class="constructor">Name()</span>));</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//Person&#123;name=&#x27;9龙&#x27;, age=23&#125;</span></span><br><span class="line"><span class="comment">//Person&#123;name=&#x27;海贼王&#x27;, age=23&#125;</span></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h5 id="1-5-可选的自定义序列化"><a href="#1-5-可选的自定义序列化" class="headerlink" title="1.5 可选的自定义序列化"></a>1.5 可选的自定义序列化</h5><ol><li><p>有些时候，我们有这样的需求，某些属性不需要序列化。<strong>使用transient关键字选择不需要序列化的字段。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">   <span class="comment">//不需要序列化名字与年龄</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> age;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> height;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">boolean</span> singlehood;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.name = name;</span><br><span class="line">       <span class="keyword">this</span>.age = age;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//省略get,set方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransientTest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;person.txt&quot;</span>));</span><br><span class="line">            ObjectInputStream ios = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;person.txt&quot;</span>))) &#123;</span><br><span class="line">           Person person = <span class="keyword">new</span> Person(<span class="string">&quot;9龙&quot;</span>, <span class="number">23</span>);</span><br><span class="line">           person.setHeight(<span class="number">185</span>);</span><br><span class="line">           System.out.println(person);</span><br><span class="line">           oos.writeObject(person);</span><br><span class="line">           Person p1 = (Person)ios.readObject();</span><br><span class="line">           System.out.println(p1);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//Person&#123;name=&#x27;9龙&#x27;, age=23&#x27;, singlehood=true&#x27;, height=185cm&#125;</span></span><br><span class="line"><span class="comment">//Person&#123;name=&#x27;null&#x27;, age=0&#x27;, singlehood=false&#x27;, height=185cm&#125;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>从输出我们看到，<strong>使用transient修饰的属性，java序列化时，会忽略掉此字段，所以反序列化出的对象，被transient修饰的属性是默认值。对于引用类型，值是null；基本类型，值是0；boolean类型，值是false。</strong></p></li><li><p>使用transient虽然简单，但将此属性完全隔离在了序列化之外。java提供了<strong>可选的自定义序列化。</strong>可以进行控制序列化的方式，或者对序列化数据进行编码加密等。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> void write<span class="constructor">Object(<span class="params">java</span>.<span class="params">io</span>.ObjectOutputStream <span class="params">out</span>)</span> throws IOException；</span><br><span class="line"><span class="keyword">private</span> void read<span class="constructor">Object(<span class="params">java</span>.<span class="params">io</span>.ObjectIutputStream <span class="params">in</span>)</span> throws IOException,ClassNotFoundException;</span><br><span class="line"><span class="keyword">private</span> void read<span class="constructor">ObjectNoData()</span> throws ObjectStreamException;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>通过重写writeObject与readObject方法，可以自己选择哪些属性需要序列化， 哪些属性不需要。如果writeObject使用某种规则序列化，则相应的readObject需要相反的规则反序列化，以便能正确反序列化出对象。这里展示对名字进行反转加密。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> Person implements Serializable &#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line">   <span class="comment">//省略构造方法，get及set方法</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> void write<span class="constructor">Object(ObjectOutputStream <span class="params">out</span>)</span> throws IOException &#123;</span><br><span class="line">       <span class="comment">//将名字反转写入二进制流</span></span><br><span class="line">       out.write<span class="constructor">Object(<span class="params">new</span> StringBuffer(<span class="params">this</span>.<span class="params">name</span>)</span>.reverse<span class="literal">()</span>);</span><br><span class="line">       out.write<span class="constructor">Int(<span class="params">age</span>)</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> void read<span class="constructor">Object(ObjectInputStream <span class="params">ins</span>)</span> throws IOException,ClassNotFoundException&#123;</span><br><span class="line">       <span class="comment">//将读出的字符串反转恢复回来</span></span><br><span class="line">       this.name = ((StringBuffer)ins.read<span class="constructor">Object()</span>).reverse<span class="literal">()</span>.<span class="keyword">to</span><span class="constructor">String()</span>;</span><br><span class="line">       this.age = ins.read<span class="constructor">Int()</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>当序列化流不完整时，readObjectNoData()方法可以用来正确地初始化反序列化的对象。例如，使用不同类接收反序列化对象，或者序列化流被篡改时，系统都会调用readObjectNoData()方法来初始化反序列化的对象。</p></li><li><p><strong>更彻底的自定义序列化</strong></p><p>ANY-ACCESS-MODIFIER Object writeReplace() throws ObjectStreamException;<br>  ANY-ACCESS-MODIFIER Object readResolve() throws ObjectStreamException;</p><ul><li><p><strong>writeReplace：在序列化时，会先调用此方法，再调用writeObject方法。此方法可将任意对象代替目标序列化对象</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Serializable</span></span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">String</span> name;</span><br><span class="line">  <span class="keyword">private</span> int age;</span><br><span class="line">  <span class="comment">//省略构造方法，get及set方法</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Object writeReplace() throws ObjectStreamException &#123;</span><br><span class="line">      ArrayList&lt;Object&gt; list = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">      list.add(<span class="built_in">this</span>.name);</span><br><span class="line">      list.add(<span class="built_in">this</span>.age);</span><br><span class="line">      <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) throws Exception &#123;</span><br><span class="line">      <span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> <span class="type">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="type">FileOutputStream</span>(<span class="string">&quot;person.txt&quot;</span>));</span><br><span class="line">           ObjectInputStream ios = <span class="keyword">new</span> <span class="type">ObjectInputStream</span>(<span class="keyword">new</span> <span class="type">FileInputStream</span>(<span class="string">&quot;person.txt&quot;</span>))) &#123;</span><br><span class="line">          Person person = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">&quot;9龙&quot;</span>, <span class="number">23</span>);</span><br><span class="line">          oos.writeObject(person);</span><br><span class="line">          ArrayList list = (ArrayList)ios.readObject();</span><br><span class="line">          System.out.println(list);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//[9龙, 23]</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li><li><p><strong>readResolve：反序列化时替换反序列化出的对象，反序列化出来的对象被立即丢弃。此方法在readeObject后调用。</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Serializable</span></span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> name;</span><br><span class="line">    <span class="keyword">private</span> int age;</span><br><span class="line">    <span class="comment">//省略构造方法，get及set方法</span></span><br><span class="line">     <span class="keyword">private</span> Object readResolve() throws ObjectStreamException&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type"></span>(<span class="string">&quot;brady&quot;</span>, <span class="number">23</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) throws Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> <span class="type">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="type">FileOutputStream</span>(<span class="string">&quot;person.txt&quot;</span>));</span><br><span class="line">             ObjectInputStream ios = <span class="keyword">new</span> <span class="type">ObjectInputStream</span>(<span class="keyword">new</span> <span class="type">FileInputStream</span>(<span class="string">&quot;person.txt&quot;</span>))) &#123;</span><br><span class="line">            Person person = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">&quot;9龙&quot;</span>, <span class="number">23</span>);</span><br><span class="line">            oos.writeObject(person);</span><br><span class="line">            HashMap map = (HashMap)ios.readObject();</span><br><span class="line">            System.out.println(map);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//&#123;brady=23&#125;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>readResolve常用来反序列单例类，保证单例类的唯一性。</strong></p><p><strong>注意：readResolve与writeReplace的访问修饰符可以是private、protected、public，如果父类重写了这两个方法，子类都需要根据自身需求重写，这显然不是一个好的设计。通常建议对于final修饰的类重写readResolve方法没有问题；否则，重写readResolve使用private修饰。</strong></p></li></ul></li></ol><h4 id="2、Externalizable：强制自定义序列化"><a href="#2、Externalizable：强制自定义序列化" class="headerlink" title="2、Externalizable：强制自定义序列化"></a>2、Externalizable：强制自定义序列化</h4><p>通过实现Externalizable接口，必须实现writeExternal、readExternal方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Externalizable</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExPerson</span> <span class="keyword">implements</span> <span class="title">Externalizable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//注意，必须加上pulic 无参构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExPerson</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//将name反转后写入二进制流</span></span><br><span class="line">        StringBuffer reverse = <span class="keyword">new</span> StringBuffer(name).reverse();</span><br><span class="line">        System.out.println(reverse.toString());</span><br><span class="line">        out.writeObject(reverse);</span><br><span class="line">        out.writeInt(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//将读取的字符串反转后赋值给name实例变量</span></span><br><span class="line">        <span class="keyword">this</span>.name = ((StringBuffer) in.readObject()).reverse().toString();</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="keyword">this</span>.age = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;ExPerson.txt&quot;</span>));</span><br><span class="line">             ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;ExPerson.txt&quot;</span>))) &#123;</span><br><span class="line">            oos.writeObject(<span class="keyword">new</span> ExPerson(<span class="string">&quot;brady&quot;</span>, <span class="number">23</span>));</span><br><span class="line">            ExPerson ep = (ExPerson) ois.readObject();</span><br><span class="line">            System.out.println(ep);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//ydarb</span></span><br><span class="line"><span class="comment">//brady</span></span><br><span class="line"><span class="comment">//ExPerson&#123;name=&#x27;brady&#x27;, age=23&#125;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>注意：Externalizable接口不同于Serializable接口，实现此接口必须实现接口中的两个方法实现自定义序列化，这是强制性的；特别之处是必须提供pulic的无参构造器，因为在反序列化的时候需要反射创建对象。</strong></p><h4 id="3、两种序列化对比"><a href="#3、两种序列化对比" class="headerlink" title="3、两种序列化对比"></a>3、两种序列化对比</h4><table><thead><tr><th>实现Serializable接口</th><th>实现Externalizable接口</th></tr></thead><tbody><tr><td>系统自动存储必要的信息</td><td>程序员决定存储哪些信息</td></tr><tr><td>Java内建支持，易于实现，只需要实现该接口即可，无需任何代码支持</td><td>必须实现接口内的两个方法</td></tr><tr><td>性能略差</td><td>性能略好</td></tr></tbody></table><p><strong>虽然Externalizable接口带来了一定的性能提升，但变成复杂度也提高了，所以一般通过实现Serializable接口进行序列化。</strong></p><h3 id="三、序列化版本号serialVersionUID"><a href="#三、序列化版本号serialVersionUID" class="headerlink" title="三、序列化版本号serialVersionUID"></a>三、序列化版本号serialVersionUID</h3><p>我们知道，<strong>反序列化必须拥有class文件，但随着项目的升级，class文件也会升级，序列化怎么保证升级前后的兼容性呢？</strong></p><p>java序列化提供了一个private static final long serialVersionUID 的序列化版本号，只有版本号相同，即使更改了序列化属性，对象也可以正确被反序列化回来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//序列化版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1111013L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//省略构造方法及get,set</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果反序列化使用的<strong>class的版本号</strong>与序列化时使用的<strong>不一致</strong>，反序列化会<strong>报InvalidClassException异常。</strong></p><p><img src="https://user-gold-cdn.xitu.io/2019/5/21/16ad9dbc2a4e3900?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><strong>序列化版本号可自由指定，如果不指定，JVM会根据类信息自己计算一个版本号，这样随着class的升级，就无法正确反序列化；不指定版本号另一个明显隐患是，不利于jvm间的移植，可能class文件没有更改，但不同jvm可能计算的规则不一样，这样也会导致无法反序列化。</strong></p><p>什么情况下需要修改serialVersionUID呢？分三种情况。</p><ul><li>如果只是修改了方法，反序列化不容影响，则无需修改版本号；</li><li>如果只是修改了静态变量，瞬态变量（transient修饰的变量），反序列化不受影响，无需修改版本号；</li><li>如果修改了非瞬态变量，则可能导致反序列化失败。<strong>如果新类中实例变量的类型与序列化时类的类型不一致，则会反序列化失败，这时候需要更改serialVersionUID。</strong>如果只是新增了实例变量，则反序列化回来新增的是默认值；如果减少了实例变量，反序列化时会忽略掉减少的实例变量。</li></ul><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><ol><li>所有需要网络传输的对象都需要实现序列化接口，通过建议所有的javaBean都实现Serializable接口。</li><li>对象的类名、实例变量（包括基本类型，数组，对其他对象的引用）都会被序列化；方法、类变量、transient实例变量都不会被序列化。</li><li>如果想让某个变量不被序列化，使用transient修饰。</li><li>序列化对象的引用类型成员变量，也必须是可序列化的，否则，会报错。</li><li>反序列化时必须有序列化对象的class文件。</li><li>当通过文件、网络来读取序列化后的对象时，必须按照实际写入的顺序读取。</li><li>单例类序列化，需要重写readResolve()方法；否则会破坏单例原则。</li><li>同一对象序列化多次，只有第一次序列化为二进制流，以后都只是保存序列化编号，不会重复序列化。</li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;#h&quot;&gt;一、序列化的含义、意义及使用场景&lt;/a&gt;&lt;a href=&quot;#h-1&quot;&gt;二、序列化实现的方式&lt;/a&gt;&lt;a href=&quot;#h1serializable&quot;&gt;1、Serializable&lt;/a&gt;&lt;a href=&quot;#h11&quot;&gt;1.1 普通序列化&lt;/a&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>MicroMeter的基础概念</title>
    <link href="http://yoursite.com/2021/01/26/MicroMeter%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2021/01/26/MicroMeter%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</id>
    <published>2021-01-26T14:00:00.000Z</published>
    <updated>2022-04-10T16:33:39.500Z</updated>
    
    <content type="html"><![CDATA[<h2 id="表格的语法"><a href="#表格的语法" class="headerlink" title="表格的语法"></a>表格的语法</h2><table><thead><tr><th>Tables</th><th align="center">Are</th><th align="right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td align="center">right-aligned</td><td align="right">$1600</td></tr><tr><td>col 2 is</td><td align="center">centered</td><td align="right">$12</td></tr><tr><td>zebra stripes</td><td align="center">are neat</td><td align="right">$1</td></tr></tbody></table><p>首行缩进两字符：&amp;emsp;&amp;emsp;</p><p>MicroMeter中指标的分类包括五种类型:timers, gauges, counters, <br>distribution summaries, and long task timers</p><h1 id="一、目的"><a href="#一、目的" class="headerlink" title="一、目的"></a>一、目的</h1><p>&amp;emsp;&amp;emsp;MicroMeter是针对基于JVM的应用程序的Metrics标准检测库。它为最流行的监视系统提供了一个基于可视化客户端的简单外观，使您无需供应商锁定即可对基于JVM的应用程序代码进行可视化。它旨在在最大限度地提高指标工作可移植性的同时，几乎不增加指标收集活动的开销。</p><hr><h1 id="二、支持的监控系统"><a href="#二、支持的监控系统" class="headerlink" title="二、支持的监控系统"></a>二、支持的监控系统</h1><p>&amp;emsp;&amp;emsp;MicroMeter不是分布式跟踪系统或事件日志记录器。阿德里安·科尔（Adrian Cole）关于“ 可观测性3种方式”的演讲在强调这些不同类型的系统之间的差异方面做得很好。</p><p>&amp;emsp;&amp;emsp;MicroMeter包含一个带有可视化一起SPI的核心模块，一组包含各种监视系统的实现（每个系统称为注册表）的模块，以及一个测试套件。学习监视系统理解下面三个重要特征：</p><h2 id="2-1-维度"><a href="#2-1-维度" class="headerlink" title="2.1 维度"></a>2.1 维度</h2><p>&amp;emsp;&amp;emsp;系统是否支持通过标记键&#x2F;值对丰富metrics名称（tags）。如果系统不是为维度性的，则它是分层的，这意味着它仅支持平面度量标准名称。将metrics指标发布到分层系统时，Micrometer会展平标签键&#x2F;值对的集合并将其添加到名称中。</p><h2 id="2-2-速率聚合（Rate-aggregation）"><a href="#2-2-速率聚合（Rate-aggregation）" class="headerlink" title="2.2 速率聚合（Rate aggregation）"></a>2.2 速率聚合（Rate aggregation）</h2><p>&amp;emsp;&amp;emsp;在本文中，我们指的是在规定的时间间隔内集合一组样本。一些监视系统希望某些类型的离散样本（例如计数）在发布之前由应用程序转换为比率。有些人希望总是发送累积值。还有其他人对此没有意见。</p><h2 id="2-3-发布"><a href="#2-3-发布" class="headerlink" title="2.3 发布"></a>2.3 发布</h2><p>&amp;emsp;&amp;emsp;一些系统希望在闲暇时轮询应用程序以获取指标，而另一些系统则希望按固定间隔将指标推送给他们。</p><hr><h1 id="三、注册表（Registry）"><a href="#三、注册表（Registry）" class="headerlink" title="三、注册表（Registry）"></a>三、注册表（Registry）</h1><p>&amp;emsp;&amp;emsp;Meter是用于收集有关应用程序的一组度量（我们分别称为metrics指标）的接口。MicroMeter里面的Meters是从MeterRegistry中创建并保存在其中的。每个支持的监视系统都有一个的实现的MeterRegistry。注册表的创建方式因每个监控系统的实现方式而不同。</p><p>&amp;emsp;&amp;emsp;MicroMeter包装带有SimpleMeterRegistry，可在内存中保存每个meter的最新值，并且不会将数据导出到任何地方。如果您还没有首选的监视系统，则可以使用简单的注册表开始使用指标：</p><pre><code>MeterRegistry registry = new SimpleMeterRegistry();</code></pre><p>注：一个SimpleMeterRegistry是基于Spring的应用程序自动注入的。</p><h2 id="3-1-复合注册表"><a href="#3-1-复合注册表" class="headerlink" title="3.1 复合注册表"></a>3.1 复合注册表</h2><p>&amp;emsp;&amp;emsp;MicroMeter提供了一个CompositeMeterRegistry可以添加多个注册表的功能，使我们可以同时将Metrics指标发布到多个监视系统。</p><pre><code>CompositeMeterRegistry composite = new CompositeMeterRegistry();Counter compositeCounter = composite.counter(&quot;counter&quot;);compositeCounter.increment(); (1)SimpleMeterRegistry simple = new SimpleMeterRegistry();composite.add(simple); (2)compositeCounter.increment(); (3)</code></pre><p>1.组合中没有注册表之前，增量为NOOPd。此时计数器的计数仍将为0。</p><p>2.一个名为“ counter”的计数器被注册到简单注册表中。</p><p>3.简单注册表计数器以及组合中任何其他注册表的计数器都会增加。 </p><h2 id="3-2-全局注册表"><a href="#3-2-全局注册表" class="headerlink" title="3.2 全局注册表"></a>3.2 全局注册表</h2><p>&amp;emsp;&amp;emsp;MicroMeter提供了一个静态全局注册表Metrics.globalRegistry和一组静态生成器，用于基于此注册表生成meters。globalRegistry是一个复合注册表。(我是不是可以理解成Metrics就是默认完成了那个Metrics.globalRegistry，然后我们就可以肆无忌惮的使用Mtrics.xxx了)</p><pre><code>class MyComponent &#123;Counter featureCounter = Metrics.counter(&quot;feature&quot;, &quot;region&quot;, &quot;test&quot;); (1)void feature() &#123;    featureCounter.increment();&#125;void feature2(String type) &#123;    Metrics.counter(&quot;feature.2&quot;, &quot;type&quot;, type).increment(); (2)    &#125;&#125;class MyApplication &#123;void start() &#123;    // wire your monitoring system to global static state    Metrics.addRegistry(new SimpleMeterRegistry()); (3)    &#125;    &#125;</code></pre><p>&amp;emsp;&amp;emsp;1.只要能够实现（尤其是在可视化性能至关重要的地方），请将Meter实例存储在字段中，以避免在每次使用时查找其名称&#x2F;标签。</p><p>&amp;emsp;&amp;emsp;2.当需要根据本地上下文确定标记时，您别无选择，只能在方法体内构造&#x2F;查找Meter。查找成本只是单个哈希查找，因此对于大多数用途而言，这是可以接受的。</p><p>&amp;emsp;&amp;emsp;3.创建meters后添加注册表也是可以的，例如Metrics.counter(…​)。这些meters将被添加到每个注册表，因为它已绑定到全局组合。</p><h2 id="3-4-Meters"><a href="#3-4-Meters" class="headerlink" title="3.4 Meters"></a>3.4 Meters</h2><p>&amp;emsp;&amp;emsp;MicroMeter包含的它支持Meter原语集包括：Timer，Counter，Gauge，DistributionSummary，LongTaskTimer，FunctionCounter，FunctionTimer，和TimeGauge。不同的meter类型得出不同数量的时间序列指标metrics。例如，虽然有一个单独的表示Gauge类型的指标，但是Timer类型的指标既得出时间事件的计数，也含有时间事件总的计数。</p><p>&amp;emsp;&amp;emsp;meter是通过其名称和维度进行唯一标识的。我们可以“维度”和“标签”是一个意思，而“MicroMeter”层面Tag仅仅是因为它更短。作为一般规则，应该可以使用该名称作为枢轴。维度允许时间切面以特定的命名指标进行深入分析并推断数据。这意味着，如果仅选择名称，则用户可以使用其他维度和显示值的原因进行追溯。</p><h1 id="五-命名meters"><a href="#五-命名meters" class="headerlink" title="五 命名meters"></a>五 命名meters</h1><p>&amp;emsp;&amp;emsp;MicroMeter采用命名约定，用“.”（点）字符分隔小写单词。不同的监视系统对命名约定有不同的建议，并且某些命名约定可能与一个系统兼容，而与另一个系统不兼容。监视系统的每个Micrometer实施都附带一个命名约定，该约定将小写点标记法名称转换为监视系统推荐的命名约定。此外，此命名约定实现还清除了监视系统不允许的Metrics标准名称和特殊字符标签。您可以使用以下方法在注册表中实现NamingConvention并设置注册表，从而覆盖注册表的默认命名约定：</p><pre><code>registry.config().namingConvention(myCustomNamingConvention);</code></pre><p>&amp;emsp;&amp;emsp;有了适当的命名约定，在Micrometer中注册的以下timer计时器在各种监视系统中就可以很好的使用了：</p><pre><code>registry.timer(&quot;http.server.requests&quot;);</code></pre><p>&amp;emsp;&amp;emsp;Prometheus- http_server_requests_duration_seconds</p><p>&amp;emsp;&amp;emsp;Atlas- httpServerRequests</p><p>&amp;emsp;&amp;emsp;Graphite- http.server.requests</p><p>&amp;emsp;&amp;emsp;InfluxDB- http_server_requests</p><p>&amp;emsp;&amp;emsp;通过遵守Micrometer的小写点标记约定，我们就可以确保跨监视系统的metrics名称具有最大的可移植性。</p><h2 id="5-1-标签命名"><a href="#5-1-标签命名" class="headerlink" title="5.1 标签命名"></a>5.1 标签命名</h2><blockquote><p>tip</p><blockquote><p>命名标签时，建议使用与metrics名称相同的小写点标记。利用标签的这种一致的命名约定，可以更好地转换为相应监视系统的惯用命名方案。</p></blockquote></blockquote><p>假设我们正在尝试测量http请求的数量和数据库调用的数量。</p><p>推荐方法：</p><pre><code>registry.counter(&quot;database.calls&quot;, &quot;db&quot;, &quot;users&quot;)registry.counter(&quot;http.requests&quot;, &quot;uri&quot;, &quot;/api/users&quot;)</code></pre><p>&amp;emsp;&amp;emsp;这个变量提供了足够的文本信息，因此，如果仅选择名称，则可以推断出该值，并且至少具有潜在的意义。例如，如果我们选择“database.calls”则可以看到所有数据库的调用总数。然后，我们可以分组或选择“db”以进一步细分或对呼叫对每个数据库的贡献进行比较分析。</p><p>不合适的方法</p><pre><code>registry.counter(&quot;calls&quot;,                &quot;class&quot;, &quot;database&quot;,                &quot;db&quot;, &quot;users&quot;);registry.counter(&quot;calls&quot;,                &quot;class&quot;, &quot;http&quot;,                &quot;uri&quot;, &quot;/api/users&quot;);</code></pre><p>&amp;emsp;&amp;emsp;在这种方法中，如果选择，calls我们将获得一个值，该值是对数据库和API端点的调用次数的总和。如果没有进一步的维度向下钻取，该时间序列将无用。</p><h2 id="5-2-通用标签"><a href="#5-2-通用标签" class="headerlink" title="5.2 通用标签"></a>5.2 通用标签</h2><p>&amp;emsp;&amp;emsp;可以在注册表级别定义公用标签，并将其添加到报告给监视系统的每个度量标准中。通常用于在操作环境（例如主机，实例，区域，堆栈等）上进行维度深入分析。</p><pre><code>registry.config().commonTags(&quot;stack&quot;, &quot;prod&quot;, &quot;region&quot;, &quot;us-east-1&quot;);registry.config().commonTags(Arrays.asList(Tag.of(&quot;stack&quot;, &quot;prod&quot;), Tag.of(&quot;region&quot;, &quot;us-east-1&quot;))); // equivalently</code></pre><p>&amp;emsp;&amp;emsp;调用commonTags追加其他通用标签。</p><blockquote><p>重要</p><blockquote><p>如果我们在Spring环境中，需要通过添加MeterRegistryCustomizerBean来添加通用标签，以确保在自动配置meter绑定程序之前应用了通用标签。</p></blockquote></blockquote><h2 id="5-3-标签值"><a href="#5-3-标签值" class="headerlink" title="5.3 标签值"></a>5.3 标签值</h2><p>&amp;emsp;&amp;emsp;标签值必须非空</p><blockquote><p>警告</p><blockquote><p>注意来自用户提供的来源的标记值可能会破坏指标的基数。我们应该始终保持规范并绑定用户提供的输入。有时原因是非常细微的。考虑用于记录服务端点上的HTTP请求的URI标记。如果我们不将404约束为NOT_FOUND之类的值，则metrics的维度将随着找不到的每个资源而增长。</p></blockquote></blockquote><hr><h1 id="6-Meter过滤器"><a href="#6-Meter过滤器" class="headerlink" title="6.Meter过滤器"></a>6.Meter过滤器</h1><p>&amp;emsp;&amp;emsp;每个注册表都可以配置meter过滤器，使我们可以更好地控制如何注册仪表，何时注册仪表以及发出何种统计信息。Meter过滤器具有三个基本功能：</p><p>&amp;emsp;&amp;emsp;1.拒绝（或接受）meter被注册。</p><p>&amp;emsp;&amp;emsp;2.转换Meter的ID（例如，更改名称，添加或删除标签，更改描述或基本单位）。</p><p>&amp;emsp;&amp;emsp;3.配置某些meter类型的分布统计信息。</p><p>&amp;emsp;&amp;emsp;MeterFilter的实现以编程方式添加到注册表中：</p><pre><code>registry.config().meterFilter(MeterFilter.ignoreTags(&quot;too.much.information&quot;)).meterFilter(MeterFilter.denyNameStartsWith(&quot;jvm&quot;));</code></pre><p>&amp;emsp;&amp;emsp;按顺序应用Meter过滤器，并将变换或配置meter的结果链接在一起。</p><h2 id="6-1-拒绝-x2F-接受meters"><a href="#6-1-拒绝-x2F-接受meters" class="headerlink" title="6.1 拒绝&#x2F;接受meters"></a>6.1 拒绝&#x2F;接受meters</h2><p>&amp;emsp;&amp;emsp;接受&#x2F;拒绝过滤器的详细形式为：</p><pre><code>new MeterFilter() &#123;    @Override    public MeterFilterReply accept(Meter.Id id) &#123;       if(id.getName().contains(&quot;test&quot;)) &#123;          return MeterFilterReply.DENY;       &#125;       return MeterFilterReply.NEUTRAL;        &#125;    &#125;</code></pre><p>&amp;emsp;&amp;emsp;MeterFilterReply具有三种可能的状态：</p><ul><li><p>DENY-请勿注册该仪表。当我们尝试注册一个与另一个注册表冲突的meter,过滤器返回DENY注册表将返回meter的NOOP版本（例如NoopCounter，NoopTimer）。我们的代码可以继续与NOOP计量器进行交互，但是记录在其中的任何内容都将以最小的开销立即被丢弃。</p></li><li><p>NEUTRAL-如果没有其他meter过滤器返回DENY，则meter的注册将照常进行。</p></li><li><p>ACCEPT-如果过滤器返回ACCEPT，meter将立即注册，而不会询问任何其他过滤器的接受方法。</p></li></ul><h3 id="6-1-1-便利的方法"><a href="#6-1-1-便利的方法" class="headerlink" title="6.1.1 便利的方法"></a>6.1.1 便利的方法</h3><h3 id="6-1-2-链接-拒绝-x2F-接受meters"><a href="#6-1-2-链接-拒绝-x2F-接受meters" class="headerlink" title="6.1.2 链接 拒绝&#x2F;接受meters"></a>6.1.2 链接 拒绝&#x2F;接受meters</h3><h2 id="6-2-转换metrics"><a href="#6-2-转换metrics" class="headerlink" title="6.2 转换metrics"></a>6.2 转换metrics</h2><p>&amp;emsp;&amp;emsp;转换过滤器如下所示：</p><pre><code>new MeterFilter() &#123;    @Override    public Meter.Id map(Meter.Id id) &#123;       if(id.getName().startsWith(&quot;test&quot;)) &#123;          return id.withName(&quot;extra.&quot; + id.getName()).withTag(&quot;extra.tag&quot;, &quot;value&quot;);       &#125;       return id;    &#125;&#125;</code></pre><p>&amp;emsp;&amp;emsp;该过滤器有条件地向meters添加以名称“ test”开头的名称前缀和附加标签。</p><p>&amp;emsp;&amp;emsp;MeterFilter 为许多常见的转换案例提供了便利构建器：</p><p>&amp;emsp;&amp;emsp;commonTags(Iterable<Tag>)-向所有指标添加一组标签。强烈建议为应用名称，主机，区域等添加通用标签。</p><p>&amp;emsp;&amp;emsp;ignoreTags(String…​)-从每个仪表上舍弃匹配的标签键。当标签可证明变得过高的基数并开始给监视系统施加压力或开销增大，使得我们不能快速更改所有检测点时，此功能特别有用。</p><p>&amp;emsp;&amp;emsp;replaceTagValues(String tagKey, Function&lt;String, String&gt; replacement, String…​ exceptions)-根据为所有匹配的标记键提供的映射替换标记值。通过将标签值的某些部分映射到其他内容，可以用来减少标签的总基数。</p><p>&amp;emsp;&amp;emsp;renameTag(String meterNamePrefix, String fromTagKey, String toTagKey) -重命名以给定前缀开头的每个指标的标签键。</p><h2 id="6-3-配置分布统计"><a href="#6-3-配置分布统计" class="headerlink" title="6.3 配置分布统计"></a>6.3 配置分布统计</h2><p>&amp;emsp;&amp;emsp;Timer和DistributionSummary除了可以通过过滤器配置的计数、总数和最大值的基本信息外，还包含一组可选的分布统计信息。这些分布统计信息包括预先计算的百分位数，SLA和直方图。</p><pre><code>new MeterFilter() &#123;    @Override    public DistributionStatisticConfig configure(Meter.Id id, DistributionStatisticConfig config) &#123;        if (id.getName().startsWith(prefix)) &#123;            return DistributionStatisticConfig.builder()                    .publishPercentiles(0.9, 0.95)                    .build()                    .merge(config);        &#125;        return config;    &#125;&#125;;</code></pre><p>&amp;emsp;&amp;emsp;通常，我们应该仅对我们希望配置的切片创建一个新的DistributionStatisticConfig并且将它与输入的配置合并。这样，我们就可以下拉注册表提供的分发统计信息的默认值，并将多个过滤器链接在一起，每个过滤器都可以配置分发统计信息的一部分（例如，我们可能希望所有http请求都具有100ms的SLA，但在一些关键请求上只需要百分位端点）。</p><p>&amp;emsp;&amp;emsp;MeterFilter 为以下人员提供便利构建器：</p><p>&amp;emsp;&amp;emsp;maxExpected(Duration&#x2F;long) -控制从timer或summary中得到的百分比直方图桶的上限。</p><p>&amp;emsp;&amp;emsp;minExpected(Duration&#x2F;long) -控制从timer或summary中得到的百分比直方图桶的下限。</p><p>&amp;emsp;&amp;emsp;Spring Boot提供了基于属性的过滤器，用于通过名称前缀配置SLA，百分比和百分比直方图。</p><h1 id="7-速率聚合"><a href="#7-速率聚合" class="headerlink" title="7.速率聚合"></a>7.速率聚合</h1><p>&amp;emsp;&amp;emsp;Micrometer知道特定的监视系统希望在metrics发布之前还是在服务器端作为查询的一部分临时在客户端进行速率聚合。它根据监视系统期望的样式累积metrics。</p><p>&amp;emsp;&amp;emsp;并非所有测量指标都进行速率聚合进行报告或展示。例如，gauge和long task timer的任务就不是速率聚合。 </p><p>&amp;emsp;&amp;emsp;执行服务器端速率聚合的监视系统希望在每个发布间隔报告绝对值。例如，自从应用程序的开始运行，在每个发布间隔所有counter增量的绝对值都会发布。</p><p>&amp;emsp;&amp;emsp;假设我们有一个略微偏向的随机游走，它选择每10ms增加一次counter计数器。如果我们在监控系统，比如Prometheus这样的系统中查看原始计数器值，则会看到逐步单调递增的函数（步长是Prometheus轮询或抓取数据的间隔）。</p><p><img src="https://wx4.sinaimg.cn/mw690/007857NYly1g8v8j33vttj30i708zmxx.jpg" alt="rate1"></p><p>&amp;emsp;&amp;emsp;在某个时间窗口内没有速率聚合的counter很少是有用的，因为表示的是计数器递增的速度和服务寿命的函数。在上面的示例中，服务重新启动时，counter降回零。新实例（例如在生产部署中）投入使用后，速率聚合图像将返回到约55的值。</p><p>&amp;emsp;&amp;emsp;如果我们已实现零停机时间部署（例如通过红黑部署），则应该能够在速率汇总图上轻松设置最低警报阈值，而无需重新启动服务导致计数器值下降。</p><blockquote><p>重要</p><blockquote><p>对于大多数生产目的，无论是警报，自动数据分析等，都是基于速率汇总数据进行自动化的。</p></blockquote></blockquote><h2 id="7-2-客户端"><a href="#7-2-客户端" class="headerlink" title="7.2 客户端"></a>7.2 客户端</h2><p>另一类监视系统：</p><p>&amp;emsp;&amp;emsp;1.期望速率汇总数据。考虑到对于大多数生产目的的关键需求指标，我们应该基于速率而不是绝对值来做出决策，这样的系统将得益于无需进行太多数学运算即可满足查询的需求。</p><p>&amp;emsp;&amp;emsp;2.几乎没有数学运算或没有数学运算，即可使我们可以通过查询对数据进行速率聚合。对于这些系统，发布预先聚合的数据是构建有意义的表示的唯一方法。</p><p>&amp;emsp;&amp;emsp;MicroMeter通过累积当前发布间隔数据的步长值来有效维护速率数据。当对步长值进行轮询时（例如，在发布时），如果步长值检测到当前间隔已过去，则它将当前数据移至“先前”状态。该先前状态是报告的，直到下次当前数据覆盖它为止。以下是当前和先前状态以及轮询之间相互作用的说明：</p><p>&amp;emsp;&amp;emsp;poll函数返回的值始终是每秒的速率*间隔。如果上面说明的步长值表示counter的值，则可以说计数器在第一个间隔中看到了“每秒0.3增量”，这可以在第二个间隔中的任何时间报告给后端。</p><p>&amp;emsp;&amp;emsp;MicroMeterde的timer至少跟踪一个计数和总时间，作为单独的测量。假设我们以10秒的间隔配置发布，并且看到20个请求，每个请求花费100毫秒。然后在第一个间隔中：</p><pre><code>1.count = 10秒*（20个请求/ 10秒）= 20个请求2.totalTime = 10秒*（20 * 100毫秒/ 10秒）= 2秒</code></pre><p>&amp;emsp;&amp;emsp;该count统计信息很有意义，可以单独使用–它是吞吐量的度量。totalTime表示间隔中所有请求的总延迟。另外：</p><pre><code>totalTime / count = 2秒/ 20个请求= 0.1秒/请求= 100 ms /请求</code></pre><p>&amp;emsp;&amp;emsp;这是平均延迟的有用度量。当将相同的思想应用于分布汇总totalAmount并count从中得出时，该度量称为分布平均值。平均延迟只是按时间（timer）度量的分发summary的分发平均值。犹如Atlas一些监测系统计算从这些统计分布平均提供设施和MicroMeter将发布totalTime和count作为单独统计。其他如Datadog则没有内置此类操作，Micrometer将计算客户端的平均分配并将其发送出去。<br><img src="https://wx4.sinaimg.cn/mw690/007857NYly1g8v8gqzxc1j31cm0fpjtr.jpg" alt="rate分析"><br>&amp;emsp;&amp;emsp;发布时间间隔的速率足以推断出在任何时间窗口内大于或等于发布时间间隔的速率。在我们的示例中，如果服务在给定的分钟内继续接收20个请求，在每10秒间每个请花费100ms，那么我们可以说：</p><p>&amp;emsp;&amp;emsp;1.MicroMeter每10秒报告一次total–“ 20个请求” 。监视系统简单地将这六个10秒的间隔相加即可得出每分钟120个请求的结论。请注意，是进行进行求和操作的是监视系统，而不是MicroMeter。</p><p>&amp;emsp;&amp;emsp;2.MicroMeter每隔10 秒报告一次totalTime–“ 2秒” 。监视系统可以对一分钟内的所有总时间统计信息求和，以在分钟间隔内产生总时间的“ 12秒”。然后，平均延迟就如我们期望的那样：12秒&#x2F; 120个请求&#x3D; 100 ms &#x2F;请求。</p><hr><h1 id="8-Counters"><a href="#8-Counters" class="headerlink" title="8.Counters"></a>8.Counters</h1><p>Couners报告一个指标，计数。该Counter接口允许我们以固定数量递增，该数量必须为正。</p><blockquote><p>tip</p><blockquote><p>永远不要记数一些我们可以使用Timer或用DistributionSummary记录的东西！Timer和DistributionSummary会发布除了其他的测量事件之外，还有事件的计数。</p></blockquote></blockquote><p>&amp;emsp;&amp;emsp;建立图表并根据Counter发出警报时，通常我们应该最感兴趣的是测量在给定时间间隔内某些事件的速率。考虑一个简单的队列，Counter可用于衡量事物的插入和移除速度。</p><p>&amp;emsp;&amp;emsp;人们首先想到的是可视化绝对数值，而不是速率，但绝对数量通常是既是一些事务的使用速率的函数也是可视化条件下应用程序实例的使用寿命。在某些时间间隔内构建仪表板和Counter速率警报会忽略应用程序的寿命，让我们在应用程序启动后很长时间才看到异常行为。</p><blockquote><p>注意</p><blockquote><p>在进入使用计数器之前，请务必通读Timer部分，因为Timer会记录计时事件的计数，因为Counter记录了时间事件的计数作为度量的一部分。对于我们打算计时的那些代码，我们无需单独添加计数器。</p></blockquote></blockquote><p>&amp;emsp;&amp;emsp;以下代码模拟了一个真实的Counter，该Counter的rate在较短的时间范围内显示出一些扰动。</p><pre><code>Normal rand = ...; // a random generatorMeterRegistry registry = ...Counter counter = registry.counter(&quot;counter&quot;); (1)Flux.interval(Duration.ofMillis(10))    .doOnEach(d -&gt; &#123;        if (rand.nextDouble() + 0.1 &gt; 0) &#123; (2)            counter.increment(); (3)        &#125;    &#125;)    .blockLast();</code></pre><p>&amp;emsp;&amp;emsp;1.可以使用名称和（可选）一组标签从注册表本身创建大多数Counter。</p><p>&amp;emsp;&amp;emsp;2.略微偏向的随机游走。</p><p>&amp;emsp;&amp;emsp;3.这就是我们与Conuter交互的方式。我们也可以用counter.increment(n)在单个操作中调用增加1以上的值。</p><p>&amp;emsp;&amp;emsp;Counter接口本身还有一个流利的计数器构建器，可以访问不太常用的选项，例如基本单位和说明。我们可以通过调用将计数器注册为构造计数器的最后一步register。</p><pre><code>Counter counter = Counter    .builder(&quot;counter&quot;)    .baseUnit(&quot;beans&quot;) // optional    .description(&quot;a description of what this counter does&quot;) // optional    .tags(&quot;region&quot;, &quot;test&quot;) // optional    .register(registry);</code></pre><h2 id="8-1-功能–追踪Counter"><a href="#8-1-功能–追踪Counter" class="headerlink" title="8.1 功能–追踪Counter"></a>8.1 功能–追踪Counter</h2><p>&amp;emsp;&amp;emsp;MicroMeter还提供了一种更不常用的计数器模式，该模式跟踪单调递增的函数（函数保持不变或随时间增加，但从不减少）。一些监视系统（例如Prometheus）将Counter的累积值推送到后端，但是其他系统则发布Counter在推送间隔内递增的速率。通过采用这种模式，我们可以让监控系统的Micrometer实施选择是否对Counter进行归一化评估，并且计数器可以在不同类型的监控系统之间保持可移植性。</p><pre><code>Cache cache = ...; // suppose we have a Guava cache with stats recording onregistry.more().counter(&quot;evictions&quot;, tags, cache, c -&gt; c.stats().evictionCount()); (1)</code></pre><p>&amp;emsp;&amp;emsp;1.evictionCount() 是一个单调递增的函数，从生命周期的开始就随着每次缓存逐出而递增。</p><p>&amp;emsp;&amp;emsp;功能–跟踪Counter,与监视系统的速率归一化功能（无论是查询语言的人工产物还是数据被推送到系统的方式）配合使用，在功能的累积值之上增加了一层丰富性。可以推断值增加的速率，这样的速率是否在一个可接受的范围，随着时间的推移是在增加或降低。</p><blockquote><p>警告</p><blockquote><p>MicroMeter不能为您保证函数的单调性。通过使用此签名，我们可以根据对定义的了解来断言其单调性。</p></blockquote></blockquote><p>&amp;emsp;&amp;emsp;FunctionCounter接口本身也具有用于功能计数器的流利的构建器，可以访问不太常用的选项，例如基本单元和描述。我们可以通过调用将计数器注册为构造计数器的最后一步register(MeterRegistry)。</p><pre><code>MyCounterState state = ...;FunctionCounter counter = FunctionCounter    .builder(&quot;counter&quot;, state, state -&gt; state.count())    .baseUnit(&quot;beans&quot;) // optional    .description(&quot;a description of what this counter does&quot;) // optional    .tags(&quot;region&quot;, &quot;test&quot;) // optional    .register(registry);</code></pre><h1 id="9-Gauge"><a href="#9-Gauge" class="headerlink" title="9.Gauge"></a>9.Gauge</h1><p>&amp;emsp;&amp;emsp;Gauge是获取当前值的处理器。Gauge的典型示例是运行状态下的<strong>集合或映射的大小或线程数</strong>。</p><blockquote><p>tip</p><blockquote><p>Gauge对于监视具有自然上限的事物很有用。不建议使用Gauge来监视诸如请求计数之类的事情，因为它们会在应用程序实例生命周期内不受限制地增长。</p></blockquote></blockquote><blockquote><p>tip</p><blockquote><p>能用Counter计量的东西千万不要用Gauge！</p></blockquote></blockquote><p>&amp;emsp;&amp;emsp;MicroMeter的立场是应该对Gauge进行采样而不进行设置，因此没有关于样品之间可能发生的情况的信息。毕竟，在将Gauge值报告给Metrics后端后，Gauge上设置的任何中间值都会丢失，因此首先设置这些中间值似乎没有什么价值。</p><p>&amp;emsp;&amp;emsp;如果有帮助，可以将其Gauge视为“heisen-gauge”-仅在观察到时才会改变的仪表。开箱即用提供的所有其他Meter类型都会在向数据后端发送数据时累积中间计数。</p><p>&amp;emsp;&amp;emsp;该MeterRegistry接口包含用于构建Gauge以观察数值、方法、、集合和映射的方法。</p><pre><code>List&lt;String&gt; list = registry.gauge(&quot;listGauge&quot;, Collections.emptyList(), new ArrayList&lt;&gt;(), List::size); (1)List&lt;String&gt; list2 = registry.gaugeCollectionSize(&quot;listSize2&quot;, Tags.empty(), new ArrayList&lt;&gt;()); (2)Map&lt;String, Integer&gt; map = registry.gaugeMapSize(&quot;mapGauge&quot;, Tags.empty(), new HashMap&lt;&gt;());</code></pre><p>&amp;emsp;&amp;emsp;1.gauge的一种较常见的形式是监视某些非数字对象。最后一个参数建立了一个函数，该函数用于在观察gauge时确定gauge的值。</p><p>&amp;emsp;&amp;emsp;2.对于(1)的一种更方便的形式，用于您只想监视集合大小的情况。</p><p>&amp;emsp;&amp;emsp;创建gauge的所有不同形式都仅保持对要观察的对象的弱引用，以免阻止对象的垃圾收集。</p><h2 id="9-1-手动增减仪表"><a href="#9-1-手动增减仪表" class="headerlink" title="9.1 手动增减仪表"></a>9.1 手动增减仪表</h2><p>&amp;emsp;&amp;emsp;gauge可制成可以跟踪任何java.lang.Number亚型，如java.util.concurrent.atomic中发现的AtomicInteger和AtomicLong，和Guava的AtomicDouble类似的类型。</p><pre><code>AtomicInteger n = registry.gauge(&quot;numberGauge&quot;, new AtomicInteger(0));n.set(1);n.set(2);</code></pre><p>&amp;emsp;&amp;emsp;请注意，这种形式与其他meter类型不同，Gauge在创建一个meter时，我们不会得到引用，而是要观察到的东西。这是因为存在”heisen-gauge”原理，gauge一经创建便是自给自足的，因此我们无需与之交互。这使MicroMeter可以只向我们退还已检测的对象，从而可以快速创建一个可观察对象并围绕该对象设置metrics指标。</p><p>&amp;emsp;&amp;emsp;此模式应比DoubleFunction表格少见。请记住，频繁设置观察值会Number导致许多中间值无法发布。仅在发布时将gauge的瞬时值发送到监视系统。</p><blockquote><p>警告</p><blockquote><p>尝试使用原始数字或其java.lang对象形式之一构造gauge总是不正确的。这些数字是不可变的，因此gauge无法更改。尝试用不同的编号“重新注册”量规是行不通的，因为注册表仅对名称和标签组成的唯一组合维护一个仪表。</p></blockquote></blockquote><h2 id="9-2-量规的构建器"><a href="#9-2-量规的构建器" class="headerlink" title="9.2 量规的构建器"></a>9.2 量规的构建器</h2><p>&amp;emsp;&amp;emsp;该接口包含一个流利的gauge构建器：</p><pre><code>Gauge gauge = Gauge    .builder(&quot;gauge&quot;, myObj, myObj::gaugeValue)    .description(&quot;a description of what this gauge does&quot;) // optional    .tags(&quot;region&quot;, &quot;test&quot;) // optional    .register(registry);</code></pre><p>&amp;emsp;&amp;emsp;通常，返回的Gauge实例仅在测试中有用，因为gauge已设置为在注册后自动跟踪数值。</p><h2 id="9-3-我的仪表为什么报告NaN或消失？"><a href="#9-3-我的仪表为什么报告NaN或消失？" class="headerlink" title="9.3 我的仪表为什么报告NaN或消失？"></a>9.3 我的仪表为什么报告NaN或消失？</h2><p>&amp;emsp;&amp;emsp;MicroMeter对于创建强引用对象非常谨慎，避免那些对象无法进行垃圾收集，一旦被测量的对象被取消引用并被垃圾回收，Micrometer将开始报告测量值的NaN或不报告，具体取决于注册表的实现方式。</p><p>&amp;emsp;&amp;emsp;如果看到gauge报告了几分钟，然后消失或报告了NaN，则几乎可以肯定地表明被测量的基础对象已被垃圾回收。</p><hr><h1 id="10-计时器"><a href="#10-计时器" class="headerlink" title="10 计时器"></a>10 计时器</h1><p>&amp;emsp;&amp;emsp;计时器用于测量短时延以及此类事件的频率。所有实现的Timer将按照时间序列报告至少总时间和事件计数。尽管可以将Timers用于其他用例，但请注意不支持负值，并且记录更长的持续时间可能会导致总时间溢出（以Long.MAX_VALUE纳秒计）（292.3年）。</p><p>&amp;emsp;&amp;emsp;例如，考虑一个图表，它显示了对典型Web服务器的请求延迟。可以期望服务器快速响应许多请求，因此计时器将每秒更新多次。</p><p>&amp;emsp;&amp;emsp;Counter的适当基本单位因指标后端的不同而有所不同。MicroMeter对此毫无疑问，但是由于存在混淆的可能性，与Timers 相互作用时需要TimeUnit。Micrometer知道每种实现的首选项，并根据实现在适当的基本单元中发布我们的时间安排。</p><pre><code>public interface Timer extends Meter &#123;    ...    void record(long amount, TimeUnit unit);    void record(Duration duration);    double totalTime(TimeUnit unit);&#125;</code></pre><p>&amp;emsp;&amp;emsp;该接口包含一个流畅的Timer构建器：</p><pre><code>Timer timer = Timer.builder(&quot;my.timer&quot;).description(&quot;a description of what this timer does&quot;) // optional.tags(&quot;region&quot;, &quot;test&quot;) // optional.register(registry);</code></pre><h2 id="10-1-记录代码块"><a href="#10-1-记录代码块" class="headerlink" title="10.1 记录代码块"></a>10.1 记录代码块</h2><p>&amp;emsp;&amp;emsp;该Timer接口公开了一些方便的重载，用于内联时间记录，例如：</p><pre><code>timer.record(() -&gt; dontCareAboutReturnValue());timer.recordCallable(() -&gt; returnValue());Runnable r = timer.wrap(() -&gt; dontCareAboutReturnValue()); (1)Callable c = timer.wrap(() -&gt; returnValue());</code></pre><p>1.包装Runnable或Callable返回其可视化版本以供以后使用。</p><blockquote><p>注意</p><blockquote><p>Timer实际上只是一个专门的分布式summary，它知道如何将持续时间缩放到每个监视系统的基本时间单位，并且具有自动确定的基本单位。在每种情况下，如果要测量时间，都应使用Timer而不是DistributionSummary。</p></blockquote></blockquote><h2 id="10-2-将开始状态存储在Timer-Sample"><a href="#10-2-将开始状态存储在Timer-Sample" class="headerlink" title="10.2 将开始状态存储在Timer.Sample"></a>10.2 将开始状态存储在Timer.Sample</h2><p>&amp;emsp;&amp;emsp;您也可以将启动状态存储在示例实例中，以后可以将其停止。该示例记录基于注册表时钟的开始时间。开始采样后，执行要计时的代码，并通过调用stop(Timer)采样完成操作。</p><pre><code>Timer.Sample sample = Timer.start(registry);// do stuffResponse response = ...sample.stop(registry.timer(&quot;my.timer&quot;, &quot;response&quot;, response.status()));</code></pre><p>&amp;emsp;&amp;emsp;请注意，在停止采样之前，如何确定采样所用的计时器。这使我们能够根据我们正在计时的操作的结束状态动态地确定某些标签。</p><h2 id="10-3-Timed注解"><a href="#10-3-Timed注解" class="headerlink" title="10.3 @Timed注解"></a>10.3 @Timed注解</h2><p>&amp;emsp;&amp;emsp;micrometer-core模块包含一个@Timed注释，框架可以使用该注释向特定类型的方法（例如为Web请求端点提供服务的方法）或通常为所有方法添加计时支持。</p><blockquote><p>警告</p><blockquote><p>Micrometer的Spring Boot配置无法@Timed在任意方法上识别。</p></blockquote></blockquote><p>&amp;emsp;&amp;emsp;还包含一个可孵化的AspectJ方面micrometer-core，在应用程序中，我们可以通过编译&#x2F;加载AspectJ编织，或通过框架工具比如Spring Aop等其他方式解释AspectJ切面和代理目标方法。如下是一个示例Spring AOP配置：</p><pre><code>@Configurationpublic class TimedConfiguration &#123;@Beanpublic TimedAspect timedAspect(MeterRegistry registry) &#123;  return new TimedAspect(registry);   &#125;&#125;</code></pre><p>&amp;emsp;&amp;emsp;在AspectJ代理实例中，应用程序TimedAspect的@Timed用于任何任意方法。</p><h2 id="10-4-功能–跟踪timers"><a href="#10-4-功能–跟踪timers" class="headerlink" title="10.4 功能–跟踪timers"></a>10.4 功能–跟踪timers</h2><p>&amp;emsp;&amp;emsp;MicroMeter还提供了一种不常用的计时器模式，该模式可跟踪两个单调递增的函数（一个函数随时间保持不变或增加，但从不减小）：计数函数和总时间函数。某些监视系统（例如Prometheus）将计数器的累积值（在这种情况下适用于计数和总时间函数）推送到后端，但其他系统则发布计数器在推送间隔内递增的速率。通过采用这种模式，我们可以让监控系统的Micrometer实现选择是否对timer进行速率聚合，并且计时器可以在不同类型的监控系统之间保持可移植性。</p><pre><code>IMap&lt;?, ?&gt; cache = ...; // suppose we have a Hazelcast cacheregistry.more().timer(&quot;cache.gets.latency&quot;, Tags.of(&quot;name&quot;, cache.getName()), cache,    c -&gt; c.getLocalMapStats().getGetOperationCount(), (1)    c -&gt; c.getLocalMapStats().getTotalGetLatency(),    TimeUnit.NANOSECONDS (2));</code></pre><p>&amp;emsp;&amp;emsp;1.getGetOperationCount() 是一个单调递增的函数，它从生命周期的开始就随着每个缓存的获取而递增。</p><p>&amp;emsp;&amp;emsp;2.这表示由getTotalGetLatency()表示的时间单位。每个注册表实现均指定其预期的基本时间单位是什么，并且报告的总时间将缩放为该值。</p><p>&amp;emsp;&amp;emsp;功能–跟踪timer与监视系统的速率归一功能（无论是查询语言的人工产物还是数据被推送到系统的方式）配合使用，在功能的累积值之上增加了一层丰富性，我们可以推断吞吐量和延迟的速率，该速率是否在可接受的范围内，随时间增加还是减少等。</p><blockquote><p>警告</p><blockquote><p>MicroMeter不能为我们保证count和total time功能的单调性。通过使用此签名，您可以根据对定义的了解来断言它们的单调性。</p></blockquote></blockquote><p>&amp;emsp;&amp;emsp;FunctionTimer接口本身还有一个流利的FunctionTimer构建器，可用于访问不常用的选项，例如基本单元和描述。您可以通过调用register(MeterRegistry)为构造计时器的最后一步)。</p><pre><code>IMap&lt;?, ?&gt; cache = ...FunctionTimer.builder(&quot;cache.gets.latency&quot;, cache,        c -&gt; c.getLocalMapStats().getGetOperationCount(),        c -&gt; c.getLocalMapStats().getTotalGetLatency(),        TimeUnit.NANOSECONDS)    .tags(&quot;name&quot;, cache.getName())    .description(&quot;Cache gets&quot;)    .register(registry);</code></pre><h2 id="10-5-暂停检测"><a href="#10-5-暂停检测" class="headerlink" title="10.5 暂停检测"></a>10.5 暂停检测</h2><p>&amp;emsp;&amp;emsp;MicroMeter使用LatencyUtils包来补偿协同遗漏—系统和VM暂停导致的额外延迟会延迟您的延迟统计信息。百分位数和SLA计数之类的分布统计信息受暂停检测器实现的影响，该实现会在此处和此处添加额外的延迟以补偿暂停。</p><p>&amp;emsp;&amp;emsp;MicroMeter支持两种暂停检测器实施方式：基于时钟漂移的检测器和无操作检测器。在MicroMeter的1.0.10&#x2F;1.1.4&#x2F;1.2.0版本之前，默认情况下配置了时钟漂移检测器以报告尽可能准确的度量标准，而无需进行进一步配置。从1.0.10&#x2F;1.1.4&#x2F;1.2.0版本开始，默认情况下配置无操作检测器，但可以如下配置时钟漂移检测器。</p><p>&amp;emsp;&amp;emsp;基于时钟漂移的检测器具有可配置的睡眠间隔和暂停阈值。CPU消耗与sleepInterval、暂停检测精度成反比。这两个值的100ms是合理的默认值，以提供对长时间停顿事件的适当检测，同时消耗可忽略的CPU时间。</p><p>&amp;emsp;&amp;emsp;我们可以使用以下方法自定义暂停检测器：</p><pre><code>registry.config().pauseDetector(new ClockDriftPauseDetector(sleepInterval, pauseThreshold));registry.config().pauseDetector(new NoPauseDetector());</code></pre><p>&amp;emsp;&amp;emsp;将来，我们可能会提供进一步的检测器实现。例如，在某些情况下，可以从GC日志中推断出一些暂停，而不需要恒定的CPU负载，尽管负载很小。将来的JDK也可能会提供对暂停事件的直接访问。</p><h2 id="10-6-内存占用估算"><a href="#10-6-内存占用估算" class="headerlink" title="10.6 内存占用估算"></a>10.6 内存占用估算</h2><p>&amp;emsp;&amp;emsp;Timer是最消耗内存的meter，其总占用空间可能会因我们选择的选项而有很大差异。下表是基于各种功能使用情况的内存消耗表。这些数字假定没有标签，并且环形缓冲区的长度为3。添加标签当然会增加总数，增加缓冲区的长度也会有所增加。总存储量也可能会有所不同，具体取决于注册表的实现。</p><ul><li><p>R &#x3D;环形缓冲区的长度。在所有示例中，我们假定默认值为3。R用设置Timer.Builder#distributionStatisticBufferLength。</p></li><li><p>B &#x3D;总直方图桶。可以是SLA边界或百分比直方图桶。默认情况下，计时器被限制为最小期望值1ms和最大期望值30秒，如果适用，则为百分比直方图产生66个桶。</p></li><li><p>I &#x3D;暂停补偿的间隔估算器。1.7 kb</p></li><li><p>M &#x3D;最大衰减时间。104字节</p></li><li><p>Fb &#x3D;固定边界直方图。30b * B * R</p></li><li><p>Pp &#x3D;百分位数精度。默认情况下为1。通常在[0，3]范围内。Pp用设置Timer.Builder#percentilePrecision。</p></li><li><p>Hdr（Pp）&#x3D;高动态范围直方图。</p></li></ul><p>若 Pp &#x3D; 0：1.9kb * R + 0.8kb</p><p>若 Pp &#x3D; 1：3.8kb * R + 1.1kb</p><p>若 Pp &#x3D; 2：18.2kb * R + 4.7kb</p><p>若 Pp &#x3D; 3：66kb * R + 33kb</p><table><thead><tr><th align="center">暂停检测</th><th align="center">客户端百分位数</th><th align="center">Cool</th><th align="center">直方图和&#x2F;或SLA</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">YES</td><td align="center">NO</td><td align="center">NO</td><td align="center">I+M</td><td align="center">~1.8kb</td></tr><tr><td align="center">YES</td><td align="center">NO</td><td align="center">YES</td><td align="center">I+M+Fb</td><td align="center">对于默认的百分比直方图，〜7.7kb</td></tr><tr><td align="center">YES</td><td align="center">YES</td><td align="center">YES</td><td align="center">I+M+Hdr(Pp)</td><td align="center">要添加默认值的0.95％，否则为〜14.3kb</td></tr><tr><td align="center">NO</td><td align="center">NO</td><td align="center">NO</td><td align="center">M</td><td align="center">〜0.1kb</td></tr><tr><td align="center">NO</td><td align="center">NO</td><td align="center">YES</td><td align="center">M+Fb</td><td align="center">对于默认的百分比直方图，〜6kb</td></tr><tr><td align="center">NO</td><td align="center">YES</td><td align="center">YES</td><td align="center">M+Hdr(Pp)</td><td align="center">要添加默认值的0.95％，否则为〜12.6kb</td></tr></tbody></table><blockquote><p>注意</p><blockquote><p>这些估计是基于Micrometer 1.0.3中所做的改进，并且假定至少使用该版本。</p></blockquote></blockquote><blockquote><p>注意</p><blockquote><p>特别是对于Prometheus ，无论您如何尝试通过进行配置Timer.Builder，R 始终等于1 。这对于</p></blockquote></blockquote><p>&amp;emsp;&amp;emsp;Prometheus来说是特殊情况，因为它期望永不翻转的累积直方图数据。</p><h1 id="11-分布式-summaries"><a href="#11-分布式-summaries" class="headerlink" title="11 分布式 summaries"></a>11 分布式 summaries</h1><p>&amp;emsp;&amp;emsp;分布式summaries用于跟踪事件的分布。它在结构上类似于计时器，但记录的值不代表时间单位。例如，分布式summary可用于衡量命中服务器的请求的有效负载大小。</p><p>&amp;emsp;&amp;emsp;要创建一个分布式summary：</p><pre><code>DistributionSummary summary = registry.summary(&quot;response.size&quot;);</code></pre><p>&amp;emsp;&amp;emsp;该接口包含一个流利的分布式summary构建器：</p><pre><code>DistributionSummary summary = DistributionSummary    .builder(&quot;response.size&quot;)    .description(&quot;a description of what this summary does&quot;) // optional    .baseUnit(&quot;bytes&quot;) // optional (1)    .tags(&quot;region&quot;, &quot;test&quot;) // optional    .scale(100) // optional (2)    .register(registry);</code></pre><p>&amp;emsp;&amp;emsp;1.添加基本​​单元以获得最大的可移植性-基本单元是某些监视系统的命名约定的一部分。如果忘记的话，将其保留下来并违反命名约定不会有任何不利影响。</p><p>&amp;emsp;&amp;emsp;2.可选的，我们可以提供一个比例因子，每个记录的样本在记录时将乘以该比例。</p><h2 id="11-1-标度和直方图"><a href="#11-1-标度和直方图" class="headerlink" title="11.1 标度和直方图"></a>11.1 标度和直方图</h2><p>&amp;emsp;&amp;emsp;MicroMeter的预选百分比直方图桶都是从1到最大long的整数。目前minimumExpectedValue和maximumExpectedValue用来控制桶的基数。如果我们尝试检测到您的最小&#x2F;最大值产生较小的范围并将预选的存储桶域缩放到summary的范围，则我们没有其他方法可以控制桶的基数。</p><p>&amp;emsp;&amp;emsp;相反，如果summary的域受到更多限制，则按固定因子缩放摘要的范围。到目前为止，我们所听到的用例是域为[0,1]的比率的汇总。然后：</p><pre><code>DistributionSummary.builder(&quot;my.ratio&quot;).scale(100).register(registry)</code></pre><p>&amp;emsp;&amp;emsp;这样，比率最终会在[0,100]的范围内，我们可以将其设置maximumExpectedValue为100。如果您关心特定的比率，则将其与自定义SLA边界配对：</p><pre><code>DistributionSummary.builder(&quot;my.ratio&quot;)   .scale(100)   .sla(70, 80, 90)   .register(registry)</code></pre><h2 id="11-2-内存占用估算"><a href="#11-2-内存占用估算" class="headerlink" title="11.2 内存占用估算"></a>11.2 内存占用估算</h2><p>&amp;emsp;&amp;emsp;分布式summary的总内存占用量可能会变化很大，具体取决于我们选择的选项。下表是基于各种功能使用情况的内存消耗表。这些数字假定没有标签，并且环形缓冲区的长度为3。添加标签当然会增加总数，增加缓冲区的长度也会有所增加。总存储量也可能会有所不同，具体取决于注册表的实现。</p><ul><li><p>R &#x3D;环形缓冲区的长度。在所有示例中，我们假定默认值为3。R用设置DistributionSummary.Builder#distributionStatisticBufferLength。</p></li><li><p>B &#x3D;总直方图桶。可以是SLA边界或百分比直方图桶。默认情况下，摘要没有最小和最大期望值，因此请装运所有276个预定的直方图桶。当您打算运送百分位直方图时，应始终使用minimumExpectedValue和来固定分布摘要maximumExpectedValue。</p></li><li><p>M &#x3D;最大衰减时间。104字节</p></li><li><p>Fb &#x3D;固定边界直方图。30b * B * R</p></li><li><p>Pp &#x3D;百分位数精度。默认情况下为1。通常在[0，3]范围内。Pp用设置DistributionSummary.Builder#percentilePrecision。</p></li><li><p>Hdr（Pp）&#x3D;高动态范围直方图。</p></li></ul><p>当Pp &#x3D; 0时：1.9kb * R + 0.8kb</p><p>当Pp &#x3D; 1时：3.8kb * R + 1.1kb</p><p>当Pp &#x3D; 2时：18.2kb * R + 4.7kb</p><p>当Pp &#x3D; 3时：66kb * R + 33kb</p><table><thead><tr><th align="center">客户端</th><th align="center">百分位数直方图和&#x2F;或SLA</th><th align="right">公式</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">NO</td><td align="center">NO</td><td align="right">M</td><td align="center">〜0.1kb</td></tr><tr><td align="center">NO</td><td align="center">YES</td><td align="right">M+Fb</td><td align="center">对于固定在66个桶中的百分位直方图，〜6kb</td></tr><tr><td align="center">YES</td><td align="center">YES</td><td align="right">M+Hdr(Pp)</td><td align="center">要添加默认值的0.95％，否则为〜12.6kb</td></tr></tbody></table><blockquote><p>注意</p><blockquote><p>这些估计是基于Micrometer1.0.3中所做的改进，并且假定至少使用该版本。</p></blockquote><p>注意</p><blockquote><p>特别是对于Prometheus ，无论您如何尝试通过DistributionSummary.Builder进行配置，R 始终等于1。这对于Prometheus来说是特殊情况，因为它期望的是永不翻转的累积直方图数据。</p></blockquote></blockquote><hr><h1 id="12-长任务timers"><a href="#12-长任务timers" class="headerlink" title="12.长任务timers"></a>12.长任务timers</h1><p>&amp;emsp;&amp;emsp;长任务timers是一种特殊的timer，可让我们在正在测量的事件仍在运行时测量时间。在任务完成之前，计时器不会持续记录时间。</p><p>&amp;emsp;&amp;emsp;现在考虑一个后台过程来刷新数据存储中的元数据。例如，Edda缓存AWS资源，例如实例、卷、自动扩展组等。通常，所有数据都可以在几分钟内刷新。如果AWS服务出现问题，则可能需要更长的时间。长任务timer可用于跟踪刷新元数据的总时间。</p><p>&amp;emsp;&amp;emsp;例如，在Spring应用程序中，通常使用来实现如此长时间运行的进程@Scheduled。MicroMeter提供了特殊的@Timed注释，用于使用长任务timer来可视化这些过程。</p><pre><code>@Timed(value = &quot;aws.scrape&quot;, longTask = true)@Scheduled(fixedDelay = 360000)void scrapeResources() &#123;// find instances, volumes, auto-scaling groups, etc...&#125;</code></pre><p>&amp;emsp;&amp;emsp;@Timed是否生效取决于应用程序框架。如果所选择的框架不支持它，我们仍然可以使用长任务计时器：</p><pre><code>LongTaskTimer scrapeTimer = registry.more().longTaskTimer(&quot;scrape&quot;);void scrapeResources() &#123;    scrapeTimer.record(() =&gt; &#123;        // find instances, volumes, auto-scaling groups, etc...    &#125;);&#125;</code></pre><p>&amp;emsp;&amp;emsp;如果我们想在此过程超过阈值时发出警报，则需要longtasktimer，超过阈值后，我们将在第一个报告间隔收到该警报。如果使用常规timer，则直到该过程完成后的第一个报告间隔（超过一个小时），我们才会收到警报！</p><p>&amp;emsp;&amp;emsp;该接口包含用于Longtasktimer的流利的构建器：</p><pre><code>LongTaskTimer longTaskTimer = LongTaskTimer    .builder(&quot;long.task.timer&quot;)    .description(&quot;a description of what this timer does&quot;) // optional    .tags(&quot;region&quot;, &quot;test&quot;) // optional    .register(registry);</code></pre><hr><h1 id="13-直方图和百分位数"><a href="#13-直方图和百分位数" class="headerlink" title="13 直方图和百分位数"></a>13 直方图和百分位数</h1><p>&amp;emsp;&amp;emsp;Timer和分布式summary支持收集数据以观察其百分比分布。查看百分位数的主要方法有两种：</p><p>&amp;emsp;&amp;emsp;1.百分比直方图 -MicroMeter将值累加为基础直方图，并将预定的一组buckets集合发送给监视系统。监视系统的查询语言负责计算此直方图的百分位数。目前，只有Prometheus，Atlas，和Wavefront支持直方图基于百分比近似，通过histogram_quantile，:percentile和hs()分别。如果定位到Prometheus，Atlas或Wavefront，则最好使用此方法，因为我们可以汇总各个维度上的直方图（通过简单地将一组维度中各个值的值相加）并从该直方图中得出可凝集的百分位数。</p><p>&amp;emsp;&amp;emsp;2.客户端百分位数 -MicroMeter为每个仪表ID（名称和标签集）计算百分位数近似值，并将百分位数值发送到监视系统。这不能像百分位数直方图那样灵活，因为不可能汇总标签之间的百分位数近似值。但是，它为不支持基于直方图的服务器端百分比计算的监视系统提供了一定百分比的洞察力。</p><p>&amp;emsp;&amp;emsp;这是一个使用直方图构建计时器的示例：</p><pre><code>Timer.builder(&quot;my.timer&quot;)   .publishPercentiles(0.5, 0.95) // median and 95th percentile   .publishPercentileHistogram()   .sla(Duration.ofMillis(100))   .minimumExpectedValue(Duration.ofMillis(1))   .maximumExpectedValue(Duration.ofSeconds(10))</code></pre><p>&amp;emsp;&amp;emsp;1.publishPercentiles-用于发布在我们的应用中计算出的百分位值。这些值在各个维度上都是不可凝聚的。</p><p>&amp;emsp;&amp;emsp;2.publishPercentileHistogram-用于发布直方图，该直方图适用于在Prometheus使用histogram_quantile，Atlas使用:percentile和Wavefront使用中计算可聚集的（跨维度）百分位近似hs()。对于Prometheus和Atlas，结果的直方图中的buckets值由MicroMeter根据由Netflix凭经验确定的生成器进行预设，以在大多数现实世界timer和分布式summary上产生合理的误差。默认情况下，生成器会产生276个存储桶，但Micrometer仅发送那些在设置范围内（包括minimumExpectedValue和maximumExpectedValue）的buckets值。MicroMeter默认将timer限制在1毫秒到1分钟的范围内，每个timer产生73个直方图桶。publishPercentileHistogram 对不支持可凝集百分位数逼近的系统没有影响-这些系统未提供直方图。</p><p>&amp;emsp;&amp;emsp;3.sla-发布包含我们SLA定义的buckets的累积直方图。与publishPercentileHistogram支持可聚集百分位数的监视系统配合使用，此设置将其他buckets添加到已发布的直方图中。在不支持可聚集百分位数的系统上使用时，此设置将导致仅使用这些存储桶发布直方图。</p><p>&amp;emsp;&amp;emsp;4.minimumExpectedValue&#x2F; maximumExpectedValue-控制publishPercentileHistogram发送的存储桶的数量，以及控制基础HdrHistogram结构的准确性和内存占用量。</p><p>&amp;emsp;&amp;emsp;由于将百分位数发送到监视系统会生成其他时间序列，因此通常最好不要在作为依赖项包含在应用程序中的核心库中对其进行配置。取而代之的是，应用程序可以通过meter过滤器为某些计时器&#x2F;分配摘要集启用此行为。</p><p>&amp;emsp;&amp;emsp;例如，假设我们在一个公共库中有几个计时器。我们为这些计时器名称添加了前缀myservice：</p><pre><code>registry.timer(&quot;myservice.http.requests&quot;).record(..);registry.timer(&quot;myservice.db.requests&quot;).record(..);</code></pre><p>&amp;emsp;&amp;emsp;我们可以通过仪表过滤器为两个timer打开客户端百分位数：</p><pre><code>registry.config().meterFilter(    new MeterFilter() &#123;        @Override        public DistributionStatisticConfig configure(Meter.Id id, DistributionStatisticConfig config) &#123;            if(id.getName().startsWith(&quot;myservice&quot;)) &#123;                return DistributionStatisticConfig.builder()                    .percentiles(0.95)                    .build()                    .merge(config);            &#125;            return config;        &#125;    &#125;);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;表格的语法&quot;&gt;&lt;a href=&quot;#表格的语法&quot; class=&quot;headerlink&quot; title=&quot;表格的语法&quot;&gt;&lt;/a&gt;表格的语法&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Tables&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;Are&lt;/
      
    
    </summary>
    
    
      <category term="Monitor System" scheme="http://yoursite.com/categories/Monitor-System/"/>
    
    
  </entry>
  
  <entry>
    <title>我的2020</title>
    <link href="http://yoursite.com/2021/01/09/%E6%88%91%E7%9A%842020/"/>
    <id>http://yoursite.com/2021/01/09/%E6%88%91%E7%9A%842020/</id>
    <published>2021-01-09T11:51:36.000Z</published>
    <updated>2021-01-09T12:18:27.090Z</updated>
    
    <content type="html"><![CDATA[<p>大学毕业后感觉生活就像按了快进键一样，现在让我回忆过去还是最容易想起毕业刚来北京那会儿，2020这一年就好像被偷走了一样，甚至觉得这份2020的总结有些多余……</p><p>这一年在学习方面算是有了些成长，看了好几本书，像《深入理解JVM虚拟机》、《算法》、《深入浅出Mysql》、《redis设计与实现》、《剑指offer》、以及刷了300道leetcode，这些东西让我对于编程开发有了一定的掌握，同时也为2021的秋招解决了很大一部分知识点，这从回京后找实习的结果还是能看出来效果的，一般公司的算法和基础知识都没有太大的问题。当然这是好的一面，但是也暴露出了很大的问题，实战经验非常不足，在一些框架的用法、现实问题的思考点与处理方式等都还很不足，百度的面试如同当头棒喝一般让人警醒；自己的基础知识储备还很不足，比如操作系统、计算机网络、数据库这些都只是一知半解，秋招的竞争对手是全国各个高校的人，想要跟他们竞争必须让自己多方面的知识丰满起来，所以在接下来的2021一定要有两个自己拿得出手的项目，同时要打牢基础，再准备一些足以让自己出彩的内容（暂定分布式相关知识）！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大学毕业后感觉生活就像按了快进键一样，现在让我回忆过去还是最容易想起毕业刚来北京那会儿，2020这一年就好像被偷走了一样，甚至觉得这份2020的总结有些多余……&lt;/p&gt;
&lt;p&gt;这一年在学习方面算是有了些成长，看了好几本书，像《深入理解JVM虚拟机》、《算法》、《深入浅出My
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>虚拟机设置桥接方式的实现方式</title>
    <link href="http://yoursite.com/2020/11/14/%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AE%BE%E7%BD%AE%E6%A1%A5%E6%8E%A5%E6%96%B9%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/11/14/%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AE%BE%E7%BD%AE%E6%A1%A5%E6%8E%A5%E6%96%B9%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</id>
    <published>2020-11-14T07:10:24.000Z</published>
    <updated>2020-11-14T08:38:32.498Z</updated>
    
    <content type="html"><![CDATA[<p>&amp;emsp;&amp;emsp;最近在学习elasticsearch,es是部署在centos虚拟机上的，我在虚拟机上起了es之后需要验证一些检索方式，可是我的宿主机连不通我的虚拟机，于是我就把虚拟机的网络连接方式改为了桥接模式，这篇文章主要是记录一下修改连接方式时的一些所学。</p><a id="more"></a><h2 id="一、虚拟机的网络连接方式"><a href="#一、虚拟机的网络连接方式" class="headerlink" title="一、虚拟机的网络连接方式"></a>一、虚拟机的网络连接方式</h2><p>&amp;emsp;&amp;emsp;vmware为我们提供了三种网络工作模式，它们分别是：<strong>Bridged（桥接模式）、NAT（网络地址转换模式）、Host-Only（仅主机模式）。</strong>下图中的VMnet0表示的是用于桥接模式下的虚拟交换机；VMnet1表示的是用于仅主机模式下的虚拟交换机；VMnet8表示的是用于NAT模式下的虚拟交换机。</p><p><img src="http://ww1.sinaimg.cn/large/006JSCholy1gkoqrepjbyj30j10i4mxo.jpg" alt="虚拟机网络连接方式"></p><h3 id="1-1桥接模式"><a href="#1-1桥接模式" class="headerlink" title="1.1桥接模式"></a>1.1桥接模式</h3><p>&amp;emsp;&amp;emsp;桥接模式就是将主机网卡与虚拟机虚拟的网卡利用虚拟网桥进行通信。在桥接的作用下，类似于把物理主机虚拟为一个交换机，所有桥接设置的虚拟机连接到这个交换机的一个接口上，物理主机也同样插在这个交换机当中，所以所有桥接下的网卡与网卡都是交换模式的，相互可以访问而不干扰。在桥接模式下，虚拟机ip地址需要与主机在同一个网段，如果需要联网，则网关与DNS需要与主机网卡一致。<br><img src="http://ww1.sinaimg.cn/large/006JSCholy1gkoraueurxj30ny0m1q8w.jpg" alt="桥接模式"></p><h3 id="1-2NAT模式"><a href="#1-2NAT模式" class="headerlink" title="1.2NAT模式"></a>1.2NAT模式</h3><p>&amp;emsp;&amp;emsp;NAT，是Network Address Translation的缩写，意即网络地址转换。NAT模式也是VMware创建虚拟机的默认网络连接模式。使用NAT模式网络连接时，VMware会在主机上建立单独的专用网络，用以在主机和虚拟机之间相互通信。虚拟机向外部网络发送的请求数据”包裹”，都会交由NAT网络适配器加上”特殊标记”并以主机的名义转发出去，外部网络返回的响应数据”包裹”，也是先由主机接收，然后交由NAT网络适配器根据”特殊标记”进行识别并转发给对应的虚拟机，因此，虚拟机在外部网络中不必具有自己的IP地址。从外部网络来看，虚拟机和主机在共享一个IP地址，默认情况下，外部网络终端也无法访问到虚拟机。</p><p>&amp;emsp;&amp;emsp;此外，在一台主机上只允许有一个NAT模式的虚拟网络。因此，同一台主机上的多个采用NAT模式网络连接的虚拟机也是可以相互访问的。</p><p>&amp;emsp;&amp;emsp;前面我们已经提到，默认情况下，外部网络无法访问到虚拟机，不过我们也可以通过手动修改NAT设置实现端口转发功能，将外部网络发送到主机指定端口的数据转发到指定的虚拟机上。比如，我们在虚拟机的80端口上”建立”了一个站点，只要我们设置端口转发，将主机88端口上的数据转发给虚拟机的80端口，就可以让外部网络通过主机的88端口访问到虚拟机80端口上的站点。</p><p><img src="http://ww1.sinaimg.cn/large/006JSCholy1gkos0y1m2bj30py0knwk0.jpg" alt="NAT模式"></p><h3 id="1-3-仅主机模式"><a href="#1-3-仅主机模式" class="headerlink" title="1.3 仅主机模式"></a>1.3 仅主机模式</h3><p>&amp;emsp;&amp;emsp;仅主机模式，是一种比NAT模式更加封闭的的网络连接模式，它将创建完全包含在主机中的专用网络。仅主机模式的虚拟网络适配器仅对主机可见，并在虚拟机和主机系统之间提供网络连接。相对于NAT模式而言，仅主机模式不具备NAT功能，因此在默认情况下，使用仅主机模式网络连接的虚拟机无法连接到Internet(在主机上安装合适的路由或代理软件，或者在Windows系统的主机上使用Internet连接共享功能，仍然可以让虚拟机连接到Internet或其他网络)。</p><p>&amp;emsp;&amp;emsp;在同一台主机上可以创建多个仅主机模式的虚拟网络，如果多个虚拟机处于同一个仅主机模式网络中，那么它们之间是可以相互通信的；如果它们处于不同的仅主机模式网络，则默认情况下无法进行相互通信(可通过在它们之间设置路由器来实现相互通信)。</p><h2 id="二、设置centos7为连接方式为桥接模式"><a href="#二、设置centos7为连接方式为桥接模式" class="headerlink" title="二、设置centos7为连接方式为桥接模式"></a>二、设置centos7为连接方式为桥接模式</h2><h3 id="2-1-设置vmware"><a href="#2-1-设置vmware" class="headerlink" title="2.1 设置vmware"></a>2.1 设置vmware</h3><h3 id="2-2-设置虚拟机"><a href="#2-2-设置虚拟机" class="headerlink" title="2.2 设置虚拟机"></a>2.2 设置虚拟机</h3><h2 id="三、ping协议总结"><a href="#三、ping协议总结" class="headerlink" title="三、ping协议总结"></a>三、ping协议总结</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;amp;emsp;&amp;amp;emsp;最近在学习elasticsearch,es是部署在centos虚拟机上的，我在虚拟机上起了es之后需要验证一些检索方式，可是我的宿主机连不通我的虚拟机，于是我就把虚拟机的网络连接方式改为了桥接模式，这篇文章主要是记录一下修改连接方式时的一些所学。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Lambda指令的JVM层面实现——invokeDynamic指令</title>
    <link href="http://yoursite.com/2020/11/06/Lambda%E6%8C%87%E4%BB%A4%E7%9A%84JVM%E5%B1%82%E9%9D%A2%E5%AE%9E%E7%8E%B0%E2%80%94%E2%80%94invokeDynamic%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2020/11/06/Lambda%E6%8C%87%E4%BB%A4%E7%9A%84JVM%E5%B1%82%E9%9D%A2%E5%AE%9E%E7%8E%B0%E2%80%94%E2%80%94invokeDynamic%E6%8C%87%E4%BB%A4/</id>
    <published>2020-11-06T08:44:07.000Z</published>
    <updated>2020-11-06T16:50:01.653Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="jvm" scheme="http://yoursite.com/categories/jvm/"/>
    
    
  </entry>
  
  <entry>
    <title>MicroMeter笔记</title>
    <link href="http://yoursite.com/2020/04/21/MrcroMeter%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/04/21/MrcroMeter%E7%AC%94%E8%AE%B0/</id>
    <published>2020-04-21T14:00:00.000Z</published>
    <updated>2022-05-04T08:07:26.834Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>应用通过micrometer采集和暴露监控端点给prometheus，prometheus通过pull模式来采集监控时序数据信息。之后作为数据源提供给grafana进行展示。</p><p>关于MicroMeterde的注册表，MicroMeter里面的Meters是从MeterRegistry中创建并保存在其中的，而且每一个监控系统都有他们自己的MeterRgistry实现，在我们的MicroMeter里面也有自带的SimpleMeterRegistry，所以我们在项目中导入了MicroMeter的依赖以后就可以生成一部分的指标了，但是这部分指标要能够被收集到注册表上才能到我们的监控系统上；所以就由我们的复合注册表，将其他的注册表添加到复合注册表就能被多个监控系统监控；还有全局注册表，这个也是个复合注册表，Metrics.addRegistry(xxxxx);基于此我们就可以使用Metrics.counter这种方式生成指标了；</p><p><img src="https://img2018.cnblogs.com/blog/285763/201812/285763-20181226164352509-830589043.png" alt="实现流程"></p><h2 id="怎么定义一个Metric？"><a href="#怎么定义一个Metric？" class="headerlink" title="怎么定义一个Metric？"></a>怎么定义一个Metric？</h2><p>基于上述我们能得到一个结论就是一个指标的生成方法就是———注册表.指标类型（name,tag{key},tag{value},……），我们的Metris.指标类型（name,tag{key},tag{value},……）也相当于是全局注册表在干这件事情；</p><h2 id="什么是meters？"><a href="#什么是meters？" class="headerlink" title="什么是meters？"></a>什么是meters？</h2><p>我觉得Meter与Timer，Counter，Gauge，DistributionSummary，LongTaskTimer，FunctionCounter，FunctionTimer，和TimeGauge<br>的关系就像是集合与Set、Map、List的关系一样，就是一个总分关系；</p><h2 id="怎么指定一些通用的标签？"><a href="#怎么指定一些通用的标签？" class="headerlink" title="怎么指定一些通用的标签？"></a>怎么指定一些通用的标签？</h2><p>可以在注册表级别上进行定义，定义的代码是：<br>registry.config().commonTags(“stack”, “prod”, “region”, “us-east-1”)</p><p>这样监控系统上每个metrics上面就能找到定义的这些标签了。</p><h2 id="什么是MeterFilter？"><a href="#什么是MeterFilter？" class="headerlink" title="什么是MeterFilter？"></a>什么是MeterFilter？</h2><p>MeterFilter主要有三个功能：</p><pre><code>1.拒绝（或接受）meter被注册。2.转换Meter的ID（例如，更改名称，添加或删除标签，更改描述或基本单位）。3.配置某些meter类型的分布统计信息。</code></pre><p>比如我们需要在注册表中忽略某个指标或者拒绝某个指标，下面即使通过编程的方式实现过滤信息：</p><p>registry.config()<br>.meterFilter(MeterFilter.ignoreTags(“too.much.information”))<br>.meterFilter(MeterFilter.denyNameStartsWith(“jvm”));</p><p>上面忽略了“too.much.information”这个指标，同时拒绝接受以jvm开头的指标，这个先知道有这些功能，具体的可以看翻译的<a href="https://blog.csdn.net/dongcheng_2015/article/details/103059035">博客MeterFilter部分</a></p><p>关于速率数据是怎么来的？<br>他的rate数据是来自于上一个时间间隔，例如下图数据<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93eDQuc2luYWltZy5jbi9tdzY5MC8wMDc4NTdOWWx5MWc4djhncXp4YzFqMzFjbTBmcGp0ci5qcGc?x-oss-process=image/format,png" alt="rate"></p><h2 id="关于Counter类型？"><a href="#关于Counter类型？" class="headerlink" title="关于Counter类型？"></a>关于Counter类型？</h2><p>Counter类型报告了一个指标–计数。<br>Counter类型指标的注册方法有两种：</p><pre><code>Counter counter = registry.counter(&quot;counter&quot;);Counter counter = Counter.builder(&quot;counter&quot;)                          .baseUnit(&quot;beans&quot;)//可选                         .description(&quot;a description of       what this counter does&quot;) //  optional                          .tags(&quot;region&quot;, &quot;test&quot;) // optional                          .register(registry);</code></pre><h2 id="关于Gauge类型"><a href="#关于Gauge类型" class="headerlink" title="关于Gauge类型"></a>关于Gauge类型</h2><p>Gauge是获取<strong>当前值</strong>的处理器，Gauge的典型示例是运行状态下的<strong>集合或映射的大小或线程数</strong>,Gauge的特点就是返回即时的数据，该MeterRegistry接口包含用于构建Gauge以观察数值、方法、、集合和映射的方法。</p><pre><code>List&lt;String&gt; list = registry.gauge(&quot;listGauge&quot;, Collections.emptyList(), new ArrayList&lt;&gt;(), List::size); (1)List&lt;String&gt; list2 = registry.gaugeCollectionSize(&quot;listSize2&quot;, Tags.empty(), new ArrayList&lt;&gt;()); (2)Map&lt;String, Integer&gt; map = registry.gaugeMapSize(&quot;mapGauge&quot;, Tags.empty(), new HashMap&lt;&gt;());</code></pre><p>Guage的构造方法：</p><pre><code>Gauge gauge = Gauge    .builder(&quot;gauge&quot;, myObj, myObj::gaugeValue)    .description(&quot;a description of what this gauge does&quot;) // optional    .tags(&quot;region&quot;, &quot;test&quot;) // optional    .register(registry);</code></pre><h2 id="Timer类型"><a href="#Timer类型" class="headerlink" title="Timer类型"></a>Timer类型</h2><p>Timer的构造方法：<br>    Timer timer &#x3D; Timer<br>        .builder(“my.timer”)<br>        .description(“a description of what this timer does”) &#x2F;&#x2F; optional<br>        .tags(“region”, “test”) &#x2F;&#x2F; optional<br>        .register(registry);</p><p>Timer相当于一个用于测量时间的DistributionSummary，所以要测量时间我们都直接使用Timer,而非DistributionSummary。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;



&lt;p&gt;应用通过micrometer采集和暴露监控端点给prometheus，prometheus通过pull模式来采集监控时序数据信息。之后作为数据源提供给grafana进行展示。&lt;/p&gt;
&lt;p&gt;关于MicroMeterde的注册表，Mi
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Springboot学习</title>
    <link href="http://yoursite.com/2019/11/16/Springboot%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/11/16/Springboot%E5%AD%A6%E4%B9%A0/</id>
    <published>2019-11-16T14:17:43.000Z</published>
    <updated>2020-11-06T06:28:39.726Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="PoatConstruct有什么作用"><a href="#PoatConstruct有什么作用" class="headerlink" title="@PoatConstruct有什么作用"></a>@PoatConstruct有什么作用</h2><p>PostConstruct注释用于在完成依赖项注入以执行任何初始化之后需要执行的方法。必须在类投入使用之前调用此方法。</p><!--more--><p>所有支持依赖注入的类都必须支持此注释。即使类没有请求注入任何资源，也必须调用使用PostConstruct注释的方法。</p><p>只有一个方法可以使用此批注进行批注。</p><p>应用PostConstruct注释的方法必须满足以下所有条件：除了拦截器之外，方法绝不能有任何参数，在这种情况下它采用Interceptor规范定义的InvocationContext对象。</p><p>在拦截器类上定义的方法必须具有以下签名之一：</p><p>void <METHOD>（InvocationContext）Object <METHOD>（InvocationContext）抛出异常注意：<br>PostConstruct拦截器方法不能抛出应用程序异常，但可以声明它抛出检查异常，包括java.lang.Exception，</p><p>如果相同的拦截器方法除了生命周期事件之外插入业务或超时方法。</p><p>如果PostConstruct拦截器方法返回一个值，容器将忽略它。</p><p>在非拦截器类上定义的方法必须具有以下签名：void <METHOD>（）应用PostConstruct的方法可以是public，protected，package private或private。</p><p>除应用程序客户端外，该方法绝不能是静态的。</p><p>该方法可能是最终的。如果该方法抛出一个未经检查的异常，那么该类绝不能投入使用，除非EJB可以处理异常甚至从它们恢复的EJB。</p><h3 id="构造方法-gt-Autowired-gt-PostConstruct"><a href="#构造方法-gt-Autowired-gt-PostConstruct" class="headerlink" title="构造方法 &gt; @Autowired &gt; @PostConstruct"></a>构造方法 &gt; @Autowired &gt; @PostConstruct</h3><p>1、从Java EE5规范开始，Servlet中增加了两个影响Servlet生命周期的注解，@PostConstruct和@PreDestroy，这两个注解被用来修饰一个非静态的void（）方法。写法有如下两种方式：</p><p>@PostConstruct</p><p>public void someMethod(){}</p><p>或者</p><p>public @PostConstruct void someMethod(){}</p><p>被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器执行一次。PostConstruct在构造函数之后执行，init（）方法之前执行。PreDestroy（）方法在destroy（）方法知性之后执行</p><p>执行顺序</p><h4 id="另外，spring中Constructor、-Autowired、-PostConstruct的顺序"><a href="#另外，spring中Constructor、-Autowired、-PostConstruct的顺序" class="headerlink" title="另外，spring中Constructor、@Autowired、@PostConstruct的顺序"></a>另外，spring中Constructor、@Autowired、@PostConstruct的顺序</h4><h4 id="其实从依赖注入的字面意思就可以知道，要将对象p注入到对象a，那么首先就必须得生成对象a和对象p，才能执行注入。所以，如果一个类A中有个成员变量p被-Autowried注解，那么-Autowired注入是发生在A的构造方法执行完之后的。"><a href="#其实从依赖注入的字面意思就可以知道，要将对象p注入到对象a，那么首先就必须得生成对象a和对象p，才能执行注入。所以，如果一个类A中有个成员变量p被-Autowried注解，那么-Autowired注入是发生在A的构造方法执行完之后的。" class="headerlink" title="其实从依赖注入的字面意思就可以知道，要将对象p注入到对象a，那么首先就必须得生成对象a和对象p，才能执行注入。所以，如果一个类A中有个成员变量p被@Autowried注解，那么@Autowired注入是发生在A的构造方法执行完之后的。"></a>其实从依赖注入的字面意思就可以知道，要将对象p注入到对象a，那么首先就必须得生成对象a和对象p，才能执行注入。所以，如果一个类A中有个成员变量p被@Autowried注解，那么@Autowired注入是发生在A的构造方法执行完之后的。</h4><h4 id="如果想在生成对象时完成某些初始化操作，而偏偏这些初始化操作又依赖于依赖注入，那么久无法在构造函数中实现。为此，可以使用-PostConstruct注解一个方法来完成初始化，-PostConstruct注解的方法将会在依赖注入完成后被自动调用。"><a href="#如果想在生成对象时完成某些初始化操作，而偏偏这些初始化操作又依赖于依赖注入，那么久无法在构造函数中实现。为此，可以使用-PostConstruct注解一个方法来完成初始化，-PostConstruct注解的方法将会在依赖注入完成后被自动调用。" class="headerlink" title="如果想在生成对象时完成某些初始化操作，而偏偏这些初始化操作又依赖于依赖注入，那么久无法在构造函数中实现。为此，可以使用@PostConstruct注解一个方法来完成初始化，@PostConstruct注解的方法将会在依赖注入完成后被自动调用。"></a>如果想在生成对象时完成某些初始化操作，而偏偏这些初始化操作又依赖于依赖注入，那么久无法在构造函数中实现。为此，可以使用@PostConstruct注解一个方法来完成初始化，@PostConstruct注解的方法将会在依赖注入完成后被自动调用。</h4><h4 id="Constructor-gt-gt-Autowired-gt-gt-PostConstruct"><a href="#Constructor-gt-gt-Autowired-gt-gt-PostConstruct" class="headerlink" title="Constructor &gt;&gt; @Autowired &gt;&gt; @PostConstruct"></a>Constructor &gt;&gt; @Autowired &gt;&gt; @PostConstruct</h4><hr><h2 id="Aspect的作用是什么？"><a href="#Aspect的作用是什么？" class="headerlink" title="@Aspect的作用是什么？"></a>@Aspect的作用是什么？</h2><p>AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术.AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p><p>在spring AOP中业务逻辑仅仅只关注业务本身，将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改变这些行为的时候不影响业务逻辑的代码。</p><pre><code>@Aspect:作用是把当前类标识为一个切面供容器读取 @Pointcut：Pointcut是植入Advice的触发条件。每个Pointcut的定义包括2部分，一是表达式，二是方法签名。方法签名必须是 public及void型。可以将Pointcut中的方法看作是一个被Advice引用的助记符，因为表达式不直观，因此我们可以通过方法签名的方式为 此表达式命名。因此Pointcut中的方法只需要方法签名，而不需要在方法体内编写实际代码。@Around：环绕增强，相当于MethodInterceptor@AfterReturning：后置增强，相当于AfterReturningAdvice，方法正常退出时执行@Before：标识一个前置增强方法，相当于BeforeAdvice的功能，相似功能的还有@AfterThrowing：异常抛出增强，相当于ThrowsAdvice@After: final增强，不管是抛出异常或者正常退出都会执行</code></pre><p>Spring AOP面向切面编程，可以用来配置事务、做日志、权限验证、在用户请求时做一些处理等等。用@Aspect做一个切面，就可以直接实现。</p><p>1.首先定义一个切面类，加上@Component  @Aspect这两个注解   </p><pre><code>@Component@Aspectpublic class LogAspect &#123;private static final Logger logger = LoggerFactory.getLogger(LogAspect.class);private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();&#125;</code></pre><p>2.定义切点     </p><pre><code>private final String POINT_CUT = &quot;execution(public * com.xhx.springboot.controller.*.*(..))&quot;;@Pointcut(POINT_CUT)public void pointCut()&#123;&#125;</code></pre><p>切点表达式中，..两个点表明多个，<em>代表一个，  上面表达式代表切入com.xhx.springboot.controller包下的所有类的所有方法，方法参数不限，返回类型不限。  其中访问修饰符可以不写，不能用</em>，，第一个<em>代表返回类型不限，第二个</em>表示所有类，第三个*表示所有方法，..两个点表示方法里的参数不限。  然后用@Pointcut切点注解，想在一个空方法上面，一会儿在Advice通知中，直接调用这个空方法就行了，也可以把切点表达式卸载Advice通知中的，单独定义出来主要是为了好管理。</p><p>3.Advice，通知增强，主要包括五个注解Before,After,AfterReturning,AfterThrowing,Around，下面代码中关键地方都有注释，我都列出来了。</p><pre><code>@Before  在切点方法之前执行@After  在切点方法之后执行@AfterReturning 切点方法返回后执行@AfterThrowing 切点方法抛异常执行@Around 属于环绕增强，能控制切点执行前，执行后，，用这个注解后，程序抛异常，会影响@AfterThrowing这个注解</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h2 id=&quot;PoatConstruct有什么作用&quot;&gt;&lt;a href=&quot;#PoatConstruct有什么作用&quot; class=&quot;headerlink&quot; title=&quot;@PoatConstruct有什么作用&quot;&gt;&lt;/a&gt;@PoatConstru
      
    
    </summary>
    
    
      <category term="springboot" scheme="http://yoursite.com/categories/springboot/"/>
    
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://yoursite.com/2019/11/15/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/11/15/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2019-11-15T12:01:15.000Z</published>
    <updated>2020-11-06T06:30:12.609Z</updated>
    
    <content type="html"><![CDATA[<p>&amp;emsp;正则是一个非常重要的知识点，我在数据库、前端设计、爬虫等中都看到过很多，但是自己没有去刻意学习，每次都是自己去网上搜，今天就建立自己的正则库，方便自己以后翻阅，同时也用于把自己平时见到的一些巧妙的正则表达式往里面塞一塞。</p><a id="more"></a><h3 id="一、什么是正则表达式？"><a href="#一、什么是正则表达式？" class="headerlink" title="一、什么是正则表达式？"></a>一、什么是正则表达式？</h3><p>&amp;emsp;&amp;emsp;正则表达式，又称规则表达式，通常被用来检索、替换那些符合某个模式(规则)的文本。正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。</p><h3 id="二、正则能干嘛？"><a href="#二、正则能干嘛？" class="headerlink" title="二、正则能干嘛？"></a>二、正则能干嘛？</h3><ul><li><p>一是给定的字符串是否符合正则表达式的过滤逻辑（这个过程可称为“匹配”）；</p></li><li><p>二是通过正则表达式，从文本字符串中获取我们想要的特定部分（这个过程可称为“过滤”）。</p></li></ul><h3 id="三正表达式的语法"><a href="#三正表达式的语法" class="headerlink" title="三正表达式的语法"></a>三正表达式的语法</h3><pre><code>^  表示匹配字符串的开始位置  (例外  用在中括号中[ ] 时,可以理解为取反,表示不匹配括号中字符串)$  表示匹配字符串的结束位置*  表示匹配 零次到多次+  表示匹配 一次到多次 (至少有一次)?  表示匹配零次或一次.  表示匹配单个字符 |  表示为或者,两项中取一项(  ) 小括号表示匹配括号中全部字符[  ] 中括号表示匹配括号中一个字符 范围描述 如[0-9 a-z A-Z]&#123;  &#125; 大括号用于限定匹配次数  如 &#123;n&#125;表示匹配n个字符  &#123;n,&#125;表示至少匹配n个字符  &#123;n,m&#125;表示至少n,最多m\  转义字符 如上基本符号匹配都需要转义字符   如 \*  表示匹配*号\w 表示英文字母和数字\W  非字母和数字\d  表示数字\D  非数字</code></pre><h3 id="四、常用的正则表达式"><a href="#四、常用的正则表达式" class="headerlink" title="四、常用的正则表达式"></a>四、常用的正则表达式</h3><p>常用的正则表达式(转)<br>匹配中文字符的正则表达式： <code>[\u4e00-\u9fa5]</code></p><p>匹配双字节字符(包括汉字在内)：<code>[^\x00-\xff]</code></p><p>匹配空行的正则表达式：<code>\n[\s| ]*\r</code></p><p>匹配HTML标记的正则表达式：<code>/&lt;(.*)&gt;.*&lt;\/\1&gt;|&lt;(.*) \/&gt;/</code> </p><p>匹配首尾空格的正则表达式：<code>(^\s*)|(\s*$)</code></p><p>匹配IP地址的正则表达式：<code>/(\d+)\.(\d+)\.(\d+)\.(\d+)/g //</code></p><p>匹配Email地址的正则表达式：<code>\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*</code></p><p>匹配网址URL的正则表达式：<code>http://(/[\w-]+\.)+[\w-]+(/[\w- ./?%&amp;=]*)?</code></p><p>sql语句：<code>^(select|drop|delete|create|update|insert).*$</code></p><p>1、非负整数：<code>^\d+$ </code></p><p>2、正整数：<code>^[0-9]*[1-9][0-9]*$ </code></p><p>3、非正整数：<code>^((-\d+)|(0+))$ </code></p><p>4、负整数：<code>^-[0-9]*[1-9][0-9]*$</code> </p><p>5、整数：<code>^-?\d+$</code> </p><p>6、非负浮点数：<code>^\d+(\.\d+)?$ </code></p><p>7、正浮点数：<code>^((0-9)+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$ </code></p><p>8、非正浮点数：<code>^((-\d+\.\d+)?)|(0+(\.0+)?))$ </code></p><p>9、负浮点数：<code>^(-((正浮点数正则式)))$ </code></p><p>10、英文字符串：<code>^[A-Za-z]+$</code> </p><p>11、英文大写串：<code>^[A-Z]+$</code> </p><p>12、英文小写串：<code>^[a-z]+$</code> </p><p>13、英文字符数字串：<code>^[A-Za-z0-9]+$ </code></p><p>14、英数字加下划线串：<code>^\w+$ </code></p><p>15、E-mail地址：<code>^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$ </code></p><p>16、URL：<code>^[a-zA-Z]+://(\w+(-\w+)*)(\.(\w+(-\w+)*))*(\?\s*)?$</code><br>或：<code>^http:\/\/[A-Za-z0-9]+\.[A-Za-z0-9]+[\/=\?%\-&amp;_~</code>@[]&#39;:+!]<em>([^&lt;&gt;&quot;&quot;])</em>$&#96;</p><p>17、邮政编码：<code>^[1-9]\d&#123;5&#125;$</code></p><p>18、中文：<code>^[\u0391-\uFFE5]+$</code></p><p>19、电话号码：<code>^((\d2,3)|(\d&#123;3&#125;\-))?(0\d2,3|0\d&#123;2,3&#125;-)?[1-9]\d&#123;6,7&#125;(\-\d&#123;1,4&#125;)?$</code></p><p>20、手机号码：<code>^((\d2,3)|(\d&#123;3&#125;\-))?13\d&#123;9&#125;$</code></p><p>21、双字节字符(包括汉字在内)：<code>^\x00-\xff</code></p><p>22、匹配首尾空格：<code>(^\s*)|(\s*$)</code>（像vbscript那样的trim函数）</p><p>23、匹配HTML标记：<code>&lt;(.*)&gt;.*&lt;\/\1&gt;|&lt;(.*) \/&gt; </code></p><p>24、匹配空行：<code>\n[\s| ]*\r</code></p><p>25、提取信息中的网络链接：<code>(h|H)(r|R)(e|E)(f|F) *= *(&#39;|&quot;)?(\w|\\|\/|\.)+(&#39;|&quot;| *|&gt;)?</code></p><p>26、提取信息中的邮件地址：<code>\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*</code></p><p>27、提取信息中的图片链接：<code>(s|S)(r|R)(c|C) *= *(&#39;|&quot;)?(\w|\\|\/|\.)+(&#39;|&quot;| *|&gt;)?</code></p><p>28、提取信息中的IP地址：<code>(\d+)\.(\d+)\.(\d+)\.(\d+)</code></p><p>29、提取信息中的中国手机号码：<code>(86)*0*13\d&#123;9&#125;</code></p><p>30、提取信息中的中国固定电话号码：<code>(\d3,4|\d&#123;3,4&#125;-|\s)?\d&#123;8&#125;</code></p><p>31、提取信息中的中国电话号码（包括移动和固定电话）：<code>(\d3,4|\d&#123;3,4&#125;-|\s)?\d&#123;7,14&#125;</code></p><p>32、提取信息中的中国邮政编码：<code>[1-9]&#123;1&#125;(\d+)&#123;5&#125;</code></p><p>33、提取信息中的浮点数（即小数）：<code>(-?\d*)\.?\d+</code></p><p>34、提取信息中的任何数字 ：<code>(-?\d*)(\.\d+)?</code> </p><p>35、IP：<code>(\d+)\.(\d+)\.(\d+)\.(\d+)</code></p><p>36、电话区号：<code>/^0\d&#123;2,3&#125;$/</code></p><p>37、腾讯QQ号：<code>^[1-9]*[1-9][0-9]*$</code></p><p>38、帐号(字母开头，允许5-16字节，允许字母数字下划线)：<code>^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$</code></p><p>39、中文、英文、数字及下划线：<code>^[\u4e00-\u9fa5_a-zA-Z0-9]+$</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;amp;emsp;正则是一个非常重要的知识点，我在数据库、前端设计、爬虫等中都看到过很多，但是自己没有去刻意学习，每次都是自己去网上搜，今天就建立自己的正则库，方便自己以后翻阅，同时也用于把自己平时见到的一些巧妙的正则表达式往里面塞一塞。&lt;/p&gt;
    
    </summary>
    
    
      <category term="爬虫" scheme="http://yoursite.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>springboot2——Metrics</title>
    <link href="http://yoursite.com/2019/11/13/springboot2%E2%80%94%E2%80%94Metrics/"/>
    <id>http://yoursite.com/2019/11/13/springboot2%E2%80%94%E2%80%94Metrics/</id>
    <published>2019-11-13T12:49:11.000Z</published>
    <updated>2020-11-06T06:20:22.374Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="Metrics"><a href="#Metrics" class="headerlink" title="Metrics"></a>Metrics</h1><p>&amp;emsp;&amp;emsp;Spring Boot Actuator为Micrometer提供了依赖项管理和自动配置，Micrometer是一种支持大量监视系统的应用程序指标展示，包括：AppOptics、Atlas、Datadog、Dynatrace、Elastic、Ganglia、Graphite、Humio、Influx、JMX、KairosDB、New Relic、Prometheus、SignalFx、Simple (in-memory)、StatsD、Wavefront。</p><p>&amp;emsp;&amp;emsp;要了解有关Micrometer功能的更多信息，请参阅其参考文档，特别是<a href="https://dongonns.github.io/2019/11/12/MicroMeter%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/">概念</a>部分。</p><hr><h2 id="1-入门"><a href="#1-入门" class="headerlink" title="1 入门"></a>1 入门</h2><p>&amp;emsp;&amp;emsp;Spring Boot自动配置组合MeterRegistry，并为其在类路径上找到的每个支持的实现向组合添加注册表。在micrometer-registry-{system}运行时类路径中具有依赖项足以让Spring Boot配置注册表。</p><p>&amp;emsp;&amp;emsp;大多数注册表具有共同的特征。例如，即使Micrometer注册表实现位于类路径中，您也可以禁用特定的注册表。例如，禁用Datadog：</p><pre><code>management.metrics.export.datadog.enabled=false</code></pre><p>&amp;emsp;&amp;emsp;Spring Boot还会将任何自动配置的注册表添加到Metrics该类的全局静态复合注册表中，除非您明确告诉它不要：</p><pre><code>management.metrics.use-global-registry=false</code></pre><p>&amp;emsp;&amp;emsp;您可以注册任意数量的MeterRegistryCustomizerbean来进一步配置注册表，例如在向注册表注册任何计量器(meter)之前应用通用标签：</p><pre><code>@BeanMeterRegistryCustomizer&lt;MeterRegistry&gt; metricsCommonTags() &#123;    return registry -&gt; registry.config().commonTags(&quot;region&quot;, &quot;us-east-1&quot;);&#125;</code></pre><p>&amp;emsp;&amp;emsp;您可以通过更具体地了解通用类型，将自定义项应用于特定的注册表实现：</p><pre><code>@BeanMeterRegistryCustomizer&lt;GraphiteMeterRegistry&gt; graphiteMetricsNamingConvention() &#123;    return registry -&gt; registry.config().namingConvention(MY_CUSTOM_CONVENTION);&#125;</code></pre><p>&amp;emsp;&amp;emsp;完成该设置后，您可以注入MeterRegistry组件并注册指标：</p><pre><code>@Componentpublic class SampleBean &#123;    private final Counter counter;    public SampleBean(MeterRegistry registry) &#123;        this.counter = registry.counter(&quot;received.messages&quot;);&#125;public void handleMessage(String message) &#123;    this.counter.increment();    // handle message implementation    &#125;&#125;</code></pre><p>&amp;emsp;&amp;emsp;Spring Boot还配置了<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#production-ready-metrics-meter">内置工具</a>（即MeterBinder实现），您可以通过配置或专用注释标记来控制它们。</p><h2 id="2-支持的监控系统–Prometheus"><a href="#2-支持的监控系统–Prometheus" class="headerlink" title="2 支持的监控系统–Prometheus"></a>2 支持的监控系统–Prometheus</h2><p>&amp;emsp;&amp;emsp;Prometheus希望抓取或轮询单个应用程序实例以获取指标。Spring Boot提供了一个可用的执行器端点&#x2F;actuator&#x2F;prometheus以适当的格式显示Prometheus抓取。</p><p>&amp;emsp;&amp;emsp;端点默认情况下不可用，必须公开，有关更多详细信息，请参见<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#production-ready-endpoints-exposing-endpoints">暴露端点</a>。</p><p>&amp;emsp;&amp;emsp;这是scrape_config要添加到的示例prometheus.yml：</p><pre><code>scrape_configs:  - job_name: &#39;spring&#39;    metrics_path: &#39;/actuator/prometheus&#39;    static_configs:  - targets: [&#39;HOST:PORT&#39;]</code></pre><p>&amp;emsp;&amp;emsp;对于短暂的或批处理的工作，其时间可能不够长，无法被抓取，可以使用Prometheus Pushgateway支持将其指标暴露给Prometheus。要启用Prometheus Pushgateway支持，请在项目中添加以下依赖项：</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;io.prometheus&lt;/groupId&gt;    &lt;artifactId&gt;simpleclient_pushgateway&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>&amp;emsp;&amp;emsp;当在类路径中存在Prometheus Pushgateway依赖项时，Spring Boot会自动配置PrometheusPushGatewayManager组件。这可以管理将指标推送到Prometheus Pushgateway。PrometheusPushGatewayManager可以在使用属性management.metrics.export.prometheus.pushgateway配置。对于高级配置，您还可以提供自己的PrometheusPushGatewayManager组件。</p><h2 id="3-支持的指标"><a href="#3-支持的指标" class="headerlink" title="3 支持的指标"></a>3 支持的指标</h2><p>&amp;emsp;&amp;emsp;如果适用，Spring Boot将注册以下核心指标：</p><ul><li>JVM指标，报告以下各项的利用率：</li></ul><p>&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;各种内存和缓冲池</p><p>&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;与垃圾收集有关的统计数据</p><p>&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;线程利用率</p><p>&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;加载&#x2F;卸载的类数</p><ul><li><p>CPU指标</p></li><li><p>文件描述符指标</p></li><li><p>卡夫卡消耗指标</p></li><li><p>Log4j2指标：记录每个级别记录到Log4j2的事件数</p></li><li><p>Logback指标：记录每个级别记录到Logback的事件数</p></li><li><p>正常运行时间指标：报告正常运行时间的量度和代表应用程序绝对启动时间的固定量度</p></li><li><p>Tomcat指标（server.tomcat.mbeanregistry.enabled必须设置true为才能注册所有Tomcat指标）</p></li><li><p><a href="https://docs.spring.io/spring-integration/docs/5.2.1.RELEASE/reference/html/system-management.html#micrometer-integration">Spring集成指标</a></p></li></ul><h3 id="Spring-MVC指标"><a href="#Spring-MVC指标" class="headerlink" title="Spring MVC指标"></a>Spring MVC指标</h3><p>&amp;emsp;&amp;emsp;通过自动配置，可以检测由Spring MVC处理的请求。当management.metrics.web.server.request.autotime.enabled为true时，将对所有请求进行这种检测。或者，当设置为false时，可以通过添加@Timed到请求处理方法来启用检测：</p><pre><code>@RestController@Timed public class MyController &#123;    @GetMapping(&quot;/api/people&quot;)    @Timed(extraTags = &#123; &quot;region&quot;, &quot;us-east-1&quot; &#125;)     @Timed(value = &quot;all.people&quot;, longTask = true)     public List&lt;Person&gt; listPeople() &#123; ... &#125;&#125;</code></pre><p>&amp;emsp;&amp;emsp;1.控制器类，用于对控制器中的每个请求处理程序启用计时。</p><p>&amp;emsp;&amp;emsp;2.一种启用单个端点的方法。如果您将它放在类中，则不必这样做，但是可以用于进一步为此特定端点自定义timer计时器。</p><p>&amp;emsp;&amp;emsp;3.一种longTask &#x3D; true用于为该方法启用长任务计时器的方法。长任务计时器需要一个单独的度量metric名称，并且可以与短任务计时器堆叠在一起。</p><p>&amp;emsp;&amp;emsp;默认情况下，指标名称为http.server.requests。可以通过设置management.metrics.web.server.request.metric-name属性来自定义名称。</p><p>&amp;emsp;&amp;emsp;默认情况下，与Spring MVC相关的指标带有以下信息标记：</p><table><thead><tr><th align="center">标签</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">exception</td><td align="center">处理请求时引发的任何异常的简单类名。</td></tr><tr><td align="center">method</td><td align="center">请求的方法（例如GET或POST）</td></tr><tr><td align="center">outcome</td><td align="center">基于响应状态码的请求结果。1xx是INFORMATIONAL，2xx是SUCCESS，3xx是REDIRECTION，4xx CLIENT_ERROR和5xx是SERVER_ERROR</td></tr><tr><td align="center">status</td><td align="center">响应的HTTP状态代码（例如200或500）</td></tr><tr><td align="center">uri</td><td align="center">变量替换之前的请求URI模板（如果可能）（例如，&#x2F;api&#x2F;person&#x2F;{id}）</td></tr></tbody></table><p>&amp;emsp;&amp;emsp;要自定义标签，请提供@Bean实现的WebMvcTagsProvider。</p><h2 id="HTTP客户端指标"><a href="#HTTP客户端指标" class="headerlink" title="HTTP客户端指标"></a>HTTP客户端指标</h2><p>&amp;emsp;&amp;emsp;启动器同时管理仪表RestTemplate和WebClient。为此，您必须注入自动配置的构建器并使用它来创建实例：</p><ul><li><p>RestTemplateBuilder 对于 RestTemplate</p></li><li><p>WebClient.Builder 对于 WebClient</p></li></ul><p>&amp;emsp;&amp;emsp;也可以手动应用负责此工具的定制程序，即MetricsRestTemplateCustomizer和MetricsWebClientCustomizer。</p><p>&amp;emsp;&amp;emsp;默认情况下，指标名称为http.client.requests。可以通过设置management.metrics.web.client.request.metric-name属性来自定义名称。</p><p>&amp;emsp;&amp;emsp;默认情况下，通过检测的客户端生成的指标会标记以下信息：</p><table><thead><tr><th align="center">标签</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">clientName</td><td align="center">URI的主机部分</td></tr><tr><td align="center">method</td><td align="center">请求的方法（例如GET或POST）</td></tr><tr><td align="center">outcome</td><td align="center">基于响应状态码的请求结果。1xx是INFORMATIONAL，2xx是SUCCESS，3xx是REDIRECTION，4xx CLIENT_ERROR和5xx是SERVER_ERROR，否则UNKNOWN</td></tr><tr><td align="center">status</td><td align="center">响应的HTTP状态代码（例如200或500）（IO_ERROR如果存在I &#x2F; O问题），否则CLIENT_ERROR</td></tr><tr><td align="center">uri</td><td align="center">变量替换之前的请求URI模板（如果可能）（例如，&#x2F;api&#x2F;person&#x2F;{id}）</td></tr></tbody></table><p>&amp;emsp;&amp;emsp;要自定义标签，并根据您选择的客户端，可以提供@Bean实现RestTemplateExchangeTagsProvider或WebClientExchangeTagsProvider。RestTemplateExchangeTags和WebClientExchangeTags中有方便的静态函数。</p><h3 id="缓存指标"><a href="#缓存指标" class="headerlink" title="缓存指标"></a>缓存指标</h3><p>&amp;emsp;&amp;emsp;通过自动配置可以在启动时使用前缀为Cache的指标来检测所有可用的cache。对于解百纳的cache信息是进行了标准化设置的。此外定制的cache指标也是可用的。</p><p>&amp;emsp;&amp;emsp;支持以下缓存库：</p><ul><li><p>Caffeine</p></li><li><p>EhCache 2</p></li><li><p>Hazelcast</p></li><li><p>Any compliant JCache (JSR-107) 的实现</p></li></ul><p>&amp;emsp;&amp;emsp;指标由cache的名称以及CacheManager从Bean名称派生的的名称标记(添加tag)。</p><p>&amp;emsp;&amp;emsp;只有启动时可用的缓存才绑定到注册表。对于在启动阶段后即时或以编程方式创建的缓存，需要显式注册。可以使用CacheMetricsRegistrarBean来简化该过程。</p><h3 id="数据源指标"><a href="#数据源指标" class="headerlink" title="数据源指标"></a>数据源指标</h3><p>&amp;emsp;&amp;emsp;自动配置可使前缀为jdbc.connections的metric指标的所有DataSource对象可视化。数据源检测产生的gauge表示池中当前活动，空闲，最大允许和最小允许的连接。</p><p>&amp;emsp;&amp;emsp;metrics还通过DataSource基于bean名称的计算名称来标记（添加tag）。</p><p>&amp;emsp;&amp;emsp;默认情况下，Spring Boot为所有支持的数据源提供元数据。如果您喜欢的数据源不支持开箱即用，则可以添加其他DataSourcePoolMetadataProvider组件。请参阅DataSourcePoolMetadataProvidersConfiguration示例。</p><p>&amp;emsp;&amp;emsp;此外，Hikari特定指标带有hikaricp前缀。每个度量标准都以“池”的名称标记（可以通过来控制spring.datasource.name）。</p><h2 id="4-注册自定义指标"><a href="#4-注册自定义指标" class="headerlink" title="4 注册自定义指标"></a>4 注册自定义指标</h2><p>&amp;emsp;&amp;emsp;要注册自定义指标，请插入MeterRegistry到您的组件中，如以下示例所示：</p><pre><code>class Dictionary &#123;    private final List&lt;String&gt; words = new CopyOnWriteArrayList&lt;&gt;();    Dictionary(MeterRegistry registry) &#123;        registry.gaugeCollectionSize(&quot;dictionary.size&quot;, Tags.empty(), this.words);    &#125;    // …&#125;</code></pre><p>&amp;emsp;&amp;emsp;如果发现您反复在组件或应用程序中检测一组metrics，则可以将此组metrics封装在MeterBinder实现中。默认情况下，所有MeterBinderbean的metrics都将自动绑定到Spring-managed MeterRegistry。</p><h2 id="5-自定义单个指标"><a href="#5-自定义单个指标" class="headerlink" title="5 自定义单个指标"></a>5 自定义单个指标</h2><p>&amp;emsp;&amp;emsp;如果需要将自定义应用于特定Meter实例，则可以使用该io.micrometer.core.instrument.config.MeterFilter接口。默认情况下，所有MeterFilter组件都会自动应用于MicroMeter的MeterRegistry.Config。</p><p>&amp;emsp;&amp;emsp;例如，如果要将所有仪表ID中以com.example开头的mytag.region标签重命名为mytag.area，则可以执行以下操作：</p><pre><code>@Beanpublic MeterFilter renameRegionTagMeterFilter() &#123;    return MeterFilter.renameTag(&quot;com.example&quot;, &quot;mytag.region&quot;, &quot;mytag.area&quot;);&#125;</code></pre><h3 id="通用标签"><a href="#通用标签" class="headerlink" title="通用标签"></a>通用标签</h3><p>&amp;emsp;&amp;emsp;通用标签通常用于在操作环境，如主机，实例，区域，堆栈等，进行维度深入分析。通用标签适用于所有仪表，并可以按以下示例所示进行配置：</p><pre><code>management.metrics.tags.region=us-east-1management.metrics.tags.stack=prod</code></pre><p>&amp;emsp;&amp;emsp;上面的示例将us-east-1和prod分别添加到region和stack到所有仪表。</p><p>如果使用Graphite，则常用标签的顺序很重要。由于使用这种方法不能保证通用标签的顺序，因此建议Graphite用户定义一个自定义MeterFilter。</p><h3 id="Per-meter属性"><a href="#Per-meter属性" class="headerlink" title="Per-meter属性"></a>Per-meter属性</h3><p>Per-meter适用于以给定名称开头的所有meter ID。例如，以下将禁用所有ID以example.remote开头的meter。</p><pre><code>management.metrics.enable.example.remote=false</code></pre><p>&amp;emsp;&amp;emsp;以下属性允许per-meter自定义：</p><p>表8.per-meter自定义</p><table><thead><tr><th align="center">属性</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">management.metrics.enable</td><td align="center">是否拒绝仪表发出任何指标</td></tr><tr><td align="center">management.metrics.distribution.percentiles-histogram</td><td align="center">是否发布适合于计算可凝集（跨维度）百分位数逼近的直方图</td></tr><tr><td align="center">management.metrics.distribution.minimum-expected-value，management.metrics.distribution.maximum-expected-value</td><td align="center">通过限制期望值的范围来发布较少的直方图bucket</td></tr><tr><td align="center">management.metrics.distribution.percentiles</td><td align="center">发布在应用程序中计算的百分位值</td></tr><tr><td align="center">management.metrics.distribution.sla</td><td align="center">发布包含您的SLA定义的存储桶的累积直方图</td></tr></tbody></table><p>&amp;emsp;&amp;emsp;有关percentiles-histogram，percentiles并sla概念更多的细节，请参阅“<a href="https://micrometer.io/docs/concepts#_histograms_and_percentiles">Histogram and percentiles</a>”部分文档。</p><h2 id="6-指标端点"><a href="#6-指标端点" class="headerlink" title="6 指标端点"></a>6 指标端点</h2><p>&amp;emsp;&amp;emsp;Spring Boot提供了一个metrics端点，可用于诊断检查应用程序收集的指标。端点默认情况下不可用，必须公开，有关更多详细信息，请参见<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#production-ready-endpoints-exposing-endpoints">暴露端点</a>。</p><p>&amp;emsp;&amp;emsp;路径 &#x2F;actuator&#x2F;metrics 展示可用meter名称的列表。您可以通过提供特定的meter名称作为选择器来向下浏览以查看有关该仪表的信息,例如:&#x2F;actuator&#x2F;metrics&#x2F;jvm.memory.max。</p><p>&amp;emsp;&amp;emsp;您在此处使用的名称应与代码中使用的名称相匹配，而不是已经针对监视系统进行了命名约定标准化后的名称。</p><p>&amp;emsp;&amp;emsp;您还可以tag&#x3D;KEY:VALUE在URL的末尾添加任意数量的查询参数，以在维度上进一步细分meter，例如&#x2F;actuator&#x2F;metrics&#x2F;jvm.memory.max?tag&#x3D;area:nonheap。</p><p>&amp;emsp;&amp;emsp;报告的测量值是与仪表名称和已应用的任何标签相匹配的所有仪表的统计信息的总和。因此，在上面的示例中，返回的“值”统计量是堆的“代码缓存”，“压缩类空间”和“元空间”区域的最大内存占用量的总和。如果您只想查看“ Metaspace”的最大大小，则可以添加一个额外的tag&#x3D;id:Metaspace，即&#x2F;actuator&#x2F;metrics&#x2F;jvm.memory.max?tag&#x3D;area:nonheap&amp;tag&#x3D;id:Metaspace。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;Metrics&quot;&gt;&lt;a href=&quot;#Metrics&quot; class=&quot;headerlink&quot; title=&quot;Metrics&quot;&gt;&lt;/a&gt;Metrics&lt;/h1&gt;&lt;p&gt;&amp;amp;emsp;&amp;amp;emsp;Spring Boot
      
    
    </summary>
    
    
      <category term="Monitor System" scheme="http://yoursite.com/categories/Monitor-System/"/>
    
    
  </entry>
  
  <entry>
    <title>java基础--基本数据类型</title>
    <link href="http://yoursite.com/2019/11/12/java%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/11/12/java%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2019-11-12T14:54:49.000Z</published>
    <updated>2020-11-06T06:18:22.679Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="一、注释的写法"><a href="#一、注释的写法" class="headerlink" title="一、注释的写法"></a>一、注释的写法</h1><p>1.1 单行注释   &#x2F;&#x2F;这是单行注释</p><p>1.2 多行注释</p><pre><code>/*这是      多行注释*/</code></pre><p>1.3 文档注释</p><pre><code>/*****/    </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;一、注释的写法&quot;&gt;&lt;a href=&quot;#一、注释的写法&quot; class=&quot;headerlink&quot; title=&quot;一、注释的写法&quot;&gt;&lt;/a&gt;一、注释的写法&lt;/h1&gt;&lt;p&gt;1.1 单行注释   &amp;#x2F;&amp;#x2F;这是单行注释&lt;/
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>MicroMeter基础概念</title>
    <link href="http://yoursite.com/2019/11/12/MicroMeter%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2019/11/12/MicroMeter%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</id>
    <published>2019-11-12T14:41:32.000Z</published>
    <updated>2020-11-06T06:19:07.543Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="一、目的"><a href="#一、目的" class="headerlink" title="一、目的"></a>一、目的</h1><p>&amp;emsp;&amp;emsp;MicroMeter是针对基于JVM的应用程序的Metrics标准检测库。它为最流行的监视系统提供了一个基于可视化客户端的简单外观，使我们无需供应商锁定即可对基于JVM的应用程序代码进行可视化。它旨在在最大限度地提高指标工作可移植性的同时，几乎不增加指标收集活动的开销。</p><hr><h1 id="二、支持的监控系统"><a href="#二、支持的监控系统" class="headerlink" title="二、支持的监控系统"></a>二、支持的监控系统</h1><p>&amp;emsp;&amp;emsp;MicroMeter不是分布式跟踪系统或事件日志记录器。阿德里安·科尔（Adrian Cole）关于“ 可观测性3种方式”的演讲在强调这些不同类型的系统之间的差异方面做得很好。</p><p>&amp;emsp;&amp;emsp;MicroMeter包含一个带有可视化一起SPI的核心模块，一组包含各种监视系统的实现（每个系统称为注册表）的模块，以及一个测试套件。学习监视系统理解下面三个重要特征：</p><h2 id="2-1-维度"><a href="#2-1-维度" class="headerlink" title="2.1 维度"></a>2.1 维度</h2><p>&amp;emsp;&amp;emsp;系统是否支持通过标记键&#x2F;值对丰富metrics名称（tags）。如果系统不是为维度性的，则它是分层的，这意味着它仅支持平面度量标准名称。将metrics指标发布到分层系统时，Micrometer会展平标签键&#x2F;值对的集合并将其添加到名称中。</p><h2 id="2-2-速率聚合（Rate-aggregation）"><a href="#2-2-速率聚合（Rate-aggregation）" class="headerlink" title="2.2 速率聚合（Rate aggregation）"></a>2.2 速率聚合（Rate aggregation）</h2><p>&amp;emsp;&amp;emsp;在本文中，我们指的是在规定的时间间隔内集合一组样本。一些监视系统希望某些类型的离散样本（例如计数）在发布之前由应用程序转换为比率。有些人希望总是发送累积值。还有其他人对此没有意见。</p><h2 id="2-3-发布"><a href="#2-3-发布" class="headerlink" title="2.3 发布"></a>2.3 发布</h2><p>&amp;emsp;&amp;emsp;一些系统希望在闲暇时轮询应用程序以获取指标，而另一些系统则希望按固定间隔将指标推送给他们。</p><hr><h1 id="三、注册表（Registry）"><a href="#三、注册表（Registry）" class="headerlink" title="三、注册表（Registry）"></a>三、注册表（Registry）</h1><p>&amp;emsp;&amp;emsp;Meter是用于收集有关应用程序的一组度量（我们分别称为metrics指标）的接口。MicroMeter里面的Meters是从MeterRegistry中创建并保存在其中的。每个支持的监视系统都有一个的实现的MeterRegistry。注册表的创建方式因每个监控系统的实现方式而不同。</p><p>&amp;emsp;&amp;emsp;MicroMeter包装带有SimpleMeterRegistry，可在内存中保存每个meter的最新值，并且不会将数据导出到任何地方。如果您还没有首选的监视系统，则可以使用简单的注册表开始使用指标：</p><pre><code>MeterRegistry registry = new SimpleMeterRegistry();</code></pre><p>注：一个SimpleMeterRegistry是基于Spring的应用程序自动注入的。</p><h2 id="3-1-复合注册表"><a href="#3-1-复合注册表" class="headerlink" title="3.1 复合注册表"></a>3.1 复合注册表</h2><p>&amp;emsp;&amp;emsp;MicroMeter提供了一个CompositeMeterRegistry可以添加多个注册表的功能，使我们可以同时将Metrics指标发布到多个监视系统。</p><pre><code>CompositeMeterRegistry composite = new CompositeMeterRegistry();Counter compositeCounter = composite.counter(&quot;counter&quot;);compositeCounter.increment(); (1)SimpleMeterRegistry simple = new SimpleMeterRegistry();composite.add(simple); (2)compositeCounter.increment(); (3)</code></pre><p>1.组合中没有注册表之前，增量为NOOPd。此时计数器的计数仍将为0。</p><p>2.一个名为“ counter”的计数器被注册到简单注册表中。</p><p>3.简单注册表计数器以及组合中任何其他注册表的计数器都会增加。 </p><h2 id="3-2-全局注册表"><a href="#3-2-全局注册表" class="headerlink" title="3.2 全局注册表"></a>3.2 全局注册表</h2><p>&amp;emsp;&amp;emsp;MicroMeter提供了一个静态全局注册表Metrics.globalRegistry和一组静态生成器，用于基于此注册表生成meters。globalRegistry是一个复合注册表。(我是不是可以理解成Metrics就是默认完成了那个Metrics.globalRegistry，然后我们就可以肆无忌惮的使用Mtrics.xxx了)</p><pre><code>class MyComponent &#123;Counter featureCounter = Metrics.counter(&quot;feature&quot;, &quot;region&quot;, &quot;test&quot;); (1)void feature() &#123;    featureCounter.increment();&#125;void feature2(String type) &#123;    Metrics.counter(&quot;feature.2&quot;, &quot;type&quot;, type).increment(); (2)    &#125;&#125;class MyApplication &#123;void start() &#123;    // wire your monitoring system to global static state    Metrics.addRegistry(new SimpleMeterRegistry()); (3)    &#125;    &#125;</code></pre><p>&amp;emsp;&amp;emsp;1.只要能够实现（尤其是在可视化性能至关重要的地方），请将Meter实例存储在字段中，以避免在每次使用时查找其名称&#x2F;标签。</p><p>&amp;emsp;&amp;emsp;2.当需要根据本地上下文确定标记时，您别无选择，只能在方法体内构造&#x2F;查找Meter。查找成本只是单个哈希查找，因此对于大多数用途而言，这是可以接受的。</p><p>&amp;emsp;&amp;emsp;3.创建meters后添加注册表也是可以的，例如Metrics.counter(…​)。这些meters将被添加到每个注册表，因为它已绑定到全局组合。</p><h2 id="3-4-Meters"><a href="#3-4-Meters" class="headerlink" title="3.4 Meters"></a>3.4 Meters</h2><p>&amp;emsp;&amp;emsp;MicroMeter包含的它支持Meter原语集包括：Timer，Counter，Gauge，DistributionSummary，LongTaskTimer，FunctionCounter，FunctionTimer，和TimeGauge。不同的meter类型得出不同数量的时间序列指标metrics。例如，虽然有一个单独的表示Gauge类型的指标，但是Timer类型的指标既得出时间事件的计数，也含有时间事件总的计数。</p><p>&amp;emsp;&amp;emsp;meter是通过其名称和维度进行唯一标识的。我们可以“维度”和“标签”是一个意思，而“MicroMeter”层面Tag仅仅是因为它更短。作为一般规则，应该可以使用该名称作为枢轴。维度允许时间切面以特定的命名指标进行深入分析并推断数据。这意味着，如果仅选择名称，则用户可以使用其他维度和显示值的原因进行追溯。</p><h1 id="五-命名meters"><a href="#五-命名meters" class="headerlink" title="五 命名meters"></a>五 命名meters</h1><p>&amp;emsp;&amp;emsp;MicroMeter采用命名约定，用“.”（点）字符分隔小写单词。不同的监视系统对命名约定有不同的建议，并且某些命名约定可能与一个系统兼容，而与另一个系统不兼容。监视系统的每个Micrometer实施都附带一个命名约定，该约定将小写点标记法名称转换为监视系统推荐的命名约定。此外，此命名约定实现还清除了监视系统不允许的Metrics标准名称和特殊字符标签。您可以使用以下方法在注册表中实现NamingConvention并设置注册表，从而覆盖注册表的默认命名约定：</p><pre><code>registry.config().namingConvention(myCustomNamingConvention);</code></pre><p>&amp;emsp;&amp;emsp;有了适当的命名约定，在Micrometer中注册的以下timer计时器在各种监视系统中就可以很好的使用了：</p><pre><code>registry.timer(&quot;http.server.requests&quot;);</code></pre><p>&amp;emsp;&amp;emsp;Prometheus- http_server_requests_duration_seconds</p><p>&amp;emsp;&amp;emsp;Atlas- httpServerRequests</p><p>&amp;emsp;&amp;emsp;Graphite- http.server.requests</p><p>&amp;emsp;&amp;emsp;InfluxDB- http_server_requests</p><p>&amp;emsp;&amp;emsp;通过遵守Micrometer的小写点标记约定，我们就可以确保跨监视系统的metrics名称具有最大的可移植性。</p><h2 id="5-1-标签命名"><a href="#5-1-标签命名" class="headerlink" title="5.1 标签命名"></a>5.1 标签命名</h2><blockquote><p>tip</p><blockquote><p>命名标签时，建议使用与metrics名称相同的小写点标记。利用标签的这种一致的命名约定，可以更好地转换为相应监视系统的惯用命名方案。</p></blockquote></blockquote><p>假设我们正在尝试测量http请求的数量和数据库调用的数量。</p><p>推荐方法：</p><pre><code>registry.counter(&quot;database.calls&quot;, &quot;db&quot;, &quot;users&quot;)registry.counter(&quot;http.requests&quot;, &quot;uri&quot;, &quot;/api/users&quot;)</code></pre><p>&amp;emsp;&amp;emsp;这个变量提供了足够的文本信息，因此，如果仅选择名称，则可以推断出该值，并且至少具有潜在的意义。例如，如果我们选择“database.calls”则可以看到所有数据库的调用总数。然后，我们可以分组或选择“db”以进一步细分或对呼叫对每个数据库的贡献进行比较分析。</p><p>不合适的方法</p><pre><code>registry.counter(&quot;calls&quot;,                &quot;class&quot;, &quot;database&quot;,                &quot;db&quot;, &quot;users&quot;);registry.counter(&quot;calls&quot;,                &quot;class&quot;, &quot;http&quot;,                &quot;uri&quot;, &quot;/api/users&quot;);</code></pre><p>&amp;emsp;&amp;emsp;在这种方法中，如果选择，calls我们将获得一个值，该值是对数据库和API端点的调用次数的总和。如果没有进一步的维度向下钻取，该时间序列将无用。</p><h2 id="5-2-通用标签"><a href="#5-2-通用标签" class="headerlink" title="5.2 通用标签"></a>5.2 通用标签</h2><p>&amp;emsp;&amp;emsp;可以在注册表级别定义公用标签，并将其添加到报告给监视系统的每个度量标准中。通常用于在操作环境（例如主机，实例，区域，堆栈等）上进行维度深入分析。</p><pre><code>registry.config().commonTags(&quot;stack&quot;, &quot;prod&quot;, &quot;region&quot;, &quot;us-east-1&quot;);registry.config().commonTags(Arrays.asList(Tag.of(&quot;stack&quot;, &quot;prod&quot;), Tag.of(&quot;region&quot;, &quot;us-east-1&quot;))); // equivalently</code></pre><p>&amp;emsp;&amp;emsp;调用commonTags追加其他通用标签。</p><blockquote><p>重要</p><blockquote><p>如果我们在Spring环境中，需要通过添加MeterRegistryCustomizerBean来添加通用标签，以确保在自动配置meter绑定程序之前应用了通用标签。</p></blockquote></blockquote><h2 id="5-3-标签值"><a href="#5-3-标签值" class="headerlink" title="5.3 标签值"></a>5.3 标签值</h2><p>&amp;emsp;&amp;emsp;标签值必须非空</p><blockquote><p>警告</p><blockquote><p>注意来自用户提供的来源的标记值可能会破坏指标的基数。我们应该始终保持规范并绑定用户提供的输入。有时原因是非常细微的。考虑用于记录服务端点上的HTTP请求的URI标记。如果我们不将404约束为NOT_FOUND之类的值，则metrics的维度将随着找不到的每个资源而增长。</p></blockquote></blockquote><hr><h1 id="6-Meter过滤器"><a href="#6-Meter过滤器" class="headerlink" title="6.Meter过滤器"></a>6.Meter过滤器</h1><p>&amp;emsp;&amp;emsp;每个注册表都可以配置meter过滤器，使我们可以更好地控制如何注册仪表，何时注册仪表以及发出何种统计信息。Meter过滤器具有三个基本功能：</p><p>&amp;emsp;&amp;emsp;1.拒绝（或接受）meter被注册。</p><p>&amp;emsp;&amp;emsp;2.转换Meter的ID（例如，更改名称，添加或删除标签，更改描述或基本单位）。</p><p>&amp;emsp;&amp;emsp;3.配置某些meter类型的分布统计信息。</p><p>&amp;emsp;&amp;emsp;MeterFilter的实现以编程方式添加到注册表中：</p><pre><code>registry.config().meterFilter(MeterFilter.ignoreTags(&quot;too.much.information&quot;)).meterFilter(MeterFilter.denyNameStartsWith(&quot;jvm&quot;));</code></pre><p>&amp;emsp;&amp;emsp;按顺序应用Meter过滤器，并将变换或配置meter的结果链接在一起。</p><h2 id="6-1-拒绝-x2F-接受meters"><a href="#6-1-拒绝-x2F-接受meters" class="headerlink" title="6.1 拒绝&#x2F;接受meters"></a>6.1 拒绝&#x2F;接受meters</h2><p>&amp;emsp;&amp;emsp;接受&#x2F;拒绝过滤器的详细形式为：</p><pre><code>new MeterFilter() &#123;    @Override    public MeterFilterReply accept(Meter.Id id) &#123;       if(id.getName().contains(&quot;test&quot;)) &#123;          return MeterFilterReply.DENY;       &#125;       return MeterFilterReply.NEUTRAL;        &#125;    &#125;</code></pre><p>&amp;emsp;&amp;emsp;MeterFilterReply具有三种可能的状态：</p><ul><li><p>DENY-请勿注册该仪表。当我们尝试注册一个与另一个注册表冲突的meter,过滤器返回DENY注册表将返回meter的NOOP版本（例如NoopCounter，NoopTimer）。我们的代码可以继续与NOOP计量器进行交互，但是记录在其中的任何内容都将以最小的开销立即被丢弃。</p></li><li><p>NEUTRAL-如果没有其他meter过滤器返回DENY，则meter的注册将照常进行。</p></li><li><p>ACCEPT-如果过滤器返回ACCEPT，meter将立即注册，而不会询问任何其他过滤器的接受方法。</p></li></ul><h3 id="6-1-1-便利的方法"><a href="#6-1-1-便利的方法" class="headerlink" title="6.1.1 便利的方法"></a>6.1.1 便利的方法</h3><h3 id="6-1-2-链接-拒绝-x2F-接受meters"><a href="#6-1-2-链接-拒绝-x2F-接受meters" class="headerlink" title="6.1.2 链接 拒绝&#x2F;接受meters"></a>6.1.2 链接 拒绝&#x2F;接受meters</h3><h2 id="6-2-转换metrics"><a href="#6-2-转换metrics" class="headerlink" title="6.2 转换metrics"></a>6.2 转换metrics</h2><p>&amp;emsp;&amp;emsp;转换过滤器如下所示：</p><pre><code>new MeterFilter() &#123;    @Override    public Meter.Id map(Meter.Id id) &#123;       if(id.getName().startsWith(&quot;test&quot;)) &#123;          return id.withName(&quot;extra.&quot; + id.getName()).withTag(&quot;extra.tag&quot;, &quot;value&quot;);       &#125;       return id;    &#125;&#125;</code></pre><p>&amp;emsp;&amp;emsp;该过滤器有条件地向meters添加以名称“ test”开头的名称前缀和附加标签。</p><p>&amp;emsp;&amp;emsp;MeterFilter 为许多常见的转换案例提供了便利构建器：</p><p>&amp;emsp;&amp;emsp;commonTags(Iterable<Tag>)-向所有指标添加一组标签。强烈建议为应用名称，主机，区域等添加通用标签。</p><p>&amp;emsp;&amp;emsp;ignoreTags(String…​)-从每个仪表上舍弃匹配的标签键。当标签可证明变得过高的基数并开始给监视系统施加压力或开销增大，使得我们不能快速更改所有检测点时，此功能特别有用。</p><p>&amp;emsp;&amp;emsp;replaceTagValues(String tagKey, Function&lt;String, String&gt; replacement, String…​ exceptions)-根据为所有匹配的标记键提供的映射替换标记值。通过将标签值的某些部分映射到其他内容，可以用来减少标签的总基数。</p><p>&amp;emsp;&amp;emsp;renameTag(String meterNamePrefix, String fromTagKey, String toTagKey) -重命名以给定前缀开头的每个指标的标签键。</p><h2 id="6-3-配置分布统计"><a href="#6-3-配置分布统计" class="headerlink" title="6.3 配置分布统计"></a>6.3 配置分布统计</h2><p>&amp;emsp;&amp;emsp;Timer和DistributionSummary除了可以通过过滤器配置的计数、总数和最大值的基本信息外，还包含一组可选的分布统计信息。这些分布统计信息包括预先计算的百分位数，SLA和直方图。</p><pre><code>new MeterFilter() &#123;    @Override    public DistributionStatisticConfig configure(Meter.Id id, DistributionStatisticConfig config) &#123;        if (id.getName().startsWith(prefix)) &#123;            return DistributionStatisticConfig.builder()                    .publishPercentiles(0.9, 0.95)                    .build()                    .merge(config);        &#125;        return config;    &#125;&#125;;</code></pre><p>&amp;emsp;&amp;emsp;通常，我们应该仅对我们希望配置的切片创建一个新的DistributionStatisticConfig并且将它与输入的配置合并。这样，我们就可以下拉注册表提供的分发统计信息的默认值，并将多个过滤器链接在一起，每个过滤器都可以配置分发统计信息的一部分（例如，我们可能希望所有http请求都具有100ms的SLA，但在一些关键请求上只需要百分位端点）。</p><p>&amp;emsp;&amp;emsp;MeterFilter 为以下人员提供便利构建器：</p><p>&amp;emsp;&amp;emsp;maxExpected(Duration&#x2F;long) -控制从timer或summary中得到的百分比直方图桶的上限。</p><p>&amp;emsp;&amp;emsp;minExpected(Duration&#x2F;long) -控制从timer或summary中得到的百分比直方图桶的下限。</p><p>&amp;emsp;&amp;emsp;Spring Boot提供了基于属性的过滤器，用于通过名称前缀配置SLA，百分比和百分比直方图。</p><h1 id="7-速率聚合"><a href="#7-速率聚合" class="headerlink" title="7.速率聚合"></a>7.速率聚合</h1><p>&amp;emsp;&amp;emsp;Micrometer知道特定的监视系统希望在metrics发布之前还是在服务器端作为查询的一部分临时在客户端进行速率聚合。它根据监视系统期望的样式累积metrics。</p><p>&amp;emsp;&amp;emsp;并非所有测量指标都进行速率聚合进行报告或展示。例如，gauge和long task timer的任务就不是速率聚合。 </p><p>&amp;emsp;&amp;emsp;执行服务器端速率聚合的监视系统希望在每个发布间隔报告绝对值。例如，自从应用程序的开始运行，在每个发布间隔所有counter增量的绝对值都会发布。</p><p>&amp;emsp;&amp;emsp;假设我们有一个略微偏向的随机游走，它选择每10ms增加一次counter计数器。如果我们在监控系统，比如Prometheus这样的系统中查看原始计数器值，则会看到逐步单调递增的函数（步长是Prometheus轮询或抓取数据的间隔）。</p><p><img src="https://wx4.sinaimg.cn/mw690/007857NYly1g8v8j33vttj30i708zmxx.jpg" alt="rate1"></p><p>&amp;emsp;&amp;emsp;在某个时间窗口内没有速率聚合的counter很少是有用的，因为表示的是计数器递增的速度和服务寿命的函数。在上面的示例中，服务重新启动时，counter降回零。新实例（例如在生产部署中）投入使用后，速率聚合图像将返回到约55的值。</p><p>&amp;emsp;&amp;emsp;如果我们已实现零停机时间部署（例如通过红黑部署），则应该能够在速率汇总图上轻松设置最低警报阈值，而无需重新启动服务导致计数器值下降。</p><blockquote><p>重要</p><blockquote><p>对于大多数生产目的，无论是警报，自动数据分析等，都是基于速率汇总数据进行自动化的。</p></blockquote></blockquote><h2 id="7-2-客户端"><a href="#7-2-客户端" class="headerlink" title="7.2 客户端"></a>7.2 客户端</h2><p>另一类监视系统：</p><p>&amp;emsp;&amp;emsp;1.期望速率汇总数据。考虑到对于大多数生产目的的关键需求指标，我们应该基于速率而不是绝对值来做出决策，这样的系统将得益于无需进行太多数学运算即可满足查询的需求。</p><p>&amp;emsp;&amp;emsp;2.几乎没有数学运算或没有数学运算，即可使我们可以通过查询对数据进行速率聚合。对于这些系统，发布预先聚合的数据是构建有意义的表示的唯一方法。</p><p>&amp;emsp;&amp;emsp;MicroMeter通过累积当前发布间隔数据的步长值来有效维护速率数据。当对步长值进行轮询时（例如，在发布时），如果步长值检测到当前间隔已过去，则它将当前数据移至“先前”状态。该先前状态是报告的，直到下次当前数据覆盖它为止。以下是当前和先前状态以及轮询之间相互作用的说明：</p><p>&amp;emsp;&amp;emsp;poll函数返回的值始终是每秒的速率*间隔。如果上面说明的步长值表示counter的值，则可以说计数器在第一个间隔中看到了“每秒0.3增量”，这可以在第二个间隔中的任何时间报告给后端。</p><p>&amp;emsp;&amp;emsp;MicroMeterde的timer至少跟踪一个计数和总时间，作为单独的测量。假设我们以10秒的间隔配置发布，并且看到20个请求，每个请求花费100毫秒。然后在第一个间隔中：</p><pre><code>1.count = 10秒*（20个请求/ 10秒）= 20个请求2.totalTime = 10秒*（20 * 100毫秒/ 10秒）= 2秒</code></pre><p>&amp;emsp;&amp;emsp;该count统计信息很有意义，可以单独使用–它是吞吐量的度量。totalTime表示间隔中所有请求的总延迟。另外：</p><pre><code>totalTime / count = 2秒/ 20个请求= 0.1秒/请求= 100 ms /请求</code></pre><p>&amp;emsp;&amp;emsp;这是平均延迟的有用度量。当将相同的思想应用于分布汇总totalAmount并count从中得出时，该度量称为分布平均值。平均延迟只是按时间（timer）度量的分发summary的分发平均值。犹如Atlas一些监测系统计算从这些统计分布平均提供设施和MicroMeter将发布totalTime和count作为单独统计。其他如Datadog则没有内置此类操作，Micrometer将计算客户端的平均分配并将其发送出去。<br><img src="https://wx4.sinaimg.cn/mw690/007857NYly1g8v8gqzxc1j31cm0fpjtr.jpg" alt="rate分析"><br>&amp;emsp;&amp;emsp;发布时间间隔的速率足以推断出在任何时间窗口内大于或等于发布时间间隔的速率。在我们的示例中，如果服务在给定的分钟内继续接收20个请求，在每10秒间每个请花费100ms，那么我们可以说：</p><p>&amp;emsp;&amp;emsp;1.MicroMeter每10秒报告一次total–“ 20个请求” 。监视系统简单地将这六个10秒的间隔相加即可得出每分钟120个请求的结论。请注意，是进行进行求和操作的是监视系统，而不是MicroMeter。</p><p>&amp;emsp;&amp;emsp;2.MicroMeter每隔10 秒报告一次totalTime–“ 2秒” 。监视系统可以对一分钟内的所有总时间统计信息求和，以在分钟间隔内产生总时间的“ 12秒”。然后，平均延迟就如我们期望的那样：12秒&#x2F; 120个请求&#x3D; 100 ms &#x2F;请求。</p><hr><h1 id="8-Counters"><a href="#8-Counters" class="headerlink" title="8.Counters"></a>8.Counters</h1><p>Couners报告一个指标，计数。该Counter接口允许我们以固定数量递增，该数量必须为正。</p><blockquote><p>tip</p><blockquote><p>永远不要记数一些我们可以使用Timer或用DistributionSummary记录的东西！Timer和DistributionSummary会发布除了其他的测量事件之外，还有事件的计数。</p></blockquote></blockquote><p>&amp;emsp;&amp;emsp;建立图表并根据Counter发出警报时，通常我们应该最感兴趣的是测量在给定时间间隔内某些事件的速率。考虑一个简单的队列，Counter可用于衡量事物的插入和移除速度。</p><p>&amp;emsp;&amp;emsp;人们首先想到的是可视化绝对数值，而不是速率，但绝对数量通常是既是一些事务的使用速率的函数也是可视化条件下应用程序实例的使用寿命。在某些时间间隔内构建仪表板和Counter速率警报会忽略应用程序的寿命，让我们在应用程序启动后很长时间才看到异常行为。</p><blockquote><p>注意</p><blockquote><p>在进入使用计数器之前，请务必通读Timer部分，因为Timer会记录计时事件的计数，因为Counter记录了时间事件的计数作为度量的一部分。对于我们打算计时的那些代码，我们无需单独添加计数器。</p></blockquote></blockquote><p>&amp;emsp;&amp;emsp;以下代码模拟了一个真实的Counter，该Counter的rate在较短的时间范围内显示出一些扰动。</p><pre><code>Normal rand = ...; // a random generatorMeterRegistry registry = ...Counter counter = registry.counter(&quot;counter&quot;); (1)Flux.interval(Duration.ofMillis(10))    .doOnEach(d -&gt; &#123;        if (rand.nextDouble() + 0.1 &gt; 0) &#123; (2)            counter.increment(); (3)        &#125;    &#125;)    .blockLast();</code></pre><p>&amp;emsp;&amp;emsp;1.可以使用名称和（可选）一组标签从注册表本身创建大多数Counter。</p><p>&amp;emsp;&amp;emsp;2.略微偏向的随机游走。</p><p>&amp;emsp;&amp;emsp;3.这就是我们与Conuter交互的方式。我们也可以用counter.increment(n)在单个操作中调用增加1以上的值。</p><p>&amp;emsp;&amp;emsp;Counter接口本身还有一个流利的计数器构建器，可以访问不太常用的选项，例如基本单位和说明。我们可以通过调用将计数器注册为构造计数器的最后一步register。</p><pre><code>Counter counter = Counter    .builder(&quot;counter&quot;)    .baseUnit(&quot;beans&quot;) // optional    .description(&quot;a description of what this counter does&quot;) // optional    .tags(&quot;region&quot;, &quot;test&quot;) // optional    .register(registry);</code></pre><h2 id="8-1-功能–追踪Counter"><a href="#8-1-功能–追踪Counter" class="headerlink" title="8.1 功能–追踪Counter"></a>8.1 功能–追踪Counter</h2><p>&amp;emsp;&amp;emsp;MicroMeter还提供了一种更不常用的计数器模式，该模式跟踪单调递增的函数（函数保持不变或随时间增加，但从不减少）。一些监视系统（例如Prometheus）将Counter的累积值推送到后端，但是其他系统则发布Counter在推送间隔内递增的速率。通过采用这种模式，我们可以让监控系统的Micrometer实施选择是否对Counter进行归一化评估，并且计数器可以在不同类型的监控系统之间保持可移植性。</p><pre><code>Cache cache = ...; // suppose we have a Guava cache with stats recording onregistry.more().counter(&quot;evictions&quot;, tags, cache, c -&gt; c.stats().evictionCount()); (1)</code></pre><p>&amp;emsp;&amp;emsp;1.evictionCount() 是一个单调递增的函数，从生命周期的开始就随着每次缓存逐出而递增。</p><p>&amp;emsp;&amp;emsp;功能–跟踪Counter,与监视系统的速率归一化功能（无论是查询语言的人工产物还是数据被推送到系统的方式）配合使用，在功能的累积值之上增加了一层丰富性。可以推断值增加的速率，这样的速率是否在一个可接受的范围，随着时间的推移是在增加或降低。</p><blockquote><p>警告</p><blockquote><p>MicroMeter不能为您保证函数的单调性。通过使用此签名，我们可以根据对定义的了解来断言其单调性。</p></blockquote></blockquote><p>&amp;emsp;&amp;emsp;FunctionCounter接口本身也具有用于功能计数器的流利的构建器，可以访问不太常用的选项，例如基本单元和描述。我们可以通过调用将计数器注册为构造计数器的最后一步register(MeterRegistry)。</p><pre><code>MyCounterState state = ...;FunctionCounter counter = FunctionCounter    .builder(&quot;counter&quot;, state, state -&gt; state.count())    .baseUnit(&quot;beans&quot;) // optional    .description(&quot;a description of what this counter does&quot;) // optional    .tags(&quot;region&quot;, &quot;test&quot;) // optional    .register(registry);</code></pre><h1 id="9-Gauge"><a href="#9-Gauge" class="headerlink" title="9.Gauge"></a>9.Gauge</h1><p>&amp;emsp;&amp;emsp;Gauge是获取当前值的处理器。Gauge的典型示例是运行状态下的<strong>集合或映射的大小或线程数</strong>。</p><blockquote><p>tip</p><blockquote><p>Gauge对于监视具有自然上限的事物很有用。不建议使用Gauge来监视诸如请求计数之类的事情，因为它们会在应用程序实例生命周期内不受限制地增长。</p></blockquote></blockquote><blockquote><p>tip</p><blockquote><p>能用Counter计量的东西千万不要用Gauge！</p></blockquote></blockquote><p>&amp;emsp;&amp;emsp;MicroMeter的立场是应该对Gauge进行采样而不进行设置，因此没有关于样品之间可能发生的情况的信息。毕竟，在将Gauge值报告给Metrics后端后，Gauge上设置的任何中间值都会丢失，因此首先设置这些中间值似乎没有什么价值。</p><p>&amp;emsp;&amp;emsp;如果有帮助，可以将其Gauge视为“heisen-gauge”-仅在观察到时才会改变的仪表。开箱即用提供的所有其他Meter类型都会在向数据后端发送数据时累积中间计数。</p><p>&amp;emsp;&amp;emsp;该MeterRegistry接口包含用于构建Gauge以观察数值、方法、、集合和映射的方法。</p><pre><code>List&lt;String&gt; list = registry.gauge(&quot;listGauge&quot;, Collections.emptyList(), new ArrayList&lt;&gt;(), List::size); (1)List&lt;String&gt; list2 = registry.gaugeCollectionSize(&quot;listSize2&quot;, Tags.empty(), new ArrayList&lt;&gt;()); (2)Map&lt;String, Integer&gt; map = registry.gaugeMapSize(&quot;mapGauge&quot;, Tags.empty(), new HashMap&lt;&gt;());</code></pre><p>&amp;emsp;&amp;emsp;1.gauge的一种较常见的形式是监视某些非数字对象。最后一个参数建立了一个函数，该函数用于在观察gauge时确定gauge的值。</p><p>&amp;emsp;&amp;emsp;2.对于(1)的一种更方便的形式，用于您只想监视集合大小的情况。</p><p>&amp;emsp;&amp;emsp;创建gauge的所有不同形式都仅保持对要观察的对象的弱引用，以免阻止对象的垃圾收集。</p><h2 id="9-1-手动增减仪表"><a href="#9-1-手动增减仪表" class="headerlink" title="9.1 手动增减仪表"></a>9.1 手动增减仪表</h2><p>&amp;emsp;&amp;emsp;gauge可制成可以跟踪任何java.lang.Number亚型，如java.util.concurrent.atomic中发现的AtomicInteger和AtomicLong，和Guava的AtomicDouble类似的类型。</p><pre><code>AtomicInteger n = registry.gauge(&quot;numberGauge&quot;, new AtomicInteger(0));n.set(1);n.set(2);</code></pre><p>&amp;emsp;&amp;emsp;请注意，这种形式与其他meter类型不同，Gauge在创建一个meter时，我们不会得到引用，而是要观察到的东西。这是因为存在”heisen-gauge”原理，gauge一经创建便是自给自足的，因此我们无需与之交互。这使MicroMeter可以只向我们退还已检测的对象，从而可以快速创建一个可观察对象并围绕该对象设置metrics指标。</p><p>&amp;emsp;&amp;emsp;此模式应比DoubleFunction表格少见。请记住，频繁设置观察值会Number导致许多中间值无法发布。仅在发布时将gauge的瞬时值发送到监视系统。</p><blockquote><p>警告</p><blockquote><p>尝试使用原始数字或其java.lang对象形式之一构造gauge总是不正确的。这些数字是不可变的，因此gauge无法更改。尝试用不同的编号“重新注册”量规是行不通的，因为注册表仅对名称和标签组成的唯一组合维护一个仪表。</p></blockquote></blockquote><h2 id="9-2-Gauge的构建器"><a href="#9-2-Gauge的构建器" class="headerlink" title="9.2 Gauge的构建器"></a>9.2 Gauge的构建器</h2><p>&amp;emsp;&amp;emsp;该接口包含一个流利的gauge构建器：</p><pre><code>Gauge gauge = Gauge    .builder(&quot;gauge&quot;, myObj, myObj::gaugeValue)    .description(&quot;a description of what this gauge does&quot;) // optional    .tags(&quot;region&quot;, &quot;test&quot;) // optional    .register(registry);</code></pre><p>&amp;emsp;&amp;emsp;通常，返回的Gauge实例仅在测试中有用，因为gauge已设置为在注册后自动跟踪数值。</p><h2 id="9-3-我的Gauge为什么报告NaN或消失？"><a href="#9-3-我的Gauge为什么报告NaN或消失？" class="headerlink" title="9.3 我的Gauge为什么报告NaN或消失？"></a>9.3 我的Gauge为什么报告NaN或消失？</h2><p>&amp;emsp;&amp;emsp;MicroMeter对于创建强引用对象非常谨慎，避免那些对象无法进行垃圾收集，一旦被测量的对象被取消引用并被垃圾回收，Micrometer将开始报告测量值的NaN或不报告，具体取决于注册表的实现方式。</p><p>&amp;emsp;&amp;emsp;如果看到gauge报告了几分钟，然后消失或报告了NaN，则几乎可以肯定地表明被测量的基础对象已被垃圾回收。</p><hr><h1 id="10-Timer"><a href="#10-Timer" class="headerlink" title="10 Timer"></a>10 Timer</h1><p>&amp;emsp;&amp;emsp;计时器用于测量短时延以及此类事件的频率。所有实现的Timer将按照时间序列报告至少总时间和事件计数。尽管可以将Timers用于其他用例，但请注意不支持负值，并且记录更长的持续时间可能会导致总时间溢出（以Long.MAX_VALUE纳秒计）（292.3年）。</p><p>&amp;emsp;&amp;emsp;例如，考虑一个图表，它显示了对典型Web服务器的请求延迟。可以期望服务器快速响应许多请求，因此计时器将每秒更新多次。</p><p>&amp;emsp;&amp;emsp;Counter的适当基本单位因指标后端的不同而有所不同。MicroMeter对此毫无疑问，但是由于存在混淆的可能性，与Timers 相互作用时需要TimeUnit。Micrometer知道每种实现的首选项，并根据实现在适当的基本单元中发布我们的时间安排。</p><pre><code>public interface Timer extends Meter &#123;    ...    void record(long amount, TimeUnit unit);    void record(Duration duration);    double totalTime(TimeUnit unit);&#125;</code></pre><p>&amp;emsp;&amp;emsp;该接口包含一个流畅的Timer构建器：</p><pre><code>Timer timer = Timer.builder(&quot;my.timer&quot;).description(&quot;a description of what this timer does&quot;) // optional.tags(&quot;region&quot;, &quot;test&quot;) // optional.register(registry);</code></pre><h2 id="10-1-记录代码块"><a href="#10-1-记录代码块" class="headerlink" title="10.1 记录代码块"></a>10.1 记录代码块</h2><p>&amp;emsp;&amp;emsp;该Timer接口公开了一些方便的重载，用于内联时间记录，例如：</p><pre><code>timer.record(() -&gt; dontCareAboutReturnValue());timer.recordCallable(() -&gt; returnValue());Runnable r = timer.wrap(() -&gt; dontCareAboutReturnValue()); (1)Callable c = timer.wrap(() -&gt; returnValue());</code></pre><p>1.包装Runnable或Callable返回其可视化版本以供以后使用。</p><blockquote><p>注意</p><blockquote><p>Timer实际上只是一个专门的分布式summary，它知道如何将持续时间缩放到每个监视系统的基本时间单位，并且具有自动确定的基本单位。在每种情况下，如果要测量时间，都应使用Timer而不是DistributionSummary。</p></blockquote></blockquote><h2 id="10-2-将开始状态存储在Timer-Sample"><a href="#10-2-将开始状态存储在Timer-Sample" class="headerlink" title="10.2 将开始状态存储在Timer.Sample"></a>10.2 将开始状态存储在Timer.Sample</h2><p>&amp;emsp;&amp;emsp;您也可以将启动状态存储在示例实例中，以后可以将其停止。该示例记录基于注册表时钟的开始时间。开始采样后，执行要计时的代码，并通过调用stop(Timer)采样完成操作。</p><pre><code>Timer.Sample sample = Timer.start(registry);// do stuffResponse response = ...sample.stop(registry.timer(&quot;my.timer&quot;, &quot;response&quot;, response.status()));</code></pre><p>&amp;emsp;&amp;emsp;请注意，在停止采样之前，如何确定采样所用的计时器。这使我们能够根据我们正在计时的操作的结束状态动态地确定某些标签。</p><h2 id="10-3-Timed注解"><a href="#10-3-Timed注解" class="headerlink" title="10.3 @Timed注解"></a>10.3 @Timed注解</h2><p>&amp;emsp;&amp;emsp;micrometer-core模块包含一个@Timed注释，框架可以使用该注释向特定类型的方法（例如为Web请求端点提供服务的方法）或通常为所有方法添加计时支持。</p><blockquote><p>警告</p><blockquote><p>Micrometer的Spring Boot配置无法@Timed在任意方法上识别。</p></blockquote></blockquote><p>&amp;emsp;&amp;emsp;还包含一个可孵化的AspectJ方面micrometer-core，在应用程序中，我们可以通过编译&#x2F;加载AspectJ编织，或通过框架工具比如Spring Aop等其他方式解释AspectJ切面和代理目标方法。如下是一个示例Spring AOP配置：</p><pre><code>@Configurationpublic class TimedConfiguration &#123;@Beanpublic TimedAspect timedAspect(MeterRegistry registry) &#123;  return new TimedAspect(registry);   &#125;&#125;</code></pre><p>&amp;emsp;&amp;emsp;在AspectJ代理实例中，应用程序TimedAspect的@Timed用于任何任意方法。</p><h2 id="10-4-功能–跟踪timers"><a href="#10-4-功能–跟踪timers" class="headerlink" title="10.4 功能–跟踪timers"></a>10.4 功能–跟踪timers</h2><p>&amp;emsp;&amp;emsp;MicroMeter还提供了一种不常用的计时器模式，该模式可跟踪两个单调递增的函数（一个函数随时间保持不变或增加，但从不减小）：计数函数和总时间函数。某些监视系统（例如Prometheus）将计数器的累积值（在这种情况下适用于计数和总时间函数）推送到后端，但其他系统则发布计数器在推送间隔内递增的速率。通过采用这种模式，我们可以让监控系统的Micrometer实现选择是否对timer进行速率聚合，并且计时器可以在不同类型的监控系统之间保持可移植性。</p><pre><code>IMap&lt;?, ?&gt; cache = ...; // suppose we have a Hazelcast cacheregistry.more().timer(&quot;cache.gets.latency&quot;, Tags.of(&quot;name&quot;, cache.getName()), cache,    c -&gt; c.getLocalMapStats().getGetOperationCount(), (1)    c -&gt; c.getLocalMapStats().getTotalGetLatency(),    TimeUnit.NANOSECONDS (2));</code></pre><p>&amp;emsp;&amp;emsp;1.getGetOperationCount() 是一个单调递增的函数，它从生命周期的开始就随着每个缓存的获取而递增。</p><p>&amp;emsp;&amp;emsp;2.这表示由getTotalGetLatency()表示的时间单位。每个注册表实现均指定其预期的基本时间单位是什么，并且报告的总时间将缩放为该值。</p><p>&amp;emsp;&amp;emsp;功能–跟踪timer与监视系统的速率归一功能（无论是查询语言的人工产物还是数据被推送到系统的方式）配合使用，在功能的累积值之上增加了一层丰富性，我们可以推断吞吐量和延迟的速率，该速率是否在可接受的范围内，随时间增加还是减少等。</p><blockquote><p>警告</p><blockquote><p>MicroMeter不能为我们保证count和total time功能的单调性。通过使用此签名，您可以根据对定义的了解来断言它们的单调性。</p></blockquote></blockquote><p>&amp;emsp;&amp;emsp;FunctionTimer接口本身还有一个流利的FunctionTimer构建器，可用于访问不常用的选项，例如基本单元和描述。您可以通过调用register(MeterRegistry)为构造计时器的最后一步)。</p><pre><code>IMap&lt;?, ?&gt; cache = ...FunctionTimer.builder(&quot;cache.gets.latency&quot;, cache,        c -&gt; c.getLocalMapStats().getGetOperationCount(),        c -&gt; c.getLocalMapStats().getTotalGetLatency(),        TimeUnit.NANOSECONDS)    .tags(&quot;name&quot;, cache.getName())    .description(&quot;Cache gets&quot;)    .register(registry);</code></pre><h2 id="10-5-暂停检测"><a href="#10-5-暂停检测" class="headerlink" title="10.5 暂停检测"></a>10.5 暂停检测</h2><p>&amp;emsp;&amp;emsp;MicroMeter使用LatencyUtils包来补偿协同遗漏—系统和VM暂停导致的额外延迟会延迟您的延迟统计信息。百分位数和SLA计数之类的分布统计信息受暂停检测器实现的影响，该实现会在此处和此处添加额外的延迟以补偿暂停。</p><p>&amp;emsp;&amp;emsp;MicroMeter支持两种暂停检测器实施方式：基于时钟漂移的检测器和无操作检测器。在MicroMeter的1.0.10&#x2F;1.1.4&#x2F;1.2.0版本之前，默认情况下配置了时钟漂移检测器以报告尽可能准确的度量标准，而无需进行进一步配置。从1.0.10&#x2F;1.1.4&#x2F;1.2.0版本开始，默认情况下配置无操作检测器，但可以如下配置时钟漂移检测器。</p><p>&amp;emsp;&amp;emsp;基于时钟漂移的检测器具有可配置的睡眠间隔和暂停阈值。CPU消耗与sleepInterval、暂停检测精度成反比。这两个值的100ms是合理的默认值，以提供对长时间停顿事件的适当检测，同时消耗可忽略的CPU时间。</p><p>&amp;emsp;&amp;emsp;我们可以使用以下方法自定义暂停检测器：</p><pre><code>registry.config().pauseDetector(new ClockDriftPauseDetector(sleepInterval, pauseThreshold));registry.config().pauseDetector(new NoPauseDetector());</code></pre><p>&amp;emsp;&amp;emsp;将来，我们可能会提供进一步的检测器实现。例如，在某些情况下，可以从GC日志中推断出一些暂停，而不需要恒定的CPU负载，尽管负载很小。将来的JDK也可能会提供对暂停事件的直接访问。</p><h2 id="10-6-内存占用估算"><a href="#10-6-内存占用估算" class="headerlink" title="10.6 内存占用估算"></a>10.6 内存占用估算</h2><p>&amp;emsp;&amp;emsp;Timer是最消耗内存的meter，其总占用空间可能会因我们选择的选项而有很大差异。下表是基于各种功能使用情况的内存消耗表。这些数字假定没有标签，并且环形缓冲区的长度为3。添加标签当然会增加总数，增加缓冲区的长度也会有所增加。总存储量也可能会有所不同，具体取决于注册表的实现。</p><ul><li><p>R &#x3D;环形缓冲区的长度。在所有示例中，我们假定默认值为3。R用设置Timer.Builder#distributionStatisticBufferLength。</p></li><li><p>B &#x3D;总直方图桶。可以是SLA边界或百分比直方图桶。默认情况下，计时器被限制为最小期望值1ms和最大期望值30秒，如果适用，则为百分比直方图产生66个桶。</p></li><li><p>I &#x3D;暂停补偿的间隔估算器。1.7 kb</p></li><li><p>M &#x3D;最大衰减时间。104字节</p></li><li><p>Fb &#x3D;固定边界直方图。30b * B * R</p></li><li><p>Pp &#x3D;百分位数精度。默认情况下为1。通常在[0，3]范围内。Pp用设置Timer.Builder#percentilePrecision。</p></li><li><p>Hdr（Pp）&#x3D;高动态范围直方图。</p></li></ul><p>若 Pp &#x3D; 0：1.9kb * R + 0.8kb</p><p>若 Pp &#x3D; 1：3.8kb * R + 1.1kb</p><p>若 Pp &#x3D; 2：18.2kb * R + 4.7kb</p><p>若 Pp &#x3D; 3：66kb * R + 33kb</p><table><thead><tr><th align="center">暂停检测</th><th align="center">客户端百分位数</th><th align="center">Cool</th><th align="center">直方图和&#x2F;或SLA</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">YES</td><td align="center">NO</td><td align="center">NO</td><td align="center">I+M</td><td align="center">~1.8kb</td></tr><tr><td align="center">YES</td><td align="center">NO</td><td align="center">YES</td><td align="center">I+M+Fb</td><td align="center">对于默认的百分比直方图，〜7.7kb</td></tr><tr><td align="center">YES</td><td align="center">YES</td><td align="center">YES</td><td align="center">I+M+Hdr(Pp)</td><td align="center">要添加默认值的0.95％，否则为〜14.3kb</td></tr><tr><td align="center">NO</td><td align="center">NO</td><td align="center">NO</td><td align="center">M</td><td align="center">〜0.1kb</td></tr><tr><td align="center">NO</td><td align="center">NO</td><td align="center">YES</td><td align="center">M+Fb</td><td align="center">对于默认的百分比直方图，〜6kb</td></tr><tr><td align="center">NO</td><td align="center">YES</td><td align="center">YES</td><td align="center">M+Hdr(Pp)</td><td align="center">要添加默认值的0.95％，否则为〜12.6kb</td></tr></tbody></table><blockquote><p>注意</p><blockquote><p>这些估计是基于Micrometer 1.0.3中所做的改进，并且假定至少使用该版本。</p></blockquote></blockquote><blockquote><p>注意</p><blockquote><p>特别是对于Prometheus ，无论您如何尝试通过进行配置Timer.Builder，R 始终等于1 。这对于</p></blockquote></blockquote><p>&amp;emsp;&amp;emsp;Prometheus来说是特殊情况，因为它期望永不翻转的累积直方图数据。</p><h1 id="11-分布式-summaries"><a href="#11-分布式-summaries" class="headerlink" title="11 分布式 summaries"></a>11 分布式 summaries</h1><p>&amp;emsp;&amp;emsp;分布式summaries用于跟踪事件的分布。它在结构上类似于计时器，但记录的值不代表时间单位。例如，分布式summary可用于衡量命中服务器的请求的有效负载大小。</p><p>&amp;emsp;&amp;emsp;要创建一个分布式summary：</p><pre><code>DistributionSummary summary = registry.summary(&quot;response.size&quot;);</code></pre><p>&amp;emsp;&amp;emsp;该接口包含一个流利的分布式summary构建器：</p><pre><code>DistributionSummary summary = DistributionSummary    .builder(&quot;response.size&quot;)    .description(&quot;a description of what this summary does&quot;) // optional    .baseUnit(&quot;bytes&quot;) // optional (1)    .tags(&quot;region&quot;, &quot;test&quot;) // optional    .scale(100) // optional (2)    .register(registry);</code></pre><p>&amp;emsp;&amp;emsp;1.添加基本​​单元以获得最大的可移植性-基本单元是某些监视系统的命名约定的一部分。如果忘记的话，将其保留下来并违反命名约定不会有任何不利影响。</p><p>&amp;emsp;&amp;emsp;2.可选的，我们可以提供一个比例因子，每个记录的样本在记录时将乘以该比例。</p><h2 id="11-1-标度和直方图"><a href="#11-1-标度和直方图" class="headerlink" title="11.1 标度和直方图"></a>11.1 标度和直方图</h2><p>&amp;emsp;&amp;emsp;MicroMeter的预选百分比直方图桶都是从1到最大long的整数。目前minimumExpectedValue和maximumExpectedValue用来控制桶的基数。如果我们尝试检测到您的最小&#x2F;最大值产生较小的范围并将预选的存储桶域缩放到summary的范围，则我们没有其他方法可以控制桶的基数。</p><p>&amp;emsp;&amp;emsp;相反，如果summary的域受到更多限制，则按固定因子缩放摘要的范围。到目前为止，我们所听到的用例是域为[0,1]的比率的汇总。然后：</p><pre><code>DistributionSummary.builder(&quot;my.ratio&quot;).scale(100).register(registry)</code></pre><p>&amp;emsp;&amp;emsp;这样，比率最终会在[0,100]的范围内，我们可以将其设置maximumExpectedValue为100。如果您关心特定的比率，则将其与自定义SLA边界配对：</p><pre><code>DistributionSummary.builder(&quot;my.ratio&quot;)   .scale(100)   .sla(70, 80, 90)   .register(registry)</code></pre><h2 id="11-2-内存占用估算"><a href="#11-2-内存占用估算" class="headerlink" title="11.2 内存占用估算"></a>11.2 内存占用估算</h2><p>&amp;emsp;&amp;emsp;分布式summary的总内存占用量可能会变化很大，具体取决于我们选择的选项。下表是基于各种功能使用情况的内存消耗表。这些数字假定没有标签，并且环形缓冲区的长度为3。添加标签当然会增加总数，增加缓冲区的长度也会有所增加。总存储量也可能会有所不同，具体取决于注册表的实现。</p><ul><li><p>R &#x3D;环形缓冲区的长度。在所有示例中，我们假定默认值为3。R用设置DistributionSummary.Builder#distributionStatisticBufferLength。</p></li><li><p>B &#x3D;总直方图桶。可以是SLA边界或百分比直方图桶。默认情况下，摘要没有最小和最大期望值，因此请装运所有276个预定的直方图桶。当您打算运送百分位直方图时，应始终使用minimumExpectedValue和来固定分布摘要maximumExpectedValue。</p></li><li><p>M &#x3D;最大衰减时间。104字节</p></li><li><p>Fb &#x3D;固定边界直方图。30b * B * R</p></li><li><p>Pp &#x3D;百分位数精度。默认情况下为1。通常在[0，3]范围内。Pp用设置DistributionSummary.Builder#percentilePrecision。</p></li><li><p>Hdr（Pp）&#x3D;高动态范围直方图。</p></li></ul><p>当Pp &#x3D; 0时：1.9kb * R + 0.8kb</p><p>当Pp &#x3D; 1时：3.8kb * R + 1.1kb</p><p>当Pp &#x3D; 2时：18.2kb * R + 4.7kb</p><p>当Pp &#x3D; 3时：66kb * R + 33kb</p><table><thead><tr><th align="center">客户端</th><th align="center">百分位数直方图和&#x2F;或SLA</th><th align="right">公式</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">NO</td><td align="center">NO</td><td align="right">M</td><td align="center">〜0.1kb</td></tr><tr><td align="center">NO</td><td align="center">YES</td><td align="right">M+Fb</td><td align="center">对于固定在66个桶中的百分位直方图，〜6kb</td></tr><tr><td align="center">YES</td><td align="center">YES</td><td align="right">M+Hdr(Pp)</td><td align="center">要添加默认值的0.95％，否则为〜12.6kb</td></tr></tbody></table><blockquote><p>注意</p><blockquote><p>这些估计是基于Micrometer1.0.3中所做的改进，并且假定至少使用该版本。</p></blockquote><p>注意</p><blockquote><p>特别是对于Prometheus ，无论您如何尝试通过DistributionSummary.Builder进行配置，R 始终等于1。这对于Prometheus来说是特殊情况，因为它期望的是永不翻转的累积直方图数据。</p></blockquote></blockquote><hr><h1 id="12-长任务timers"><a href="#12-长任务timers" class="headerlink" title="12.长任务timers"></a>12.长任务timers</h1><p>&amp;emsp;&amp;emsp;长任务timers是一种特殊的timer，可让我们在正在测量的事件仍在运行时测量时间。在任务完成之前，计时器不会持续记录时间。</p><p>&amp;emsp;&amp;emsp;现在考虑一个后台过程来刷新数据存储中的元数据。例如，Edda缓存AWS资源，例如实例、卷、自动扩展组等。通常，所有数据都可以在几分钟内刷新。如果AWS服务出现问题，则可能需要更长的时间。长任务timer可用于跟踪刷新元数据的总时间。</p><p>&amp;emsp;&amp;emsp;例如，在Spring应用程序中，通常使用来实现如此长时间运行的进程@Scheduled。MicroMeter提供了特殊的@Timed注释，用于使用长任务timer来可视化这些过程。</p><pre><code>@Timed(value = &quot;aws.scrape&quot;, longTask = true)@Scheduled(fixedDelay = 360000)void scrapeResources() &#123;// find instances, volumes, auto-scaling groups, etc...&#125;</code></pre><p>&amp;emsp;&amp;emsp;@Timed是否生效取决于应用程序框架。如果所选择的框架不支持它，我们仍然可以使用长任务计时器：</p><pre><code>LongTaskTimer scrapeTimer = registry.more().longTaskTimer(&quot;scrape&quot;);void scrapeResources() &#123;    scrapeTimer.record(() =&gt; &#123;        // find instances, volumes, auto-scaling groups, etc...    &#125;);&#125;</code></pre><p>&amp;emsp;&amp;emsp;如果我们想在此过程超过阈值时发出警报，则需要longtasktimer，超过阈值后，我们将在第一个报告间隔收到该警报。如果使用常规timer，则直到该过程完成后的第一个报告间隔（超过一个小时），我们才会收到警报！</p><p>&amp;emsp;&amp;emsp;该接口包含用于Longtasktimer的流利的构建器：</p><pre><code>LongTaskTimer longTaskTimer = LongTaskTimer    .builder(&quot;long.task.timer&quot;)    .description(&quot;a description of what this timer does&quot;) // optional    .tags(&quot;region&quot;, &quot;test&quot;) // optional    .register(registry);</code></pre><hr><h1 id="13-直方图和百分位数"><a href="#13-直方图和百分位数" class="headerlink" title="13 直方图和百分位数"></a>13 直方图和百分位数</h1><p>&amp;emsp;&amp;emsp;Timer和分布式summary支持收集数据以观察其百分比分布。查看百分位数的主要方法有两种：</p><p>&amp;emsp;&amp;emsp;1.百分比直方图 -MicroMeter将值累加为基础直方图，并将预定的一组buckets集合发送给监视系统。监视系统的查询语言负责计算此直方图的百分位数。目前，只有Prometheus，Atlas，和Wavefront支持直方图基于百分比近似，通过histogram_quantile，:percentile和hs()分别。如果定位到Prometheus，Atlas或Wavefront，则最好使用此方法，因为我们可以汇总各个维度上的直方图（通过简单地将一组维度中各个值的值相加）并从该直方图中得出可凝集的百分位数。</p><p>&amp;emsp;&amp;emsp;2.客户端百分位数 -MicroMeter为每个仪表ID（名称和标签集）计算百分位数近似值，并将百分位数值发送到监视系统。这不能像百分位数直方图那样灵活，因为不可能汇总标签之间的百分位数近似值。但是，它为不支持基于直方图的服务器端百分比计算的监视系统提供了一定百分比的洞察力。</p><p>&amp;emsp;&amp;emsp;这是一个使用直方图构建计时器的示例：</p><pre><code>Timer.builder(&quot;my.timer&quot;)   .publishPercentiles(0.5, 0.95) // median and 95th percentile   .publishPercentileHistogram()   .sla(Duration.ofMillis(100))   .minimumExpectedValue(Duration.ofMillis(1))   .maximumExpectedValue(Duration.ofSeconds(10))</code></pre><p>&amp;emsp;&amp;emsp;1.publishPercentiles-用于发布在我们的应用中计算出的百分位值。这些值在各个维度上都是不可凝聚的。</p><p>&amp;emsp;&amp;emsp;2.publishPercentileHistogram-用于发布直方图，该直方图适用于在Prometheus使用histogram_quantile，Atlas使用:percentile和Wavefront使用中计算可聚集的（跨维度）百分位近似hs()。对于Prometheus和Atlas，结果的直方图中的buckets值由MicroMeter根据由Netflix凭经验确定的生成器进行预设，以在大多数现实世界timer和分布式summary上产生合理的误差。默认情况下，生成器会产生276个存储桶，但Micrometer仅发送那些在设置范围内（包括minimumExpectedValue和maximumExpectedValue）的buckets值。MicroMeter默认将timer限制在1毫秒到1分钟的范围内，每个timer产生73个直方图桶。publishPercentileHistogram 对不支持可凝集百分位数逼近的系统没有影响-这些系统未提供直方图。</p><p>&amp;emsp;&amp;emsp;3.sla-发布包含我们SLA定义的buckets的累积直方图。与publishPercentileHistogram支持可聚集百分位数的监视系统配合使用，此设置将其他buckets添加到已发布的直方图中。在不支持可聚集百分位数的系统上使用时，此设置将导致仅使用这些存储桶发布直方图。</p><p>&amp;emsp;&amp;emsp;4.minimumExpectedValue&#x2F; maximumExpectedValue-控制publishPercentileHistogram发送的存储桶的数量，以及控制基础HdrHistogram结构的准确性和内存占用量。</p><p>&amp;emsp;&amp;emsp;由于将百分位数发送到监视系统会生成其他时间序列，因此通常最好不要在作为依赖项包含在应用程序中的核心库中对其进行配置。取而代之的是，应用程序可以通过meter过滤器为某些计时器&#x2F;分配摘要集启用此行为。</p><p>&amp;emsp;&amp;emsp;例如，假设我们在一个公共库中有几个计时器。我们为这些计时器名称添加了前缀myservice：</p><pre><code>registry.timer(&quot;myservice.http.requests&quot;).record(..);registry.timer(&quot;myservice.db.requests&quot;).record(..);</code></pre><p>&amp;emsp;&amp;emsp;我们可以通过仪表过滤器为两个timer打开客户端百分位数：</p><pre><code>registry.config().meterFilter(    new MeterFilter() &#123;        @Override        public DistributionStatisticConfig configure(Meter.Id id, DistributionStatisticConfig config) &#123;            if(id.getName().startsWith(&quot;myservice&quot;)) &#123;                return DistributionStatisticConfig.builder()                    .percentiles(0.95)                    .build()                    .merge(config);            &#125;            return config;        &#125;    &#125;);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;一、目的&quot;&gt;&lt;a href=&quot;#一、目的&quot; class=&quot;headerlink&quot; title=&quot;一、目的&quot;&gt;&lt;/a&gt;一、目的&lt;/h1&gt;&lt;p&gt;&amp;amp;emsp;&amp;amp;emsp;MicroMeter是针对基于JVM的应用程序
      
    
    </summary>
    
    
      <category term="Monitor System" scheme="http://yoursite.com/categories/Monitor-System/"/>
    
    
  </entry>
  
  <entry>
    <title>小技巧</title>
    <link href="http://yoursite.com/2019/11/11/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2019/11/11/%E5%B0%8F%E6%8A%80%E5%B7%A7/</id>
    <published>2019-11-11T11:24:12.000Z</published>
    <updated>2020-11-06T06:21:42.453Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>for(i&#x3D;0;i&lt;n;i++){<br>}</p><p>for(i&#x3D;n;i;i–){<br>}<br>下面这一项是boolean比较，编译速度要快上一倍；</p><p>不用申请额外空间完成数值交换<br>a &#x3D; a^b<br>b &#x3D; a^b<br>a &#x3D; a^b</p><p>BitMask<br>将帅问题</p><p>python代码实现一遍然后再写一个文档说明。</p><p>模考必考的大体类型<br>KNN算法和聚类算法</p><p>信息熵的概念<br>信息熵的算法<br>解决过拟合问题–剪枝，避免决策树太深</p><hr><h1 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h1><h2 id="一、资源管理工具"><a href="#一、资源管理工具" class="headerlink" title="一、资源管理工具"></a>一、资源管理工具</h2><p>1.1 Kubernate<br>1.2 Docker<br>1.3 OpenStack</p><h2 id="二、硬件加速"><a href="#二、硬件加速" class="headerlink" title="二、硬件加速"></a>二、硬件加速</h2><p>2.1 InfiniBand<br>2.2 NVMESSD<br>2.3 GPU<br>2.4 FPGA<br>2.5 ASIC</p><p>cpu为什么会发热？<br>计算机发生了信息丢失时就会发热，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;for(i&amp;#x3D;0;i&amp;lt;n;i++){&lt;br&gt;}&lt;/p&gt;
&lt;p&gt;for(i&amp;#x3D;n;i;i–){&lt;br&gt;}&lt;br&gt;下面这一项是boolean比较，编译速度要快上一倍；&lt;/p&gt;
&lt;p&gt;不用申请额外空间完成数值交换&lt;br&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>SpringBoot-日志</title>
    <link href="http://yoursite.com/2019/11/10/SpringBoot-%E6%97%A5%E5%BF%97/"/>
    <id>http://yoursite.com/2019/11/10/SpringBoot-%E6%97%A5%E5%BF%97/</id>
    <published>2019-11-10T02:06:55.000Z</published>
    <updated>2020-11-06T06:20:34.612Z</updated>
    
    <content type="html"><![CDATA[<p>在我们的日常开发中，通常需要查看日志来帮我们解决程序运行中的一些错误问题及对程序运行过程的监控，这篇文章主要是讲解在SpringBoot中日志的工作原理、日志实现类的选择、日志的展示及存储方式等内容。</p><a id="more"></a><h1 id="一、常用的日志框架"><a href="#一、常用的日志框架" class="headerlink" title="一、常用的日志框架"></a>一、常用的日志框架</h1><p>JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j….</p><p>其中属于<strong>日志门面</strong>（日志的抽象层）的是：JCL（Jakarta Commons Logging）    <strong>SLF4j</strong>（Simple Logging Facade for Java）、jboss-logging    </p><p>属于日志的<strong>实现类</strong>的是：Log4j2 <strong>Logback</strong>、Log4j JUL（java.util.logging） </p><p>我们一般是选择SLF4j作为抽象层，Logback作为实现类</p><p>springboot也是选用的<strong>SLF4j和Logback</strong></p><hr><h1 id="二、如何在系统中使用SLF4j"><a href="#二、如何在系统中使用SLF4j" class="headerlink" title="二、如何在系统中使用SLF4j"></a>二、如何在系统中使用SLF4j</h1><p>开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法；给系统里面导入slf4j的jar和 logback的实现jar</p><p>具体的实现代码如下：</p><pre><code>import org.slf4j.Logger; import org.slf4j.LoggerFactory;   public class HelloWorld &#123;   public static void main(String[] args) &#123;     Logger logger = LoggerFactory.getLogger(HelloWorld.class);          logger.info(&quot;Hello World&quot;);   &#125;&#125;</code></pre><blockquote><p>抽象类与实现类之间的关系如下所示,每一个日志的实现框架都有自己的配置文件。<br>使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件。</p></blockquote><p><img src="https://wx1.sinaimg.cn/mw690/007857NYgy1g8sqnny7iaj30w00homz4.jpg" alt="抽象类与实现类的关系"></p><hr><h1 id="三、遗留问题"><a href="#三、遗留问题" class="headerlink" title="三、遗留问题"></a>三、遗留问题</h1><p>在springboot中我们含有很多的框架，如Spring、Hebernate、MyBatis等，这些不同的日志框架使用的日志实现类是不相同的，那么我们如何实现不同的日志实现类之间的协调统一呢？</p><p>如：a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx 统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？</p><p><strong>如何让系统中所有的日志都统一到slf4j：</strong></p><pre><code>1、将系统中其他日志框架先排除出去；2、用中间包来替换原有的日志框架； 3、我们导入slf4j其他的实现；</code></pre><p><img src="https://wx4.sinaimg.cn/mw690/007857NYly1g8sr40230bj316e0u00xc.jpg" alt="日志框架的替换类"></p><hr><h1 id="四、SpringBoot的日志依赖关系："><a href="#四、SpringBoot的日志依赖关系：" class="headerlink" title="四、SpringBoot的日志依赖关系："></a>四、SpringBoot的日志依赖关系：</h1><p><img src="https://wx3.sinaimg.cn/mw690/007857NYgy1g8sr81yfcnj30o709f0ta.jpg" alt="日志依赖关系"></p><p>总结：</p><pre><code>1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录2）、SpringBoot也把其他的日志都替换成了slf4j；3）、中间替换包？4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？Spring框架用的是commons-logging；</code></pre><p>如下为在SpringBoot中引入依赖后的<strong>转换jar包</strong></p><p><img src="https://wx4.sinaimg.cn/mw690/007857NYgy1g8sreyk7njj30cp06odg2.jpg" alt="日志转换包"></p><p>SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要 把这个框架依赖的日志框架排除掉即可；</p><pre><code>&lt;dependency&gt;          &lt;groupId&gt;org.springframework&lt;/groupId&gt;          &lt;artifactId&gt;spring‐core&lt;/artifactId&gt;                        &lt;exclusions&gt;              &lt;exclusion&gt;                    &lt;groupId&gt;commons‐logging&lt;/groupId&gt;                    &lt;artifactId&gt;commons‐logging&lt;/artifactId&gt;              &lt;/exclusion&gt;          &lt;/exclusions&gt;&lt;/dependency </code></pre><hr><h1 id="五-日志的使用"><a href="#五-日志的使用" class="headerlink" title="五 日志的使用"></a>五 日志的使用</h1><p>SpringBoot默认帮我们配置好了日志；</p><h2 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h2><pre><code>import org.junit.jupiter.api.Test;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestclass DemoApplicationTests &#123;//日志记录器Logger logger = LoggerFactory.getLogger(getClass());@Testvoid contextLoads() &#123;    //日志的级别由低到高 trace&lt;debug&lt;info&lt;warn&lt;error    //可以调整输出的日志级别，日志就只会在这个级别以后的级别中生效    logger.trace(&quot;这是trace()日志&quot;);    logger.debug(&quot;这是debug日志&quot;);    //springboot默认提供的是info级别    logger.info(&quot;这是info日志&quot;);    logger.warn(&quot;这是warn日志&quot;);    logger.error(&quot;这是error日志&quot;);    &#125;&#125;</code></pre><p>当然我们可以对日志的输出格式、输出位置、默认级别等等做相应的调整</p><pre><code>#指定日志的输出级别，默认条件为info级别的。logging.level.csu = trace#在当前目录下生成springboot.log日志#不指定目录则在当前目录下生成springboot.log日志#logging.file = springboot.log#也可以指定springboot.log的生成路径logging.file= F:/springboot.log#指定控制台输出的文件格式logging.pattern.console==%d&#123;yyyy‐MM‐dd&#125; [%thread] %‐5level %logger&#123;50&#125; ‐ %msg%n #指定文件中日志的输出格式logging.pattern.file=%d&#123;yyyy‐MM‐dd&#125; === [%thread] === %‐5level === %logger&#123;50&#125; ==== %msg%n</code></pre><p>关于<strong>日志的输出格式简介</strong>：</p><pre><code>日志输出格式： %d表示日期时间 %thread表示线程名%‐5level：级别从左显示5个字符宽度          %logger&#123;50&#125; 表示logger名字长50个字符，否则按照句点分割。           %msg：日志消息，         %n是换行符</code></pre><h2 id="指定配置"><a href="#指定配置" class="headerlink" title="指定配置"></a>指定配置</h2><p>给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了</p><p>logback.xml：直接就被日志框架识别了； </p><p>logback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot 的高级Proﬁle功能</p><p>所以我们一般使用加上了“-spring”后缀的命名格式，如下所示在开发过程中就可以指定在开发环境和非开发环境使用的日志格式了。</p><pre><code>&lt;springProfile name=&quot;dev&quot;&gt;                     &lt;pattern&gt;%d&#123;yyyy‐MM‐dd HH:mm:ss.SSS&#125; ‐‐‐‐&gt; [%thread] ‐‐‐&gt; %‐5level  %logger&#123;50&#125; ‐ %msg%n&lt;/pattern&gt;             &lt;/springProfile&gt;             &lt;springProfile name=&quot;!dev&quot;&gt;                     &lt;pattern&gt;%d&#123;yyyy‐MM‐dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %‐5level  %logger&#123;50&#125; ‐ %msg%n&lt;/pattern&gt;             &lt;/springProfile&gt;</code></pre><p>如果直接使用没有“-spring”后缀的格式设置开发环境和非开发环境的日志格式会发生错误；</p><p>当然我们也可以使用在配置中设置环境变量来进行开发环境选择：spring.profiles.active&#x3D;dev  <br><img src="https://wx3.sinaimg.cn/mw690/007857NYgy1g8sslk1dccj311j0ovjst.jpg" alt="环境变量设置">   </p><hr><h1 id="六-切换日志框架"><a href="#六-切换日志框架" class="headerlink" title="六 切换日志框架"></a>六 切换日志框架</h1><p>SpringBoot的默认方式为SLF4j+Logback形式的，现在我们将其切换成SLF4j+log4j的形式，具体操作如下：</p><p><img src="https://wx1.sinaimg.cn/small/007857NYly1g8stgrfhm3j30kg0d70ti.jpg" alt="切换框架1"></p><p><img src="https://wx2.sinaimg.cn/small/007857NYly1g8stgum4ucj30py0870tz.jpg" alt="切换框架2"></p><p><img src="https://wx1.sinaimg.cn/mw690/007857NYly1g8stis21fpj30oa0dtta9.jpg" alt="切换框架3"></p><p><img src="https://wx1.sinaimg.cn/mw690/007857NYly1g8stivul1dj30ry07zweu.jpg" alt="切换框架4"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在我们的日常开发中，通常需要查看日志来帮我们解决程序运行中的一些错误问题及对程序运行过程的监控，这篇文章主要是讲解在SpringBoot中日志的工作原理、日志实现类的选择、日志的展示及存储方式等内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>什么是fail-fast机制？</title>
    <link href="http://yoursite.com/2019/11/04/%E4%BB%80%E4%B9%88%E6%98%AFfail-fast%E6%9C%BA%E5%88%B6%EF%BC%9F/"/>
    <id>http://yoursite.com/2019/11/04/%E4%BB%80%E4%B9%88%E6%98%AFfail-fast%E6%9C%BA%E5%88%B6%EF%BC%9F/</id>
    <published>2019-11-04T12:00:56.000Z</published>
    <updated>2022-05-04T08:09:26.259Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="什么是快速失败机制？"><a href="#什么是快速失败机制？" class="headerlink" title="什么是快速失败机制？"></a>什么是快速失败机制？</h2><blockquote><p><strong>fail-fast</strong> 机制，即快速失败机制，是java集合(Collection)中的一种错误检测机制。当在<strong>迭代集合的过程中该集合在结构上发生改变的时候，就有可能会发生fail-fast</strong>，即抛出ConcurrentModificationException异常。fail-fast机制并不保证在不同步的修改下一定会抛出异常，它只是尽最大努力去抛出，所以这种机制一般仅用于检测bug。</p></blockquote><p>快速失败机制经常出现在我们的集合操作中，快速失败机制是Iterator区别于Enumeration的一大特点。下面是一个fail-fast的示例。</p><p><img src="https://wx1.sinaimg.cn/mw690/007857NYly1g8ma643in5j30y20g9myj.jpg" alt="fail-fast"></p><p>上面的list存储的是String类型的数据，然后将这个list类型的数据进行遍历时删除索引为3的元素值为3的数据值，但是list存储的是String类型所以会出发快速失败机制，日志中会产生ConcurrentModificationException异常，如下所示：</p><p><img src="https://wx1.sinaimg.cn/mw690/007857NYly1g8mad25cqwj31ee07vgmi.jpg" alt="异常截图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h2 id=&quot;什么是快速失败机制？&quot;&gt;&lt;a href=&quot;#什么是快速失败机制？&quot; class=&quot;headerlink&quot; title=&quot;什么是快速失败机制？&quot;&gt;&lt;/a&gt;什么是快速失败机制？&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;stron
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
</feed>
